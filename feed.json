{
    "version": "https://jsonfeed.org/version/1",
    "title": "1asy",
    "subtitle": "Till I no longer can",
    "icon": "https://self-ferry.github.io/images/favicon.ico",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Self-ferry.github.io",
    "items": [
        {
            "id": "https://self-ferry.github.io/2021/05/06/%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/",
            "url": "https://self-ferry.github.io/2021/05/06/%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/",
            "title": "静态、动态链接库、句柄",
            "date_published": "2021-05-06T06:23:36.000Z",
            "content_html": "<h1 id=\"库的介绍\"><a class=\"anchor\" href=\"#库的介绍\">#</a> 库的介绍</h1>\n<p>库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。</p>\n<p>本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。<br />\n库有两种：静态库（.a、.lib）和动态库（.so、.dll）<br />\nwindows 上对应的是.lib .dll<br />\nlinux 上对应的是.a .so</p>\n<p>超详细内容:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2luZy1scHMvcC83NzU3OTE5Lmh0bWw=\">https://www.cnblogs.com/king-lps/p/7757919.html</span></p>\n<h1 id=\"代码复用的实现\"><a class=\"anchor\" href=\"#代码复用的实现\">#</a> 代码复用的实现</h1>\n<ol>\n<li>\n<p>静态链接库</p>\n</li>\n<li>\n<p>动态链接库</p>\n</li>\n<li>\n<p>使用.def 导出</p>\n</li>\n</ol>\n<h1 id=\"静态链接库\"><a class=\"anchor\" href=\"#静态链接库\">#</a> 静态链接库</h1>\n<p>例子为滴水逆向教程中的。</p>\n<h2 id=\"vc60创建静态链接库\"><a class=\"anchor\" href=\"#vc60创建静态链接库\">#</a> VC6.0 创建静态链接库</h2>\n<ol>\n<li>在 VC6 中创建项目：Win32 Static Library</li>\n</ol>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>在项目中创建两个文件：xxx.h 和 xxx.cpp</li>\n</ol>\n<p>xxx.h 文件：</p>\n<pre><code class=\"language-c++\">#if !defined(AFX_TEST_H__DB32E837_3E66_4BE7_B873_C079BC621AF0__INCLUDED_)\n#define AFX_TEST_H__DB32E837_3E66_4BE7_B873_C079BC621AF0__INCLUDED_\n\n#if _MSC_VER &gt; 1000\n#pragma once\n#endif // _MSC_VER &gt; 1000\n\n\nint Plus(int x, int y);\nint Sub(int x, int y);\nint Mul(int x, int y);\nint Div(int x, int y);\n\n\n#endif\n</code></pre>\n<p>xxx.cpp 文件：</p>\n<pre><code class=\"language-c++\">int Plus(int x, int y)\n&#123;\n  return x+y;\n&#125;\nint Sub(int x, int y)\n&#123;\n  return x-y;\n&#125;\nint Mul(int x, int y)\n&#123;\n    return x*y;\n&#125;\nint Div(int x, int y)\n&#123;\n  return x/y;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>编译</li>\n</ol>\n<h2 id=\"使用静态链接库\"><a class=\"anchor\" href=\"#使用静态链接库\">#</a> 使用静态链接库</h2>\n<p>方式一：</p>\n<p>将 xxx.h 和 xxx.lib 复制到要使用的项目中</p>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<p>在需要使用的文件中包含：#include &quot;xxx.h&quot;</p>\n<p>在需要使用的文件中包含：#pragma comment (lib, &quot;xxx.lib&quot;)</p>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n<p>方式二：</p>\n<p>将 xxx.h 和 xxx.lib 复制到要使用的项目中</p>\n<p>在需要使用的文件中包含：#include &quot;xxx.h&quot;</p>\n<p>需要让编译器自己 LINK&quot;lib 库&quot;<br />\n<img data-src=\"image005.png\" alt=\"\" /><br />\n<img data-src=\"image006.png\" alt=\"\" /><br />\n<img data-src=\"image007.png\" alt=\"\" /></p>\n<h1 id=\"动态链接库\"><a class=\"anchor\" href=\"#动态链接库\">#</a> 动态链接库</h1>\n<h2 id=\"创建dll\"><a class=\"anchor\" href=\"#创建dll\">#</a> 创建 DLL</h2>\n<ol>\n<li>\n<p>在 VC6 中创建项目：win32 Dynamic-link library</p>\n</li>\n<li>\n<p>源文件中：</p>\n</li>\n</ol>\n<pre><code class=\"language-c++\">int __stdcall Plus(int x,int y)\n&#123;\n  return x+y;\n&#125;\nint __stdcall Sub(int x,int y)\n&#123;\n  return x-y;\n&#125;\nint __stdcall Mul(int x,int y)\n&#123;\n  return x*y;\n&#125;\nint __stdcall Div(int x,int y)\n&#123;\n  return x/y;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>头文件中</li>\n</ol>\n<pre><code class=\"language-c++\">extern &quot;C&quot; _declspec(dllexport) __stdcall int Plus (int x,int y);\nextern &quot;C&quot; _declspec(dllexport) __stdcall int Sub (int x,int y);\nextern &quot;C&quot; _declspec(dllexport) __stdcall int Mul (int x,int y);\nextern &quot;C&quot; _declspec(dllexport) __stdcall int Div (int x,int y);\n</code></pre>\n<ol start=\"4\">\n<li>编译</li>\n</ol>\n<p>说明:</p>\n<p>1、extern 表示这是个全局函数，可以供各个其他的函数调用；</p>\n<p>2、&quot;C&quot; 按照 C 语言的方式进行编译、链接； __declspec (dllexport) 告诉编译器此函数为导出函数；__stdcall 是为了保持导出与导入时函数调用规则一致，要么都加，要么都不加。</p>\n<h2 id=\"使用dll\"><a class=\"anchor\" href=\"#使用dll\">#</a> 使用 DLL</h2>\n<h3 id=\"方式一隐式连接\"><a class=\"anchor\" href=\"#方式一隐式连接\">#</a> 方式一：隐式连接</h3>\n<p>步骤 1：将 *.dll  *.lib 放到工程目录下面</p>\n<p><img data-src=\"image008.png\" alt=\"\" /></p>\n<p>步骤 2：将 #pragma comment (lib,&quot;DLL 名.lib&quot;) 添加到调用文件中</p>\n<p>步骤 3：加入函数的声明</p>\n<p>extern &quot;C&quot; __declspec(dllimport) __stdcall int Plus (int x,int y);<br />\nextern &quot;C&quot; __declspec(dllimport) __stdcall int Sub (int x,int y);<br />\nextern &quot;C&quot; __declspec(dllimport) __stdcall int Mul (int x,int y);<br />\nextern &quot;C&quot; __declspec(dllimport) __stdcall int Div (int x,int y);</p>\n<p>说明：</p>\n<p>__declspec (dllimport) 告诉编译器此函数为导入函数；</p>\n<p>结果：</p>\n<p><img data-src=\"image009.png\" alt=\"\" /></p>\n<h3 id=\"方式二显示连接\"><a class=\"anchor\" href=\"#方式二显示连接\">#</a> 方式二：显示连接</h3>\n<p>步骤 1：\t// 定义函数指针<br />\n typedef int (__stdcall *lpPlus)(int,int);<br />\ntypedef int (__stdcall *lpSub)(int,int);<br />\ntypedef int (__stdcall *lpMul)(int,int);<br />\ntypedef int (__stdcall *lpDiv)(int,int);</p>\n<p>步骤 2：  // 声明函数指针变量<br />\n lpPlus myPlus;<br />\nlpSub mySub;<br />\nlpMul myMul;<br />\nlpDiv myDiv;</p>\n<p>步骤 3：  //\t// 动态加载 dll 到内存中<br />\n HINSTANCE   hModule = LoadLibrary (&quot;Dll 名.dll&quot;);</p>\n<p>步骤 4：  // 获取函数地址\t<br />\nmyPlus = (lpPlus) GetProcAddress (hModule,   &quot;函数名&quot;);<br />\nmySub = (lpSub) GetProcAddress (hModule,   &quot;函数名&quot;);<br />\nmyMul = (lpMul) GetProcAddress (hModule,   &quot;函数名&quot;);<br />\nmyDiv = (lpDiv) GetProcAddress (hModule,   &quot;函数名&quot;);</p>\n<p>步骤 5：\t// 调用函数<br />\n int a = myPlus (10,2);<br />\nint b = mySub(10,2);<br />\nint c = myMul(10,2);<br />\nint d = myDiv(10,2);</p>\n<p><span class=\"label danger\">💔注意</span></p>\n<p><mark>关于在 DLL 中的函数名</mark></p>\n<p>其实取决于函数名是否更改的关键在于 两个函数转变字__stdcall 和__cdecl<br />\n 如果你用了__stdcall 那 dll 中的函数就会在函数名前加 &quot;-&quot;, 函数名后加 &quot;@x&quot;<br />\n 而__cdecl 则不会将函数改名，因为__cdecl 是函数缺省的状态，所以只要将<br />\n__stdcall 在你的函数声明中去掉就可以了，更详细的区别可以参阅 msdn 中<br />\n的内容。</p>\n<p>结果：</p>\n<p><img data-src=\"image010.png\" alt=\"\" /></p>\n<h1 id=\"句柄\"><a class=\"anchor\" href=\"#句柄\">#</a> 句柄</h1>\n<p>Handle 是代表系统的内核对象，如文件句柄，线程句柄，进程句柄。</p>\n<p>HMODULE 是代表应用程序载入的模块</p>\n<p>HINSTANCE 在 win32 下与 HMODULE 是相同的东西 Win16 遗留</p>\n<p>HWND 是窗口句柄</p>\n<p>其实就是一个无符号整型 (四个字节),Windows 之所以这样设计有 2 个目的：</p>\n<ol>\n<li>\n<p>可读性更好</p>\n</li>\n<li>\n<p>避免在无意中进行运算</p>\n</li>\n</ol>\n",
            "tags": [
                "WindowsPE",
                "静态链接库",
                "动态链接库",
                "句柄"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/05/04/%E6%96%B0%E5%A2%9E%E8%8A%82/",
            "url": "https://self-ferry.github.io/2021/05/04/%E6%96%B0%E5%A2%9E%E8%8A%82/",
            "title": "新增节",
            "date_published": "2021-05-03T20:49:52.000Z",
            "content_html": "<h1 id=\"为什么新增节以及新增节的步骤\"><a class=\"anchor\" href=\"#为什么新增节以及新增节的步骤\">#</a> 为什么新增节。以及新增节的步骤</h1>\n<p>我们的 PE 文件在空白区可以添加代码，但是这样是由一个弊端的，因为你的空白区节属性可能是只读的不能执行，如果你修改了属性。那么程序就可能出现问题，所以新增一个节可以实现我们的代码。</p>\n<h1 id=\"新增节的步骤\"><a class=\"anchor\" href=\"#新增节的步骤\">#</a> 新增节的步骤</h1>\n<p>1. 在最后一个节位置添加一个节。如果没有空白位置。自己需要给扩展头扩大。并且自己修正节的偏移.</p>\n<p>2. 修改文件头中节表个数.</p>\n<p>3. 添加的新节表修改节表的属性 【节.VirtualAddress】 . 这个成员指定了这个节在内存哪里展开。所以需要修改.</p>\n<p>4. 修改节表文件偏移  【节.PointerToRawData】   我们指定了内存中从哪里展开节。那么也需要指定这个节在文件中在哪里展开</p>\n<p>5. 修改节表中的 节数据对齐后的大小 【节.SizeofRawData】  我们新增的节。自己需要在 PE 文件添加一段节数据。数据的大小按照文件对齐添加。并且填写到这个成员中.</p>\n<p>6. 修改扩展头的 PE 镜像大小. 【sizeofImage】 这个成员才是关键。如果不按照内存对齐修改镜像大小。那么我们的节就不会映射到内存中。或者 PE 文件根本无法执行.</p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>在 PE 中，新增节，添加代码</p>\n<h2 id=\"一-先判断节表后是否有空闲位置添加节表信息必须多出两个节表位置最后以零结尾\"><a class=\"anchor\" href=\"#一-先判断节表后是否有空闲位置添加节表信息必须多出两个节表位置最后以零结尾\">#</a> 一、先判断节表后是否有空闲位置，添加节表信息，必须多出两个节表位置，最后以零结尾。</h2>\n<h2 id=\"二-新增节后需要修改以下信息\"><a class=\"anchor\" href=\"#二-新增节后需要修改以下信息\">#</a> 二、新增节后，需要修改以下信息</h2>\n<p>1、添加一个新节，可以复制一份，最好是拥有可执行属性的节，如.text。</p>\n<p>2、在节表区，新增节的后面，填充一个节，用零填充。</p>\n<p>3、修改标准 PE 头中节的数量。</p>\n<p>4、修改 SizeOfImage 的大小。</p>\n<p>5、在原有数据的后面，新增一个节的数据（内存对齐的整倍数）。</p>\n<p>6、修正新增节表的属性。</p>\n<h2 id=\"三-新节各个属性修改说明\"><a class=\"anchor\" href=\"#三-新节各个属性修改说明\">#</a> 三、新节各个属性修改说明</h2>\n<p>1、Name: 名字随便修改，不能超过八个字节。</p>\n<p>2、VirtualSize: 申请的新节空间大小，比如 1000</p>\n<p>3、VirtualAddress: 等于上一个节的 VirtualAddress  +  SizeOfRawData</p>\n<p>4、SizeOfRawData：设置可以和 VirtualSize 一样，比如 1000</p>\n<p>5、PointerToRawData：等于上一个节的 PointerToRawData+  SizeOfRawData</p>\n<p>6、PointerToRelocation：设置成零</p>\n<p>7、PointerToLineNumbers：设置成零</p>\n<p>8、NumberOfLineRelocations：设置成零</p>\n<p>9、NumberOfLineNumbers：设置成零</p>\n<p>10、Characteristics：块属性 0x20000060  可以取上一个节表和本节表的属性值，进行异或  如 x|y</p>\n<h2 id=\"标志属性块-常用特征值对照表\"><a class=\"anchor\" href=\"#标志属性块-常用特征值对照表\">#</a> 标志 (属性块) 常用特征值对照表：</h2>\n<p>[值：00000020h] [IMAGE_SCN_CNT_CODE                // Section contains code.(包含可执行代码)]</p>\n<p>[值：00000040h] [IMAGE_SCN_CNT_INITIALIZED_DATA    // Section contains initialized data.(该块包含已初始化的数据)]</p>\n<p>[值：00000080h] [IMAGE_SCN_CNT_UNINITIALIZED_DATA  // Section contains uninitialized data.(该块包含未初始化的数据)]</p>\n<p>[值：00000200h] [IMAGE_SCN_LNK_INFO                // Section contains comments or some other type of information.]</p>\n<p>[值：00000800h] [IMAGE_SCN_LNK_REMOVE              // Section contents will not become part of image.]</p>\n<p>[值：00001000h] [IMAGE_SCN_LNK_COMDAT              // Section contents comdat.]</p>\n<p>[值：00004000h] [IMAGE_SCN_NO_DEFER_SPEC_EXC       // Reset speculative exceptions handling bits in the TLB entries for this section.]</p>\n<p>[值：00008000h] [IMAGE_SCN_GPREL                   // Section content can be accessed relative to GP.]</p>\n<p>[值：00500000h] [IMAGE_SCN_ALIGN_16BYTES           // Default alignment if no others are specified.]</p>\n<p>[值：01000000h] [IMAGE_SCN_LNK_NRELOC_OVFL         // Section contains extended relocations.]</p>\n<p>[值：02000000h] [IMAGE_SCN_MEM_DISCARDABLE         // Section can be discarded.]</p>\n<p>[值：04000000h] [IMAGE_SCN_MEM_NOT_CACHED          // Section is not cachable.]</p>\n<p>[值：08000000h] [IMAGE_SCN_MEM_NOT_PAGED           // Section is not pageable.]</p>\n<p>[值：10000000h] [IMAGE_SCN_MEM_SHARED              // Section is shareable (该块为共享块).]</p>\n<p>[值：20000000h] [IMAGE_SCN_MEM_EXECUTE             // Section is executable.(该块可执行)]</p>\n<p>[值：40000000h] [IMAGE_SCN_MEM_READ                // Section is readable.(该块可读)]</p>\n<p>[值：80000000h] [IMAGE_SCN_MEM_WRITE               // Section is writeable.(该块可写)]</p>\n<hr />\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p>很详细：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3VtYWMvcC81Mjc0NTU5Lmh0bWw=\">https://www.cnblogs.com/wumac/p/5274559.html</span><br />\n 有详细实操步骤：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaUJpbmFyeS9wLzk3Mzc3MTkuaHRtbA==\">https://www.cnblogs.com/iBinary/p/9737719.html</span></p>\n<p>实操了一篇还行。</p>\n",
            "tags": [
                "WindowsPE",
                "新增节"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/05/02/%E6%89%A9%E5%A4%A7%E8%8A%82/",
            "url": "https://self-ferry.github.io/2021/05/02/%E6%89%A9%E5%A4%A7%E8%8A%82/",
            "title": "扩大节",
            "date_published": "2021-05-02T09:26:17.000Z",
            "content_html": "<h1 id=\"为什么扩大节\"><a class=\"anchor\" href=\"#为什么扩大节\">#</a> 为什么扩大节？</h1>\n<p><code>我们可以在任意空白区添加自己的代码，但如果添加的代码比较多，空白区不够怎么办？</code></p>\n<p>上面我们讲了，空白区添加我们的代码。但是有的时候。我们的空白区不够了怎么办。所以需要进行扩大节.</p>\n<p>扩大节其实很简单。修改节数据对齐后的大小即可。并且在 PE 文件中添加 0 数据进行填充即可.</p>\n<p>首先看一下我们的节表</p>\n<pre><code class=\"language-c++\">typedef struct _IMAGE_SECTION_HEADER &#123;\n    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; //8个字节名字.自己可以起.编译器也可以给定.不重要.\n    union &#123;\n            DWORD   PhysicalAddress;       \n            DWORD   VirtualSize;           //节数据没有对齐后的大小.也就是没有对齐.节数据有多大.\n    &#125; Misc;\n    DWORD   VirtualAddress;　　　　　　　　　　//加载到内存中的第一个字节的地址.也就是虚拟地址.节在内存中哪里开始.内存中的VA + ImageBase 才是真正的节开始位置\n    DWORD   SizeOfRawData;　　　　　　　　　　 //修改这个属性的值,即可扩大节.并且在PE文件中添加相应的0数据进行填充.\n    DWORD   PointerToRawData;　　　　　　　　  //在文件中的偏移.是文件对齐成员倍数.\n    DWORD   PointerToRelocations;           //一下都是调试相关.\n    DWORD   PointerToLinenumbers;           //\n    WORD    NumberOfRelocations;\n    WORD    NumberOfLinenumbers;\n    DWORD   Characteristics;　　　　　　　　　　//节的属性\n&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n</code></pre>\n<h1 id=\"扩大哪一个节呢\"><a class=\"anchor\" href=\"#扩大哪一个节呢\">#</a> 扩大哪一个节呢？</h1>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>若是扩大前面几个节，则后面的节都要改动。所以一般扩大最后一个节。</p>\n<h1 id=\"扩大节的步骤\"><a class=\"anchor\" href=\"#扩大节的步骤\">#</a> 扩大节的步骤</h1>\n<ol>\n<li>\n<p>分配一块新的空间，大小为 <code>S</code></p>\n</li>\n<li>\n<p>将最后一个节的 SizeOfRawData 和 VirtualSize 改为 N<br />\n <code>N = (SizeOfRawData或者VirtualSize内存对齐后的值) + S</code></p>\n</li>\n<li>\n<p>修改 SizeOflmage 大小</p>\n</li>\n</ol>\n<h1 id=\"推荐\"><a class=\"anchor\" href=\"#推荐\">#</a> 推荐</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaUJpbmFyeS9wLzk3MzUyNzYuaHRtbA==\">https://www.cnblogs.com/iBinary/p/9735276.html</span></p>\n",
            "tags": [
                "WindowsPE",
                "扩大节"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/05/02/%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/",
            "url": "https://self-ferry.github.io/2021/05/02/%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/",
            "title": "在空白区添加代码",
            "date_published": "2021-05-02T08:58:55.000Z",
            "content_html": "<h1 id=\"在代码空白区添加代码手动\"><a class=\"anchor\" href=\"#在代码空白区添加代码手动\">#</a> 在代码空白区添加代码 (手动)</h1>\n<p><code>添加的是硬编码</code></p>\n<p>1、获取 MessageBox 地址，构造 ShellCode 代码</p>\n<p>2、E8 E9 计算公式</p>\n<p>3、在代码区手动添加代码</p>\n<p>4、修改入口地址，指向 ShellCode<br />\n 入口地址:xxxx</p>\n<p>call 0x12345678 \t\t\tCall 0x77E5425F</p>\n<p>E8 53 FE FF FF</p>\n<p>jmp 0x2345678</p>\n<p>E9 2B 2B 00 00</p>\n<p>真正要跳转的地址 = E8 这条指令的下一行地址 + X</p>\n<p>X = 真正要跳转的地址 - E8 这条指令的下一行地址</p>\n<p>X = 00401050 - 004011FD</p>\n<p>X = 00403b80 - 00401055</p>\n<p>要跳转的地方 = E8 当前的地址 + 5 + X</p>\n<p>X = 要跳转的地址 - (E8 的地址 + 5)</p>\n<p>6A 00 6A 00 6A 00 6A 00 E8 00 00 00 00 E9 00 00 00 00</p>\n<h1 id=\"实战\"><a class=\"anchor\" href=\"#实战\">#</a> 实战</h1>\n<p>OD 查找 MessageBox 位置。</p>\n<p>显示模块窗口。</p>\n<p>找到 USER32.dll, 双击进入后， <code>Ctrl+N</code>  打开当前模块的名称（标签）列表。在里面查找 MessageBox。</p>\n<p>MessageBox:0x76321930<br />\nMessageBox - ImageBase -508 - 5 =  75F2 1423<br />\n401000</p>\n<p>3F FAEE</p>\n<p>6A 00 6A 00 6A 00 6A 00 E8 23 14 F2 75 E9 EE FA 3F 00</p>\n<p>00007FFDA9672180</p>\n",
            "tags": [
                "WindowsPE",
                "空白区添加代码"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/05/02/RVA%E4%B8%8EFOA%E8%BD%AC%E6%8D%A2/",
            "url": "https://self-ferry.github.io/2021/05/02/RVA%E4%B8%8EFOA%E8%BD%AC%E6%8D%A2/",
            "title": "RVA与FOA转换",
            "date_published": "2021-05-02T08:05:32.000Z",
            "content_html": "<h1 id=\"引出问题\"><a class=\"anchor\" href=\"#引出问题\">#</a> 引出问题</h1>\n<p><code>如果想改变一个全区变量的初始值，该怎么做？</code></p>\n<p>如果一个变量有值，那这个值是存储在 PE 中的。</p>\n<p>有一个小细节：定义一个变量，当它加载在内存中的时候才会有默认初始值的。在 C 中定义一个整型变量，不给它赋值打印它，默认是为 0 的。</p>\n<p><code>面临的问题是什么？</code></p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<h1 id=\"转换\"><a class=\"anchor\" href=\"#转换\">#</a> 转换</h1>\n<p><span class=\"label\">RVA: 相对虚拟地址</span><br />\n<span class=\"label\"> FOA: 文件偏移地址</span></p>\n<ol>\n<li>RVA TO FOA</li>\n</ol>\n<p>即我们现在知道内存状态下的偏移，需要找到文件状态下的偏移。<br />\n步骤如下图：</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<p>step1：内存中的地址减去内存基址得到偏移，即 RVA。<br />\nstep2：循环遍历节表中各个节的信息，判断在哪个节中。（需要满足：内存偏移 + 节数据没对齐的大小 &gt; image_panyi &gt; 内存偏移）<br />\nstep3: 找出在哪个节后，减去该节在内存中的偏移（VirturalAddress）得到在该节中的相对偏移。<br />\nstep4: 上一步得到的该节的相对偏移 + 该节在文件中的偏移 (PointToRawData)，即得到 FOA</p>\n<ol start=\"2\">\n<li>FOA TO RVA</li>\n</ol>\n<p>现在我们已经知道如何从内存中的偏移转化为文件中的偏移。现在是它的逆过程<br />\n step1: 文件中的地址减去文件基址，得到在文件中的偏移，即 FOA。<br />\nstep2: 循环遍历节表中各个节的信息，判断在哪个节中。（文件对齐 + 文件偏移 &gt; file_panyi &gt; 文件偏移）<br />\nstep3: 找出在哪个节后，减去该节在文件中的偏移（VirturalAddress）得到在该节中的相对偏移。<br />\nstep4: 上一步得到的该节的相对偏移 + 该节在内存中的偏移 (VirtualAddress)，即得到 RVA。</p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>RVA 转换 FOA，在以后的破解或者保护中只是基本功而已！基础要打牢。</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzgwNTAwODc3NS9hcnRpY2xlL2RldGFpbHMvMTA1Mzc0NTAz\">https://blog.csdn.net/z17805008775/article/details/105374503</span></p>\n",
            "tags": [
                "WindowsPE",
                "RVA与FOA"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/04/25/C%E3%80%81C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "https://self-ferry.github.io/2021/04/25/C%E3%80%81C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "C、C++学习笔记",
            "date_published": "2021-04-25T08:49:55.000Z",
            "content_html": "<h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/04/20/Linux%E4%B8%AD%E7%9A%84su%E4%B8%8Esu-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://self-ferry.github.io/2021/04/20/Linux%E4%B8%AD%E7%9A%84su%E4%B8%8Esu-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "Linux中的su与su -命令的区别",
            "date_published": "2021-04-20T14:26:01.000Z",
            "content_html": "<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p>详情见<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5oYTk3LmNvbS80MDAxLmh0bWw=\"> http://www.ha97.com/4001.html</span></p>\n<h2 id=\"区别\"><a class=\"anchor\" href=\"#区别\">#</a> 区别</h2>\n<p>su 命令和 su - 命令最大的本质区别就是：前者只是切换了 root 身份，但 Shell 环境仍然是普通用户的 Shell；而后者连用户和 Shell 环境一起切换成 root 身份了。只有切换了 Shell 环境才不会出现 PATH 环境变量错误。su 切换成 root 用户以后，pwd 一下，发现工作目录仍然是普通用户的工作目录；而用 su - 命令切换以后，工作目录变成 root 的工作目录了。用 echo $PATH 命令看一下 su 和 su - 以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用 su - 命令。</p>\n",
            "tags": [
                "Linux",
                "Linux"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/04/20/Linux%E9%85%8D%E7%BD%AEvsftp/",
            "url": "https://self-ferry.github.io/2021/04/20/Linux%E9%85%8D%E7%BD%AEvsftp/",
            "title": "Linux配置vsftp",
            "date_published": "2021-04-20T02:41:51.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>Linux 网络服务课的作业。虽然简单，但也让我踩了不少坑，记个笔记吧。<br />\n作业的内容是可以匿名上传或删除文件就可。</p>\n<h1 id=\"正文\"><a class=\"anchor\" href=\"#正文\">#</a> 正文</h1>\n<p>先换个 yum 的源，下载的快一点。<br />\n <code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></p>\n<p>换源前也可以先备份一下。<br />\n这里的详细内容可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1ZGluYW5peWEvYXJ0aWNsZS9kZXRhaWxzLzEwNTc1ODczOQ==\"> https://blog.csdn.net/wudinaniya/article/details/105758739</span></p>\n<h2 id=\"下载vsftp\"><a class=\"anchor\" href=\"#下载vsftp\">#</a> 下载 vsftp</h2>\n<p><code>yum -y install vsftpd</code></p>\n<h2 id=\"查看是否安装成功\"><a class=\"anchor\" href=\"#查看是否安装成功\">#</a> 查看是否安装成功</h2>\n<p><code>rpm -qa|grep vsftpd</code></p>\n<h2 id=\"关闭一切墙策略selinux\"><a class=\"anchor\" href=\"#关闭一切墙策略selinux\">#</a> 关闭一切墙 | 策略 | SELINUX</h2>\n<p><code>systemctl stop firewalld</code> <br />\n <code>iptables -F</code></p>\n<p>关闭 SELINUX，有两种方法：<br />\n临时关闭：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># getenforce</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Enforcing</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># setenforce 0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># getenforce</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Permissive</pre></td></tr></table></figure><p>永久关闭：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># vim /etc/sysconfig/selinux</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token assign-left variable\">SELINUX</span><span class=\"token operator\">=</span>enforcing 改为 <span class=\"token assign-left variable\">SELINUX</span><span class=\"token operator\">=</span>disabled</pre></td></tr></table></figure><p>重启服务 reboot</p>\n<h2 id=\"修改vsftpdconfig\"><a class=\"anchor\" href=\"#修改vsftpdconfig\">#</a> 修改 vsftpd.config</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>修改配置文件 /etc/vsftpd.conf</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token assign-left variable\">anonymous_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许匿名访问</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token assign-left variable\">write_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许写文件</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token assign-left variable\">anon_upload_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许匿名用户上传文件</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token assign-left variable\">anon_mkdir_write_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许匿名用户创建目录和写权限</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token assign-left variable\">anon_other_write_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许匿名用户删除、重命名等其它权限  这个在配置文件里默认找不到</span></pre></td></tr></table></figure><h2 id=\"这里附上详细的vsftpconfig配置\"><a class=\"anchor\" href=\"#这里附上详细的vsftpconfig配置\">#</a> 这里附上详细的 vsftp.config 配置</h2>\n<p>vsftpd 的配置文件在为 vsftpd.conf，一般在 /etc/vsftpd/ 目录下。</p>\n<table>\n    <tr>\n        <th>属性</th>\n        <th>属性值</th>\n        <th align=\"left\">含义</th>\n    </tr>\n    <tr>\n        <td>anonymous_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许匿名用户（anonymous）登录 <code>FTP</code>，如果该设置被注释，则默认允许</td>\n    </tr>\n    <tr>\n        <td>local_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许本地系统用户登录</td>\n    </tr>\n    <tr>\n        <td>write_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否开启任何形式的 <code>FTP</code> 写入命令，上传文件</td>\n    </tr>\n    <tr>\n        <td>local_umask</td>\n        <td>xxx</td>\n        <td align=\"left\">本地用户的 <code>umask</code> 设置，如果注释该设置则默认为 <code>077</code>，但一般都设置成 <code>022</code></td>\n    </tr>\n    <tr>\n        <td>anon_upload_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许匿名用户上传文件，如果要设置为允许，则需要先开启 <code>write_enable</code>，否则无效，此外对应目录还要具有写权限</td>\n    </tr>\n    <tr>\n        <td>anon_mkdir_write_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许匿名用户创建新目录</td>\n    </tr>\n    <tr>\n        <td>dirmessage_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">当进入某个目录时，发送信息提示给远程用户</td>\n    </tr>\n    <tr>\n        <td>xferlog_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否开启 上传/下载 的日志记录</td>\n    </tr>\n    <tr>\n        <td>connect_from_port_20</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否使用 <code>20</code> 端口来连接 <code>FTP</code></td>\n    </tr>\n    <tr>\n        <td>chown_uploads</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">匿名上传的文件是否由某一指定用户 <code>chown_username</code> 所有</td>\n    </tr>\n    <tr>\n        <td>chown_username</td>\n        <td>有效用户名</td>\n        <td align=\"left\">匿名上传的文件由该设定用户所有</td>\n    </tr>\n    <tr>\n        <td>xferlog_file</td>\n        <td>有效路径</td>\n        <td align=\"left\">设置日志文件的保存位置，默认为 <code>/var/log/xferlog</code></td>\n    </tr>\n    <tr>\n        <td>xferlog_std_format</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否使用标准的 <code>ftpd xferlog</code>日志格式，该格式日志默认保存在 <code>/var/log/xferlog</code></td>\n    </tr>\n    <tr>\n        <td>idle_session_timeout</td>\n        <td>数值</td>\n        <td align=\"left\">设置空闲连接的超时时间，单位 秒</td>\n    </tr>\n    <tr>\n        <td>data_connection_timeout</td>\n        <td>数值</td>\n        <td align=\"left\">设置等待数据传输的最大时间，单位 秒（<code>data_connection_timeout</code> 与 <code>idle_session_timeout</code>\n            在同一时间只有一个有效）\n        </td>\n    </tr>\n    <tr>\n        <td>nopriv_user</td>\n        <td>有效用户名</td>\n        <td align=\"left\">指定一个非特权用户，用于运行 <code>vsftpd</code></td>\n    </tr>\n    <tr>\n        <td>async_abor_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否支持异步 <code>ABOR</code> 请求</td>\n    </tr>\n    <tr>\n        <td>ascii_upload_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否开启 <code>ASCII</code> 模式进行文件上传，一般不开启</td>\n    </tr>\n    <tr>\n        <td>ascii_download_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否开启 <code>ASCII</code> 模式进行文件下载，一般不开启</td>\n    </tr>\n    <tr>\n        <td>ftpd_banner</td>\n        <td>…</td>\n        <td align=\"left\">自定义登录标语</td>\n    </tr>\n    <tr>\n        <td>deny_email_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">如果匿名登录，则会要求输入 email 地址，如果不希望一些 email 地址具有登录权限，则可以开启此项，并在 <code>banned_email_file</code>\n            指定的文件中写入对应的 email 地址\n        </td>\n    </tr>\n    <tr>\n        <td>banned_email_file</td>\n        <td>有效文件</td>\n        <td align=\"left\">当开启 <code>deny_email_enable</code> 时，需要通过此项指定一个保存登录无效 email 的文件</td>\n    </tr>\n    <tr>\n        <td>chroot_local_user</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否将所有用户限制在主目录，当为 <code>NO</code> 时， <code>FTP</code> 用户可以切换到其他目录</td>\n    </tr>\n    <tr>\n        <td>chroot_list_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否启用限制用户的名单列表</td>\n    </tr>\n    <tr>\n        <td>chroot_list_file</td>\n        <td>有效文件</td>\n        <td align=\"left\">用户列表，其作用与 <code>chroot_local_user</code> 和 <code>chroot_local_user</code> 的组合有关，详见下表</td>\n    </tr>\n    <tr>\n        <td>allow_writeable_chroot</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许用户对 ftp 根目录具有写权限，如果设置成不允许而目录实际上却具备写权限，则会报错</td>\n    </tr>\n    <tr>\n        <td>ls_recurse_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许 <code>ls -R</code> 指令来递归查询，递归查询比较耗资源</td>\n    </tr>\n    <tr>\n        <td>listen</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">如果为 <code>YES</code>，<code>vsftpd</code> 将以独立模式运行并监听 <code>IPv4</code> 的套接字，处理相关连接请求（该指令不能与\n            <code>listen_ipv6</code> 一起使用）\n        </td>\n    </tr>\n    <tr>\n        <td>listen_ipv6</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许监听 <code>IPv6</code> 套接字</td>\n    </tr>\n    <tr>\n        <td>pam_service_name</td>\n        <td>…</td>\n        <td align=\"left\">设置 <code>PAM</code> 外挂模块提供的认证服务所使用的配置文件名 ，即 <code>/etc/pam.d/vsftpd</code> 文件，此文件中 <code>file=/etc/vsftpd/ftpusers</code>\n            字段，说明了 <code>PAM</code> 模块能抵挡的帐号内容来自文件 <code>/etc/vsftpd/ftpusers</code> 中\n        </td>\n    </tr>\n    <tr>\n        <td>userlist_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否启用 <code>user_list</code> 文件来控制用户登录</td>\n    </tr>\n    <tr>\n        <td>userlist_deny</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否拒绝 <code>user_list</code> 中的用户登录，此属性设置需在 <code>userlist_enable = YES</code> 时才有效</td>\n    </tr>\n    <tr>\n        <td>tcp_wrappers</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否使用 <code>tcp_wrappers</code> 作为主机访问控制方式</td>\n    </tr>\n    <tr>\n        <td>max_clients</td>\n        <td>数值</td>\n        <td align=\"left\">同一时间允许的最大连接数</td>\n    </tr>\n    <tr>\n        <td>max_per_ip</td>\n        <td>数值</td>\n        <td align=\"left\">同一个IP客户端连接的最大值</td>\n    </tr>\n    <tr>\n        <td>local_root</td>\n        <td>有效目录</td>\n        <td align=\"left\">系统用户登录后的根目录</td>\n    </tr>\n    <tr>\n        <td>anon_root</td>\n        <td>有效目录</td>\n        <td align=\"left\">匿名用户登录后的根目录</td>\n    </tr>\n    <tr>\n        <td>user_config_dir</td>\n        <td>有效目录</td>\n        <td align=\"left\">用户单独配置文件存放目录，该目录下用户的文件名就是对应用户名</td>\n    </tr>\n</table>\n<h2 id=\"以上搞完之后还要把ftp目录的权限给更改\"><a class=\"anchor\" href=\"#以上搞完之后还要把ftp目录的权限给更改\">#</a> 以上搞完之后还要把 ftp 目录的权限给更改</h2>\n<p><code>chmod 777 /var/ftp/pub</code></p>\n<p>这里只能更改 ftp 目录下的子目录的权限。这就是个坑，当更改 /etc/ftp/ 这个目录的权限时，都没法登陆这个 ftp 服务器了。<br />\n当然是可以更改 ftp 下的目录的，在 vsftpd.config 中配置。</p>\n",
            "tags": [
                "Linux",
                "CentOS7配置vsftp"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/30/win32%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8B%E4%BB%B6%E6%B6%88%E6%81%AF/",
            "url": "https://self-ferry.github.io/2021/03/30/win32%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8B%E4%BB%B6%E6%B6%88%E6%81%AF/",
            "title": "win32（二）事件消息",
            "date_published": "2021-03-30T14:32:27.000Z",
            "content_html": "<h1 id=\"事件-消息\"><a class=\"anchor\" href=\"#事件-消息\">#</a> 事件 消息</h1>\n<p>Windows 中的事件是一个 &quot;动作&quot;，这个动作可能是用户操作应用程序产生的，也可能是 Windows 自己产生的.</p>\n<p>而消息，就是用来描述这些 &quot;动作&quot; 的，比如：</p>\n<p>这个动作是什么时候产生的？</p>\n<p>哪个应用程序产生的？</p>\n<p>在什么位置产生的？<br />\n等等。。。</p>\n<p><span class=\"label\">事件驱动消息，消息封装事件</span></p>\n<p>Windows 为了能够准确的描述这些信息，提供了一个结构体：MSG，该结构体里面记录的事件的详细信息.</p>\n<pre><code class=\"language-c++\">typedef struct tagMSG &#123;    \n\nHWND hwnd;     // 窗口句柄\n\nUINT message;     //消息类型\n\nWPARAM wParam;     // 对消息类型进一步描述\n\nLPARAM lParam;     //同上\n\nDWORD time;     // 动作发生时间\n\nPOINT pt;     //坐标，结构体封装了，内部是x，y\n\n&#125; MSG, *PMSG;     \n</code></pre>\n<p>说明：</p>\n<p>1、hwnd：</p>\n<p>表示消息所属的窗口</p>\n<p>一个消息一般都是与某个窗口相关联的</p>\n<p>在 Windows 中 HWND 类型的变量通常用来标识窗口。</p>\n<p>2、message</p>\n<p>在 Windows 中，消息是由一个数值来表示的</p>\n<p>但是由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏（WM == Window Message）</p>\n<p>鼠标左键按下 WM_LBUTTONDOWN        键盘按下 WM_KEYDOWN</p>\n<p>3、wParam 和 lParam</p>\n<p>32 位消息的特定附加信息，具体表示什么处决于 message</p>\n<p>4、time</p>\n<p>消息创建时的时间</p>\n<p>5、消息创建时的鼠标位置</p>\n<p>具体来说：如下图，用户输入后，封装成消息，加入系统的消息队列，然后应用程序那还有队列</p>\n<p>用来存储自己的消息队列，所以系统队列到应用程序队列是分流而治的过程。</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>从队列中取出消息，使用的是循环机制，就是不停的取出消息，而后面的判断消息类型是不是我们关心的意思其实是</p>\n<p>我们是否写了该消息下的响应函数，或者说回调函数。</p>\n<p>具体流程如下图：</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<h1 id=\"创建一个窗口程序\"><a class=\"anchor\" href=\"#创建一个窗口程序\">#</a> 创建一个窗口程序</h1>\n<p>步骤 1：创建 Windows 应用程序 选择空项目</p>\n<p>步骤 2：在新建项窗口中选 C++ 代码文件 创建一个新的 cpp 文件</p>\n<p>步骤 3：在新的 cpp 文件中添加: <code>#include &lt;Windows.h&gt;</code></p>\n<p>并添加入口函数：</p>\n<pre><code class=\"language-c++\">int CALLBACK WinMain(                 CALLBACK 是一个宏             \n\n_In_ HINSTANCE hInstance,         #define CALLBACK __stdcall    \n\n_In_ HINSTANCE hPrevInstance,     \n\n_In_ LPSTR lpCmdLine,                 \n\n_In_ int nCmdShow             \n\n)                     所有的Win32 API函数都遵循该约定    \n\n&#123;                     \n\nreturn 0;             \n\n&#125;                     \n\n</code></pre>\n<p>步骤 4：设计窗口类</p>\n<p>代码：</p>\n<pre><code class=\"language-c++\">\n//窗口的类名    \n\nTCHAR className[] = &quot;My First Window&quot;;     \n\n// 创建窗口类的对象     \n\nWNDCLASS wndclass = &#123;0&#125;;        //一定要先将所有值赋值    \n\nwndclass.hbrBackground = (HBRUSH)COLOR_MENU;        //窗口的背景色    \n\nwndclass.lpfnWndProc = WindowProc;        //窗口过程函数    \n\nwndclass.lpszClassName = className;        //窗口类的名字    \n\nwndclass.hInstance = hInstance;        //定义窗口类的应用程序的实例句柄    \n\n</code></pre>\n<p>步骤 5：注册窗口类    ，这是什么？哈哈哈，就是把结构体赋值后传参调用。</p>\n<pre><code class=\"language-c++\">RegisterClass(&amp;wndclass);     \n\n</code></pre>\n<p>步骤 6：创建窗口</p>\n<pre><code class=\"language-c++\">// 创建窗口     \n\nHWND hwnd = CreateWindow(     \n\nclassName,        //类名    \n\nTEXT(&quot;我的第一个窗口&quot;),        //窗口标题    \n\nWS_OVERLAPPEDWINDOW,        //窗口外观样式     \n\n10,        //相对于父窗口的X坐标    \n\n10,        //相对于父窗口的Y坐标    \n\n600,        //窗口的宽度     \n\n300,        //窗口的高度     \n\nNULL,        //父窗口句柄，为NULL     \n\nNULL,        //菜单句柄，为NULL     \n\nhInstance,        //当前应用程序的句柄     \n\nNULL);        //附加数据一般为NULL    \n\nif(hwnd == NULL)        //是否创建成功     \n\nreturn 0;     \n\n</code></pre>\n<p>步骤 7：显示窗口</p>\n<pre><code class=\"language-c++\">// 显示窗口     \n\nShowWindow(hwnd, SW_SHOW);     \n</code></pre>\n<p>步骤 8：消息循环</p>\n<pre><code class=\"language-c++\">MSG msg;     \n\nwhile(GetMessage(&amp;msg, NULL, 0, 0))     \n\n&#123;     \n\nTranslateMessage(&amp;msg);     \n\nDispatchMessage(&amp;msg);     \n\n&#125;     \n</code></pre>\n<p>步骤 9：回调函数</p>\n<pre><code class=\"language-c++\">/*                        \n\n窗口消息处理程序 窗口回调函数：            \n\n1、窗口回调函数处理过的消息，必须传回0.        \n\n2、窗口回调不处理的消息，由DefWindowProc来处理.    \n\n*/                        \n\nLRESULT CALLBACK WindowProc(         \n\nIN HWND hwnd,     \n\nIN UINT uMsg,     \n\nIN WPARAM wParam,     \n\nIN LPARAM lParam     \n\n)     \n\n&#123;     \n\nswitch(uMsg)    \n\n&#123;    \n\n//窗口消息    \n\ncase WM_CREATE:     \n\n&#123;    \n\nDbgPrintf(&quot;WM_CREATE %d %d\\n&quot;,wParam,lParam);    \n\nCREATESTRUCT* createst = (CREATESTRUCT*)lParam;    \n\nDbgPrintf(&quot;CREATESTRUCT %s\\n&quot;,createst-&gt;lpszClass);    \n\nreturn 0;    \n\n&#125;    \n\ncase WM_MOVE:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_MOVE %d %d\\n&quot;,wParam,lParam);    \n\nPOINTS points = MAKEPOINTS(lParam);    \n\nDbgPrintf(&quot;X Y %d %d\\n&quot;,points.x,points.y);    \n\nreturn 0;    \n\n&#125;    \n\ncase WM_SIZE:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_SIZE %d %d\\n&quot;,wParam,lParam);    \n\nint newWidth = (int)(short) LOWORD(lParam);     \n\nint newHeight = (int)(short) HIWORD(lParam);     \n\nDbgPrintf(&quot;WM_SIZE %d %d\\n&quot;,newWidth,newHeight);    \n\nreturn 0;    \n\n&#125;    \n\ncase WM_DESTROY:    //销毁\n\n&#123;    \n\nDbgPrintf(&quot;WM_DESTROY %d %d\\n&quot;,wParam,lParam);    \n\nPostQuitMessage(0);    \n\nreturn 0;    \n\n&#125;    \n\n//键盘消息    \n\ncase WM_KEYUP:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_KEYUP %d %d\\n&quot;,wParam,lParam);    \n\nreturn 0;    \n\n&#125;    \n\ncase WM_KEYDOWN:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_KEYDOWN %d %d\\n&quot;,wParam,lParam);    \n\nreturn 0;    \n\n&#125;    \n\n//鼠标消息    \n\ncase WM_LBUTTONDOWN:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_LBUTTONDOWN %d %d\\n&quot;,wParam,lParam);    \n\nPOINTS points = MAKEPOINTS(lParam);    \n\nDbgPrintf(&quot;WM_LBUTTONDOWN %d %d\\n&quot;,points.x,points.y);    \n\nreturn 0;    \n\n&#125;    \n\n&#125;    \n\nreturn DefWindowProc(hwnd,uMsg,wParam,lParam);    //扔给windows处理其他消息\n\n&#125;     \n\n</code></pre>\n<p>MFC 就是基于此封装</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p>滴水逆向课件</p>\n",
            "tags": [
                "win32",
                "widows"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/30/win32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/",
            "url": "https://self-ferry.github.io/2021/03/30/win32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/",
            "title": "win32学习（一）",
            "date_published": "2021-03-30T07:14:33.000Z",
            "content_html": "<h1 id=\"winmain-函数\"><a class=\"anchor\" href=\"#winmain-函数\">#</a> WinMain 函数</h1>\n<pre><code class=\"language-c++\">int WINAPI WinMain(\n  HINSTANCE hInstance, // 应用程序当前实例的句柄\n\tHINSTANCE hPrevInstance, // 应用程序的先前实例的句柄。同一个程序打开两次，出现两个窗口，第一次打开的窗口就是先前实例的窗口。对于一个32位程序，该参数总为NULL。\n\tLPSTR IpCmdLine, // 命令行的字符串的指针\n\tint nShowCmd  // 窗口显示方式、默认为SW_SHOWDEFAULT\n);\n</code></pre>\n<p>WinMain 函数接收 4 个参数，这些参数都是在系统调用 WinMain 函数时，传递给应用程序的。</p>\n<p>第一个参数 hInstance 表示该程序当前运行的实例的句柄，这是一个数值。当程序在 Windows 下运行时，它唯一标识运行中的实例（注意，只有运行中的程序实例，才有实例句柄）。一个应用程序可以运行多个实例，每运行一个实例，系统都会给该实例分配一个句柄值，并通过 hInstance 参数传递给 WinMain 函数。</p>\n<p>第二个参数 hPrevInstance 表示当前实例的前一个实例的句柄。通过查看 MSDN 我们可以知道，在 Win32 环境下，这个参数总是 NULL ，即在 Win32 环境下，这个参数不再起作用。</p>\n<p>第三个参数 lpCmdLine 是一个以空终止的字符串，指定传递给应用程序的命令行参数。 例如：在 D 盘下有一个 sunxin.txt 文件，当我们用鼠标双击这个文件时将启动记事本程序（ notepad.exe ），此时系统会将 D:/sunxin.txt 作为命令行参数传递给记事本程序的 WinMain 函数，记事本程序在得到这个文件的全路径名后，就在窗口中显示该文件的内容。要在 VC++ 开发环境中向应用程序传递参数，可以单击菜单 【 Project 】→【 Settings 】，选择 “Debug” 选项卡，在 “ Program arguments ” 编辑框中输入你想传递给应用程序的参数。</p>\n<p>第四个参数 nCmdShow 指定程序的窗口应该如何显示，例如最大化、最小化、隐藏等。这个参数的值由该程序的调用者所指定，在调用 ShowWindow () 时可以使用到该值</p>\n<p>=============================================================</p>\n<p><span class=\"label\">应用程序句柄</span></p>\n<p>WinMain 函数的第一个参数 hInstance 就是可执行文件的实例句柄，实际上是个内存地址，它指出系统在何处把 exe 文件装载入进程的地址空间！<br />\nPE 中的 ImageBase</p>\n<p><span class=\"label\">窗口显示方式</span></p>\n<p>第四个参数 nCmdShow，指定窗口第一次出现 (程序刚刚启动时) 时的显示方式。显示方式有多种，比如：</p>\n<p>不显示，nCmdShow = 0;<br />\n 正常显示，nCmdShow = 1;(默认为 1)<br />\n 最小化显示，nCmdShow = 2;<br />\n 最大化显示，nCmdShow = 3;<br />\n 如果需要改变系统的默认的显示方式，需要在创建窗口之前指定 nCmdShow 的值 (通过一个简单的赋值语句 nCmdShow = n)</p>\n<p>不过，其实这里要让 nCmdShow 起作用，需要把 nCmdShow 作为参数传递给 ShowWindow 函数</p>\n<pre><code class=\"language-c++\">/*\n * ShowWindow() Commands\n */\n#define SW_HIDE             0\n#define SW_SHOWNORMAL       1\n#define SW_NORMAL           1     激活并显示一个窗口。如果窗口被最小化或最大化，系统 将其恢复到原来的尺寸和大小。应用程序 在第一次显示窗口的时候应该指定此标志。\n#define SW_SHOWMINIMIZED    2     激活窗口并将其最小化。\n#define SW_SHOWMAXIMIZED    3     激活窗口并将其最大化。\n#define SW_MAXIMIZE         3     最大化指定的窗口。\n#define SW_SHOWNOACTIVATE   4     以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。\n#define SW_SHOW             5     在窗口原来的位置以原来的尺寸激活和显示窗口。\n#define SW_MINIMIZE         6     最小化指定的窗口并且激活在Z序中的下一个顶层窗口。\n#define SW_SHOWMINNOACTIVE  7\n#define SW_SHOWNA           8     以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。\n#define SW_RESTORE          9     激活并显示窗口。如果窗口最小化或最大化，则系统 将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序 应该指定这个标志。\n#define SW_SHOWDEFAULT      10     依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序 的程序 传递给CreateProcess函数的。\n#define SW_FORCEMINIMIZE    11     在WindowNT5.0中最小化窗口，即使拥有窗口的线程被挂起也会最小化。在从其他线程最小化窗口时才使用这个参数。\n#define SW_MAX              11\n</code></pre>\n<h1 id=\"winapi和apientry\"><a class=\"anchor\" href=\"#winapi和apientry\">#</a> WINAPI 和 APIENTRY</h1>\n<p>另外，这里稍微说明一下  <code>WINAPI</code>  这个宏定义，我们看 WinMain 函数的原型：</p>\n<pre><code class=\"language-c++\">int WINAPI WinMain(\n    HINSTANCE hInstance,\n    HINSTANCE hPreInstance,\n    LPSTR     lpCmdLine,\n    int       nCmdShow\n);\n</code></pre>\n<p>WINAPI 是这样定义的：</p>\n<p><code>#define WINAPI      __stdcall</code></p>\n<p>在 VC6.0 下生成的 WinMain 函数，实际上是：</p>\n<pre><code class=\"language-c++\">int APIENTRY WinMain(\n    HINSTANCE hInstance,\n    HINSTANCE hPreInstance,\n    LPSTR     lpCmdLine,\n    int       nCmdShow\n);\n</code></pre>\n<p>APIENTRY 这个定义为：</p>\n<p><code>#define APIENTRY    WINAPI</code></p>\n<p>所以归根到底都是  <code>__stdcall</code> ，这个是什么东西了？这里解释一下：</p>\n<p><code>__stdcall</code>  一种调用约定 (调用函数时候的一种约定)，其他的调用约定有：</p>\n<p><code>__cdecl 和 __fastcall</code></p>\n<p>调用约定将决定以下内容：</p>\n<p>1) 函数参数的压栈顺序，</p>\n<p>2) 由调用者还是被调用者把参数弹出栈，</p>\n<p>3) 以及产生函数修饰名的方法。</p>\n<p>WIN32API 使用的是 <code>__stdcall</code>  调用约定</p>\n<p>标准 C，C++ 使用的是 <code>__cdecl</code>  调用约定</p>\n<p><code>__stdcall</code>  调用约定：函数的参数自右向左压栈，被调用的函数在返回前清理传送参数的内存栈</p>\n<p><code>__cdecl</code>  调用约定：每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用 <code>_stdcall</code>  函数的大。函数采用从右到左的压栈方式。注意：对于可变参数的成员函数，始终使用 <code>__cdecl</code>  的调用约定</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zMDI0Nzc4MS9hcnRpY2xlL2RldGFpbHMvOTcxNDE1MTg=\">https://blog.csdn.net/weixin_30247781/article/details/97141518</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjMzMzU1MS9hcnRpY2xlL2RldGFpbHMvMTEzMjUwOTk5\">https://blog.csdn.net/weixin_42333551/article/details/113250999</span></p>\n",
            "tags": [
                "win32",
                "WinMain函数"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/24/%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0/",
            "url": "https://self-ferry.github.io/2021/03/24/%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0/",
            "title": "汇编复习",
            "date_published": "2021-03-24T12:19:17.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>之前学的，因为一些事情就耽搁了，转而学其他的了，现在有时间了，打算接着学，发现忘的差不多了。只能重学了。<br />\n逆水行舟，不进则退。</p>\n<h1 id=\"内存格式\"><a class=\"anchor\" href=\"#内存格式\">#</a> 内存格式</h1>\n<ol>\n<li>每个内存单元宽度为 8</li>\n<li>【0x 编号】称为内存地址</li>\n<li>内存是存储数据的，内存地址是对存储数据的一个标识，指向数据却不是数据，通过内存地址的指引，可以访问到内存当中指向的数据.</li>\n</ol>\n<p>内存最小的单位是一个字节 ==&gt;&gt; 8 个二进制数  ==&gt;&gt; 两位的十六进制数</p>\n<p>一个内存单元能存一个两位的十六进制数，而这就是内存数据</p>\n<h1 id=\"简单指令intel汇编语法\"><a class=\"anchor\" href=\"#简单指令intel汇编语法\">#</a> 简单指令 (intel 汇编语法)</h1>\n<h2 id=\"mov\"><a class=\"anchor\" href=\"#mov\">#</a> mov</h2>\n<p>格式：  <code>mov destination, source</code></p>\n<p><code>mov eax, ebx</code>   // 将 EBX 中的内容复制到 EAX 寄存器中<br />\n <code>mov eax, 0x42</code>  // 将立即数 0x42 复制到 EAX 寄存器中<br />\n <code>mov eax, [0x443212C4]</code>  // 将内存地址 0x443212C4 的四个字节复制到 EAX 寄存器<br />\n <code>mov eax, [ebx+esi*4]</code>   // 将 ebx+esi*4 等式结果只想的内存地址处 4 个字节复制至 EAX</p>\n<h2 id=\"lea\"><a class=\"anchor\" href=\"#lea\">#</a> lea</h2>\n<p>格式：  <code>lea destination, source</code></p>\n<p>lea 指令用来将一个内存地址赋给目的操作数。<br />\n例如，  <code>lea eax, [ebx+8]</code>  就是将 EBX+8 的值给 EAX。<br />\n相反的， <code>mov eax, [ebx+8]</code>  则加载内存中地址为 EBX+8 处的数据。</p>\n<h2 id=\"算术运算\"><a class=\"anchor\" href=\"#算术运算\">#</a> 算术运算</h2>\n<h3 id=\"加减运算\"><a class=\"anchor\" href=\"#加减运算\">#</a> 加减运算</h3>\n<p><span class=\"label\">例子</span></p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:left\">指令</td>\n<td style=\"text-align:left\">描述</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sub eax,0x10</td>\n<td style=\"text-align:left\">EAX 寄存器值减去 0x10</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">add eax,ebx</td>\n<td style=\"text-align:left\">将 EBX 值加入 EAX 并将结果保存至 EAX</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">inc edx</td>\n<td style=\"text-align:left\">EDX 值递增 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dec ecx</td>\n<td style=\"text-align:left\">ECX 值递减 1</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"乘除运算\"><a class=\"anchor\" href=\"#乘除运算\">#</a> 乘除运算</h3>\n<p>乘法和除法都使用了一个预先规定的寄存器。因此其运算就是指令码加上寄存器要去乘除的值。<br />\n <code>mul</code>  和 <code>div</code>  指令要操作的寄存器一般会在之前许多条指令的地方被赋值，因此你可能需要在程序的上下文中来寻找。<br />\n <code>mul value</code>  指令总是将 <code>eax</code>  乘上 <code>value</code> 。因此， <code>EAX</code>  寄存器必须在乘法指令出现前就赋值好。</p>\n<p>乘法的结果以 64 位的形式分开存储在两个寄存器中： <code>EDX</code>  和 <code>EAX</code> 。其中 EDX 存储了高的 32 位，EAX 存储低的 32 位。</p>\n<p>32 位模式下，MUL（无符号数乘法）指令有三种类型：</p>\n<pre><code>第一种执行 8 位操作数与 AL 寄存器的乘法；\n第二种执行 16 位操作数与 AX 寄存器的乘法；\n第三种执行 32 位操作数与 EAX 寄存器的乘法。\n</code></pre>\n<p>乘数和被乘数的大小必须保持一致，乘积的大小则是它们的一倍。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数：</p>\n<pre><code>MUL reg/mem8\nMUL reg/meml6\nMUL reg/mem32\n</code></pre>\n<p>MUL 指令中的单操作数是乘数。下表按照乘数的大小，列出了默认的被乘数和乘积。由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。</p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:left\">被乘数</td>\n<td style=\"text-align:left\">乘数</td>\n<td style=\"text-align:left\">乘积</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AL</td>\n<td style=\"text-align:left\">reg/mem8</td>\n<td style=\"text-align:left\">AX</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AX</td>\n<td style=\"text-align:left\">reg/mem16</td>\n<td style=\"text-align:left\">DX:AX</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">EAX</td>\n<td style=\"text-align:left\">reg/mem32</td>\n<td style=\"text-align:left\">EDX:EAX</td>\n</tr>\n</tbody>\n</table>\n<p>如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置 1。因为进位标志位常常用于无符号数的算术运算，在此我们也主要说明这种情况。例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。</p>\n<p>有个很好的理由要求在执行 MUL 后检查进位标志位，即，确认忽略乘积的高半部分是否安全。</p>\n<p>32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下：</p>\n<pre><code>DIV reg/mem8\nDIV reg/meml6\nDIV reg/mem32\n</code></pre>\n<p>下表给出了被除数、除数、商和余数之间的关系：</p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:left\">被除数</td>\n<td style=\"text-align:left\">除数</td>\n<td style=\"text-align:left\">商</td>\n<td>余数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AX</td>\n<td style=\"text-align:left\">reg/mem8</td>\n<td style=\"text-align:left\">AL</td>\n<td>AH</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DX:AX</td>\n<td style=\"text-align:left\">reg/mem16</td>\n<td style=\"text-align:left\">AX</td>\n<td>DX</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">EDX:EAX</td>\n<td style=\"text-align:left\">reg/mem32</td>\n<td style=\"text-align:left\">EAX</td>\n<td>EDX</td>\n</tr>\n</tbody>\n</table>\n<p>64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数，商存放到 RAX，余数存放在 RDX 中。</p>\n<h2 id=\"逻辑运算符\"><a class=\"anchor\" href=\"#逻辑运算符\">#</a> 逻辑运算符</h2>\n<ol>\n<li>否操作指令 NOT</li>\n</ol>\n<p><code>NOT OPRD</code></p>\n<p>把 OPRD 取反，再回送给 OPRD</p>\n<p>对标志位没有影响</p>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>与操作指令 AND [与]</li>\n</ol>\n<p><code>AND OPRD1，OPRD2</code></p>\n<p>OPRD1 和 OPRD2 执行与操作，结果送到 OPRD1</p>\n<p>执行后，CF＝OF＝0，标志 PF，ZF，SF 反映运算结果，AF 未定义</p>\n<p>某个操作数自身与，值不变，可使进位标志 CF＝0</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p><span class=\"label\">例子</span></p>\n<p><code>mov al, 00001111b</code> <br />\n <code>and al, 11110101b</code></p>\n<p>最后 <code>al</code>  的结果就是 <code>00000101b</code></p>\n<ol start=\"3\">\n<li>或操作指令 OR [或]</li>\n</ol>\n<p><code>OR OPRD1 OPRD2</code></p>\n<p>标志位同与运算指令</p>\n<p>某个操作数自身或，值不变，可使进位标志 CF＝0</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<ol start=\"4\">\n<li>异或操作指令 XOR [异或]</li>\n</ol>\n<p><code>XOR OPRD1 OPRD2</code></p>\n<p>标志位同与运算指令</p>\n<p>某个操作数自身异或，值不变，可使进位标志 CF＝0</p>\n<p>与 0 异或，不变，与 1 异或，取反。</p>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n<ol start=\"5\">\n<li>测试指令 TEST</li>\n</ol>\n<p><code>TEST OPRD1 OPRD2</code></p>\n<p>指令与 AND 类似，但结果不回送</p>\n<p>指令执行后，ZF，PF，SF 反映运算结果，CF＝OF＝0</p>\n<h2 id=\"移位指令\"><a class=\"anchor\" href=\"#移位指令\">#</a> 移位指令</h2>\n<p>移位指令分为算术移位和逻辑移位。</p>\n<p>移动操作数的位有两种方法。第一种是逻辑移位 (logic shift)，空出来的位用 0 填充。如下图所示，一个字节的数据向右移动一位。也就是说，每一位都被移动到其旁边的低位上。注意，位 7 被填充为 0：</p>\n<p><img data-src=\"image005.png\" alt=\"\" /></p>\n<p>下图所示为二进制数 1100 1111 逻辑右移一位，得到 OllOOlll。最低位移入进位标志位：</p>\n<p><img data-src=\"image006.png\" alt=\"\" /></p>\n<p>另一种移位的方法是算术移位 (arithmetic shift)，空出来的位用原数据的符号位填充：</p>\n<p><img data-src=\"image007.png\" alt=\"\" /></p>\n<p>例如，二进制数 1100 1111，符号位为 1。算术右移一位后，得到 1110 0111：</p>\n<p><img data-src=\"image008.png\" alt=\"\" /></p>\n<p>逻辑移位:   <code>SHL</code> 、 <code>SHR</code> <br />\n 算术移位:   <code>CAL</code> 、 <code>CAR</code></p>\n<p>无符号数的乘法和除法可以用逻辑移位；<br />\n 有符号数的乘法和除法可以用算术移位；</p>\n<h3 id=\"逻辑移位指令\"><a class=\"anchor\" href=\"#逻辑移位指令\">#</a> 逻辑移位指令</h3>\n<p>SHL（左移）指令使目的操作数逻辑左移一位，最低位用 0 填充。最高位移入进位标志位，而进位标志位中原来的数值被丢弃<br />\n SHR（右移）指令使目的操作数逻辑右移一位，最高位用 0 填充。最低位复制到进位标志位，而进位标志位中原来的数值被丢弃</p>\n<p>SHL/SHR 的第一个操作数是目的操作数，第二个操作数是移位次数：<br />\nSHL/SHR destination,count</p>\n<p>该指令可用的操作数类型如下所示：<br />\nSHL/SHR reg, imm8<br />\nSHL/SHR mem, imm8<br />\nSHL/SHR reg, CL<br />\nSHL/SHR mem, CL</p>\n<p>x86 处理器允许 imm8 为 0〜255 中的任何整数。另外，CL 寄存器包含的是移位计数。上述格式同样适用于 SHR、SAL、SAR、ROR、ROL、RCR 和 RCL 指令。</p>\n<h3 id=\"算术移位指令\"><a class=\"anchor\" href=\"#算术移位指令\">#</a> 算术移位指令</h3>\n<p>算数移位指令分为：算数左移 SAL (Shift Algebraic Left) 和算数右移 SAR (Shift Algebraic Right);<br />\n 指令格式:  <code>SAL/SAR reg/mem,CL/imm</code> <br />\n 受影响的标志位：CF,OF,PF,SF,ZF; 对 AF 的影响无定义；</p>\n<h3 id=\"循环移位指令\"><a class=\"anchor\" href=\"#循环移位指令\">#</a> 循环移位指令</h3>\n<p>循环移位指令 ror 和 rol 与移位指令类似，但移出的那一位会被填到另一端空出来的位置上，即右循环指令（ror）会将最低位循环一到最高位；左循环移位（rol）则相反。</p>\n<h2 id=\"nop指令\"><a class=\"anchor\" href=\"#nop指令\">#</a> NOP 指令</h2>\n<p>nop 指令什么也不做。当它出现时，直接执行下一条指令。<br />\nnop 指令实际上是 xchg eax,eax 的一个谓名字</p>\n<h1 id=\"栈\"><a class=\"anchor\" href=\"#栈\">#</a> 栈</h1>\n<h2 id=\"posh-指令\"><a class=\"anchor\" href=\"#posh-指令\">#</a> posh 指令</h2>\n<h1 id=\"renference\"><a class=\"anchor\" href=\"#renference\">#</a> Renference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjI3MjM1L2FydGljbGUvZGV0YWlscy84MDM2ODI1NA==\">https://blog.csdn.net/qq_41627235/article/details/80368254</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZW5rdS5iYWlkdS5jb20vdmlldy81MThkM2U4NWRmMzZhMzJkNzM3NWE0MTc4NjZmYjg0YWU0NWNjMzg2Lmh0bWw=\">https://wenku.baidu.com/view/518d3e85df36a32d7375a417866fb84ae45cc386.html</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodWhlamlhbzE1MTYvYXJ0aWNsZS9kZXRhaWxzLzEwMDg3NTEwNQ==\">https://blog.csdn.net/chuhejiao1516/article/details/100875105</span><br />\n<span class=\"exturl\" data-url=\"aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzM1ODkuaHRtbA==\">http://c.biancheng.net/view/3589.html</span></p>\n",
            "tags": [
                "汇编",
                "x86汇编指令"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/24/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/",
            "url": "https://self-ferry.github.io/2021/03/24/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/",
            "title": "密码学数论基础",
            "date_published": "2021-03-24T06:19:48.000Z",
            "content_html": "<h1 id=\"数论基础\"><a class=\"anchor\" href=\"#数论基础\">#</a> 数论基础</h1>\n<h2 id=\"整除性和带余除法\"><a class=\"anchor\" href=\"#整除性和带余除法\">#</a> 整除性和带余除法</h2>\n<h2 id=\"整除性\"><a class=\"anchor\" href=\"#整除性\">#</a> 整除性</h2>\n<p><span class=\"label\">定义：</span><br />\na、b 是两个整数，b≠0 ，如果存在一个整数 m 使等式 a=m*b 成立，则称 b 整除 a，记为 b|a,a 是被除数，b 是除数。</p>\n<p>a/b 记为 b|a a 除以 b 记为 b 整除 a</p>\n<p><span class=\"label\">性质：</span></p>\n<ul>\n<li>若 a|1， 则 a=±1。</li>\n<li>若 a|b 且 b|a，则 a=±b。</li>\n<li>任何不等于零的数整除 0。</li>\n<li>若 a|b 且 b|c，则 a|c。<br />\n <code>11|66 且 66|198 =&gt; 11|198</code></li>\n<li>对任意整数 m，n，若 b|g 且 b|h，则可得出 b|（mg+nh）。</li>\n</ul>\n<p>之所以得出最后一条结论，是因为：</p>\n<ul>\n<li>若 b|g，存在 g1，使得 g 可以表示为 g=b*g1</li>\n<li>若 b|h, 则存在 h1，使得还可以表示为 h=b*h1</li>\n</ul>\n<p>所以：<br />\n <code>mg + nh = mbg1 + nbh1 = b * (mg1 + nh1)</code> <br />\n 得出 b 整除 mg+nh。</p>\n<p><span class=\"label\">例题</span><br />\n<img data-src=\"image001.png\" alt=\"\" /></p>\n<h3 id=\"带余除法\"><a class=\"anchor\" href=\"#带余除法\">#</a> 带余除法</h3>\n<p>对给定的任意一个正整数 n 和任意非负整数 a, 若用 n 除 a, 得到整数商 q 和整数余数 r, 则满足以下关系式:<br />\n <code>a = qn + r, 0 ≤ r &lt; n; q = |(a|b)|</code></p>\n<h2 id=\"欧几里得算法\"><a class=\"anchor\" href=\"#欧几里得算法\">#</a> 欧几里得算法</h2>\n<h3 id=\"最大公约数\"><a class=\"anchor\" href=\"#最大公约数\">#</a> 最大公约数</h3>\n<p>最大公约数，也称最大公因数、最大公因子，指两个或多个整数共有约数中最大的一个。</p>\n<p>对于整数 a,b,m, 若满足 a=mb, 则称非零整数 b 是 a 的一个因子。我们用 gcd (a,b) 来表示 a 的最大公因子。a 和 b 的最大公因子是能同时整除 a 和 b 的最大整数。另外，定义 gcd (0,0)=0。<br />\n更正式的描述是，正整数 c 称为 a 和 b 的最大公因子，如果<br />\n (1) c 是 a 和 b 的因子。<br />\n(2) a、b 的因子都是 c 的一个因子。</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n",
            "tags": [
                "密码编码学与网络安全",
                "数论基础"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/23/%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/",
            "url": "https://self-ferry.github.io/2021/03/23/%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/",
            "title": "数组与矩阵",
            "date_published": "2021-03-23T11:09:25.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=\"]}]'></div></div>\n<h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/03/23/pandas%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "url": "https://self-ferry.github.io/2021/03/23/pandas%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "title": "pandas库学习",
            "date_published": "2021-03-23T11:08:13.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=\"]}]'></div></div>\n<h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/03/23/numpy%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "url": "https://self-ferry.github.io/2021/03/23/numpy%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "title": "numpy库学习",
            "date_published": "2021-03-23T11:07:40.000Z",
            "content_html": "<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9udW1weS9udW1weS10dXRvcmlhbC5odG1s\">https://www.runoob.com/numpy/numpy-tutorial.html</span></p>\n<h1 id=\"numpy库简介\"><a class=\"anchor\" href=\"#numpy库简介\">#</a> Numpy 库简介</h1>\n<p>NumPy (Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p>\n<p>NumPy 的前身 Numeric 最早是由 Jim Hugunin 与其它协作者共同开发，2005 年，Travis Oliphant 在 Numeric 中结合了另一个同性质的程序库 Numarray 的特色，并加入了其它扩展而开发了 NumPy。NumPy 为开放源代码并且由许多协作者共同维护开发。</p>\n<p>NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：</p>\n<ul>\n<li>一个强大的 N 维数组对象 ndarray</li>\n<li>广播功能函数</li>\n<li>整合 C/C++/Fortran 代码的工具</li>\n<li>线性代数、傅里叶变换、随机数生成等功能</li>\n</ul>\n<h1 id=\"numpy-应用\"><a class=\"anchor\" href=\"#numpy-应用\">#</a> NumPy 应用</h1>\n<p>NumPy 通常与 SciPy（Scientific Python）和 Matplotlib（绘图库）一起使用， 这种组合广泛用于替代 MatLab，是一个强大的科学计算环境，有助于我们通过 Python 学习数据科学或者机器学习。</p>\n<p>SciPy 是一个开源的 Python 算法库和数学工具包。</p>\n<p>SciPy 包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。</p>\n<p>Matplotlib 是 Python 编程语言及其数值数学扩展包 NumPy 的可视化操作界面。它为利用通用的图形用户界面工具包，如 Tkinter, wxPython, Qt 或 GTK+ 向应用程序嵌入式绘图提供了应用程序接口（API）。</p>\n<h1 id=\"相关链接\"><a class=\"anchor\" href=\"#相关链接\">#</a> 相关链接</h1>\n<p>NumPy 官网 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5udW1weS5vcmcv\">http://www.numpy.org/</span><br />\nNumPy 源代码：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL251bXB5L251bXB5\">https://github.com/numpy/numpy</span></p>\n<h1 id=\"numpy-ndarray对象\"><a class=\"anchor\" href=\"#numpy-ndarray对象\">#</a> Numpy Ndarray 对象</h1>\n<p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</p>\n<p>ndarray 对象是用于存放同类型元素的多维数组。</p>\n<p>ndarray 中的每个元素在内存中都有相同存储大小的区域。</p>\n<p>ndarray 内部由以下内容组成：</p>\n<ul>\n<li>\n<p>一个指向数据（内存或内存映射文件中的一块数据）的指针。</p>\n</li>\n<li>\n<p>数据类型或 dtype，描述在数组中的固定大小值的格子。</p>\n</li>\n<li>\n<p>一个表示数组形状（shape）的元组，表示各维度大小的元组。</p>\n</li>\n<li>\n<p>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要 &quot;跨过&quot; 的字节数。</p>\n</li>\n</ul>\n<h1 id=\"创建ndarray\"><a class=\"anchor\" href=\"#创建ndarray\">#</a> 创建 Ndarray</h1>\n<p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：<br />\n <code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p>\n<p>参数说明：</p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:right\">名称</td>\n<td style=\"text-align:left\">描述</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">object</td>\n<td style=\"text-align:left\">数组或嵌套的数列</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">dtype</td>\n<td style=\"text-align:left\">数组元素的数据类型，可选</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">copy</td>\n<td style=\"text-align:left\">对象是否需要复制，可选</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">order</td>\n<td style=\"text-align:left\">创建数组的样式，C 为行方向，F 为列方向，A 为任意方向（默认）</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">subok</td>\n<td style=\"text-align:left\">默认返回一个与基类类型一致的数组</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">ndmin</td>\n<td style=\"text-align:left\">指定生成数组的最小维度</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"认识numpy的数组对象ndarray\"><a class=\"anchor\" href=\"#认识numpy的数组对象ndarray\">#</a> 认识 Numpy 的数组对象 Ndarray</h1>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># -*- coding: utf-8 -*-</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 代码 2-1</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np  <span class=\"token comment\"># 导入 NumPy 库</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>arr1 <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 创建一维数组</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">' 创建的数组为： '</span><span class=\"token punctuation\">,</span> arr1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># 创建二维数组</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>arr2 <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的数组为：\\n'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组类型为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">.</span>dtype<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看数组类型</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组元素个数为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看数组元素个数</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组每个元素大小为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">.</span>itemsize<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看数组每个元素大小</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\"># 代码 2-2</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>arr2<span class=\"token punctuation\">.</span>shape <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span>  <span class=\"token comment\"># 重新设置 shape</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'重新设置shape 后的arr2 为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\"># 代码 2-3</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用arange函数创建的数组为：\\n'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\"># 代码 2-4</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用linspace函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>linspace<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\"># 代码 2-5</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用logspace函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>logspace<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token comment\"># 代码 2-6</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用zeros函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>zeros<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\"># 代码 2-7</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用eye函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>eye<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\"># 代码 2-8</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用diag函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>diag<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token comment\"># 代码 2-9</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用ones函数的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>ones<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token comment\"># 代码 2-10</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>float64<span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 整型转换为浮点型</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>int8<span class=\"token punctuation\">(</span><span class=\"token number\">42.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 浮点型转换为整型</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 整型转换为布尔型</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 整型转换为布尔型</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span><span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 布尔型转换为浮点型</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span><span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 布尔型转换为浮点型</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre></pre></td></tr><tr><td data-num=\"50\"></td><td><pre><span class=\"token comment\"># 代码 2-11</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>df <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>dtype<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>str_<span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"numitems\"</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>int64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>               <span class=\"token punctuation\">(</span><span class=\"token string\">\"price\"</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>float64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数据类型为：'</span><span class=\"token punctuation\">,</span> df<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre></pre></td></tr><tr><td data-num=\"55\"></td><td><pre><span class=\"token comment\"># 代码 2-12</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数据类型为：'</span><span class=\"token punctuation\">,</span> df<span class=\"token punctuation\">[</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数据类型为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>dtype<span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">[</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre></pre></td></tr><tr><td data-num=\"59\"></td><td><pre><span class=\"token comment\"># 代码 2-13</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>itemz <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tomatoes\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4.14</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"cabbages\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">13</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.72</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>                 dtype<span class=\"token operator\">=</span>df<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'自定义数据为：'</span><span class=\"token punctuation\">,</span> itemz<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre></pre></td></tr><tr><td data-num=\"64\"></td><td><pre><span class=\"token comment\"># 代码 2-14</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'生成的随机数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre></pre></td></tr><tr><td data-num=\"67\"></td><td><pre><span class=\"token comment\"># 代码 2-15</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'生成的随机数组为：\\n'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>rand<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre></pre></td></tr><tr><td data-num=\"70\"></td><td><pre><span class=\"token comment\"># 代码 2-16</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'生成的随机数组为：\\n'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>randn<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre></pre></td></tr><tr><td data-num=\"73\"></td><td><pre><span class=\"token comment\"># 代码 2-17</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'生成的随机数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>randint<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> size<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre></pre></td></tr><tr><td data-num=\"76\"></td><td><pre><span class=\"token comment\"># 代码 2-18</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 用整数作为下标可以获取数组中的某个元素</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre><span class=\"token comment\"># 用范围作为下标获取数组的一个切片，包括 arr [3] 不包括 arr [5]</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 省略开始下标，表示从 arr [0] 开始</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre><span class=\"token comment\"># 下标可以使用负数，-1 表示从数组后往前数的第一个元素</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>arr<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">101</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 下标还可以用来修改元素的值</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre><span class=\"token comment\"># 范围中的第三个参数表示步长，2 表示隔一个元素取一个元素</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 步长为负数时，开始下标必须大于结束下标</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre></pre></td></tr><tr><td data-num=\"91\"></td><td><pre><span class=\"token comment\"># 代码 2-19</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的二维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 索引第 0 行中第 3 和第 4 列的元素</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre><span class=\"token comment\"># 索引第 2 和第 3 行中第 3 列、第 4 列和第 5 列的元素</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：\\n'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 索引第 2 列的元素</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre></pre></td></tr><tr><td data-num=\"99\"></td><td><pre><span class=\"token comment\"># 代码 2-20</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre><span class=\"token comment\"># 从两个序列的对应位置取出两个整数组成下标：arr [0,1], arr [1,2], arr [2,3]</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 索引第 2、3 行中第 0、2、3 列的元素</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>mask <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span>np<span class=\"token punctuation\">.</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"105\"></td><td><pre><span class=\"token comment\"># mask 是一个布尔数组，它索引第 1、3 行中第 2 列的元素</span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>mask<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre></pre></td></tr><tr><td data-num=\"108\"></td><td><pre><span class=\"token comment\"># 代码 2-21</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 创建一维数组</span></pre></td></tr><tr><td data-num=\"110\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的一维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"111\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'新的一维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 设置数组的形状</span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组维度为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>ndim<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看数组维度</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre></pre></td></tr><tr><td data-num=\"114\"></td><td><pre><span class=\"token comment\"># 代码 2-22</span></pre></td></tr><tr><td data-num=\"115\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"116\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的二维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"117\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组展平后为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>ravel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"118\"></td><td><pre></pre></td></tr><tr><td data-num=\"119\"></td><td><pre><span class=\"token comment\"># 代码 2-23</span></pre></td></tr><tr><td data-num=\"120\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组展平为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>flatten<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 横向展平</span></pre></td></tr><tr><td data-num=\"121\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组展平为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>flatten<span class=\"token punctuation\">(</span><span class=\"token string\">'F'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 纵向展平</span></pre></td></tr><tr><td data-num=\"122\"></td><td><pre></pre></td></tr><tr><td data-num=\"123\"></td><td><pre><span class=\"token comment\"># 代码 2-24</span></pre></td></tr><tr><td data-num=\"124\"></td><td><pre>arr1 <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"125\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的数组1为：'</span><span class=\"token punctuation\">,</span> arr1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"126\"></td><td><pre></pre></td></tr><tr><td data-num=\"127\"></td><td><pre>arr2 <span class=\"token operator\">=</span> arr1 <span class=\"token operator\">*</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"128\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的数组2为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"129\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'横向组合为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>hstack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># hstack 函数横向组合</span></pre></td></tr><tr><td data-num=\"130\"></td><td><pre></pre></td></tr><tr><td data-num=\"131\"></td><td><pre><span class=\"token comment\"># 代码 2-25</span></pre></td></tr><tr><td data-num=\"132\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'纵向组合为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>vstack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># vstack 函数纵向组合</span></pre></td></tr><tr><td data-num=\"133\"></td><td><pre></pre></td></tr><tr><td data-num=\"134\"></td><td><pre><span class=\"token comment\"># 代码 2-26</span></pre></td></tr><tr><td data-num=\"135\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'横向组合为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>concatenate<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> axis<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># concatenate 函数横向组合</span></pre></td></tr><tr><td data-num=\"136\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'纵向组合为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>concatenate<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> axis<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># concatenate 函数纵向组合</span></pre></td></tr><tr><td data-num=\"137\"></td><td><pre></pre></td></tr><tr><td data-num=\"138\"></td><td><pre><span class=\"token comment\"># 代码 2-27</span></pre></td></tr><tr><td data-num=\"139\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"140\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的二维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"141\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'横向分割为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>hsplit<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># hsplit 函数横向分割</span></pre></td></tr><tr><td data-num=\"142\"></td><td><pre></pre></td></tr><tr><td data-num=\"143\"></td><td><pre><span class=\"token comment\"># 代码 2-28</span></pre></td></tr><tr><td data-num=\"144\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'纵向分割为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>vsplit<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># vsplit 函数纵向分割</span></pre></td></tr><tr><td data-num=\"145\"></td><td><pre></pre></td></tr><tr><td data-num=\"146\"></td><td><pre><span class=\"token comment\"># 代码 2-29</span></pre></td></tr><tr><td data-num=\"147\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'横向分割为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> axis<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># split 函数横向分割</span></pre></td></tr><tr><td data-num=\"148\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'纵向分割为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> axis<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># split 函数纵向分割</span></pre></td></tr></table></figure>",
            "tags": [
                "python",
                "数据分析"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/09/web%E6%BC%8F%E6%B4%9E-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/",
            "url": "https://self-ferry.github.io/2021/03/09/web%E6%BC%8F%E6%B4%9E-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/",
            "title": "web漏洞-业务逻辑漏洞",
            "date_published": "2021-03-09T08:15:23.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=491097414\"]}]'></div></div>\n<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>又要鸽了 0，有事情要忙。</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzE5NTgzNy5odG1s\">逻辑漏洞挖掘初步总结篇</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vWC1jYWlqaS9wLzExMjA5OTYzLmh0bWw=\">Web 安全测试中常见逻辑漏洞解析（实战篇）</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5OTE2OTIvYXJ0aWNsZS9kZXRhaWxzLzgyOTUzMjEz\">常见逻辑漏洞</span></p>\n<p>挖掘出属于自己思维的逻辑漏洞。</p>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/03/09/Nmap%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/",
            "url": "https://self-ferry.github.io/2021/03/09/Nmap%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/",
            "title": "Nmap速查手册",
            "date_published": "2021-03-09T08:14:20.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=30621618\"]}]'></div></div>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuMmN0by5jb20vQXJ0aWNsZS8yMDE0MTIvMzYyMTg4Lmh0bWw=\">https://www.2cto.com/Article/201412/362188.html</span></p>\n<h1 id=\"nmap-简介\"><a class=\"anchor\" href=\"#nmap-简介\">#</a> Nmap 简介</h1>\n<p>Nmap 是 Network Mapper 的简称<br />\n Nmap 是一款开源免费的网络发现（Network Discovery）和安全审计（Security Auditing）工具<br />\n 1997 年由 Fyodor 创建</p>\n<p>Nmap 四项基本功能：</p>\n<p>1. 主机发现（Host Discovery）<br />\n2. 端口扫描（Port Scanning）<br />\n3. 版本侦测（Version Detection）<br />\n4. 操作系统侦测（Operating System Detection）</p>\n<p>这四项功能之间，又存在大致的依赖关系（通常情况下的顺序关系，但特殊应用另外考虑），首先需要进行主机发现，随<br />\n后确定端口状况，然后确定端口上运行具体应用程序与版本信息，然后可以进行操作系统的侦测。而在四项基本功能的基<br />\n础上，Nmap 提供防火墙与 IDS（IntrusionDetection System, 入侵检测系统）的规避技巧，可以综合应用到四个基本功<br />\n能的各个阶段；另外 Nmap 提供强大的 NSE（Nmap Scripting Language）脚本引擎功能，脚本可以对基本功能进行补充<br />\n和扩展。</p>\n<p><span class=\"label info\">大致功能为:</span></p>\n<ol>\n<li>主机存活检测</li>\n<li>端口探测</li>\n<li>服务识别</li>\n<li>操作系统识别</li>\n<li>硬件地址检测</li>\n<li>服务版本识别</li>\n<li>漏洞扫描，使用 nmap 自带脚本</li>\n</ol>\n<h1 id=\"nmap参数详解\"><a class=\"anchor\" href=\"#nmap参数详解\">#</a> Nmap 参数详解</h1>\n<h2 id=\"nmap支持主机名ip网段的表示方式\"><a class=\"anchor\" href=\"#nmap支持主机名ip网段的表示方式\">#</a> Nmap 支持主机名，ip, 网段的表示方式</h2>\n<p>例如:blah.highon.coffee, <span class=\"exturl\" data-url=\"aHR0cDovL25hbXAub3JnLzI0\">namp.org/24</span>, 192.168.0.1;10.0.0-25.1-254</p>\n<p>-iL filename                    从文件中读取待检测的目标，文件中的表示方法支持机名，ip, 网段<br />\n - iR hostnum                     随机选取，进行扫描。如果 - iR 指定为 0, 则是无休止的扫描<br />\n --exclude host1 [, host2]        从扫描任务中需要排除的主机<br />\n --exculdefile exclude_file      排除文件中的 IP, 格式和 - iL 指定扫描文件的格式相同</p>\n<h2 id=\"0x00-主机发现\"><a class=\"anchor\" href=\"#0x00-主机发现\">#</a> 0x00 主机发现</h2>\n<p>-sL                     仅仅是显示，扫描的 IP 数目，不会进行任何扫描<br />\n - sn                     ping 扫描，即主机发现<br />\n - Pn                     不检测主机存活<br />\n - PS/PA/PU/PY [portlist]  TCP SYN Ping/TCP ACK Ping/UDP Ping 发现<br />\n - PE/PP/PM               使用 ICMP echo, timestamp and netmask 请求包发现主机<br />\n - PO [prococol list]      使用 IP 协议包探测对方主机是否开启<br />\n - n/-R                   不对 IP 进行域名反向解析 / 为所有的 IP 都进行域名的反响解析</p>\n<h2 id=\"0x01-扫描技巧\"><a class=\"anchor\" href=\"#0x01-扫描技巧\">#</a> 0x01 扫描技巧</h2>\n<p>-sS/sT/sA/sW/sM                 TCP SYN/TCP connect ()/ACK/TCP 窗口扫描 / TCP Maimon 扫描<br />\n - sU                             UDP 扫描<br />\n - sN/sF/sX                       TCP Null，FIN，and Xmas 扫描<br />\n --scanflags                     自定义 TCP 包中的 flags<br />\n-sI zombie host[:probeport]     Idlescan<br />\n-sY/sZ                          SCTP INIT/COOKIE-ECHO 扫描<br />\n - sO                             使用 IP protocol 扫描确定目标机支持的协议类型<br />\n - b “FTP relay host” 使用 FTP bounce scan</p>\n<h2 id=\"0x02-指定端口和扫描顺序\"><a class=\"anchor\" href=\"#0x02-指定端口和扫描顺序\">#</a> 0x02 指定端口和扫描顺序</h2>\n<p>-p                      特定的端口 -p80,443 或者 -p1-65535<br />\n-p U:PORT               扫描 udp 的某个端口，-p U:53<br />\n-F                      快速扫描模式，比默认的扫描端口还少<br />\n - r                      不随机扫描端口，默认是随机扫描的<br />\n --top-ports &quot;number&quot;    扫描开放概率最高的 number 个端口，出现的概率需要参考 nmap-services 文件，ubuntu 中该文件位于 /usr/share/nmap.nmap 默认扫前 1000 个<br />\n --port-ratio &quot;ratio&quot;    扫描指定频率以上的端口</p>\n<h2 id=\"0x03-服务版本识别\"><a class=\"anchor\" href=\"#0x03-服务版本识别\">#</a> 0x03 服务版本识别</h2>\n<p>-sV                             开放版本探测，可以直接使用 - A 同时打开操作系统探测和版本探测<br />\n --version-intensity &quot;level&quot;     设置版本扫描强度，强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是 7<br />\n--version-light                 打开轻量级模式，为 --version-intensity 2 的别名<br />\n --version-all                   尝试所有探测，为 --version-intensity 9 的别名<br />\n --version-trace                 显示出详细的版本侦测过程信息</p>\n<h2 id=\"0x04-脚本扫描\"><a class=\"anchor\" href=\"#0x04-脚本扫描\">#</a> 0x04 脚本扫描</h2>\n<p>-sC                             根据端口识别的服务，调用默认脚本<br />\n --script=”Lua scripts”          调用的脚本名<br />\n --script-args=n1=v1,[n2=v2]     调用的脚本传递的参数<br />\n --script-args-file=filename     使用文本传递参数<br />\n --script-trace                  显示所有发送和接收到的数据<br />\n --script-updatedb               更新脚本的数据库<br />\n --script-help=”Lua script”      显示指定脚本的帮助</p>\n<h2 id=\"0x05-os识别\"><a class=\"anchor\" href=\"#0x05-os识别\">#</a> 0x05 OS 识别</h2>\n<p>-O              启用操作系统检测，-A 来同时启用操作系统检测和版本检测<br />\n --osscan-limit  针对指定的目标进行操作系统检测 (至少需确知该主机分别有一个 open 和 closed 的端口)<br />\n--osscan-guess  推测操作系统检测结果，当 Nmap 无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap 默认进行这种匹配</p>\n<h2 id=\"0x06-防火墙ids躲避和欺骗\"><a class=\"anchor\" href=\"#0x06-防火墙ids躲避和欺骗\">#</a> 0x06 防火墙 / IDS 躲避和欺骗</h2>\n<p>-f; --mtu value                 指定使用分片、指定数据包的 MTU.<br />\n-D decoy1,decoy2,ME             使用诱饵隐蔽扫描<br />\n - S IP-ADDRESS                   源地址欺骗<br />\n - e interface                    使用指定的接口<br />\n - g/--source-port PROTNUM       使用指定源端口<br />\n --proxies url1,[url2],...       使用 HTTP 或者 SOCKS4 的代理</p>\n<p>--data-length NUM               填充随机数据让数据包长度达到 NUM<br />\n--ip-options OPTIONS            使用指定的 IP 选项来发送数据包<br />\n --ttl VALUE                     设置 IP time-to-live 域<br />\n --spoof-mac ADDR/PREFIX/VEBDOR  MAC 地址伪装<br />\n --badsum                        使用错误的 checksum 来发送数据包</p>\n<h2 id=\"0x07-输出\"><a class=\"anchor\" href=\"#0x07-输出\">#</a> 0x07 输出</h2>\n<p>-oN                     将标准输出直接写入指定的文件<br />\n - oX                     输出 xml 文件<br />\n - oS                     将所有的输出都改为大写<br />\n - oG                     输出便于通过 bash 或者 perl 处理的格式，非 xml<br />\n-oA BASENAME            可将扫描结果以标准格式、XML 格式和 Grep 格式一次性输出<br />\n - v                      提高输出信息的详细度<br />\n - d level                设置 debug 级别，最高是 9<br />\n--reason                显示端口处于带确认状态的原因<br />\n --open                  只输出端口状态为 open 的端口<br />\n --packet-trace          显示所有发送或者接收到的数据包<br />\n --iflist                显示路由信息和接口，便于调试<br />\n --log-errors            把日志等级为 errors/warings 的日志输出<br />\n --append-output         追加到指定的文件<br />\n --resume FILENAME       恢复已停止的扫描<br />\n --stylesheet PATH/URL   设置 XSL 样式表，转换 XML 输出<br />\n --webxml                从 namp.org 得到 XML 的样式<br />\n --no-sytlesheet         忽略 XML 声明的 XSL 样式表</p>\n<h2 id=\"0x08-其他选项\"><a class=\"anchor\" href=\"#0x08-其他选项\">#</a> 0x08 其他选项</h2>\n<p>-6                      开启 IPv6<br />\n-A                      OS 识别，版本探测，脚本扫描和 traceroute<br />\n--datedir DIRNAME       说明用户 Nmap 数据文件位置<br />\n --send-eth /--send-ip  使用原以太网帧发送 / 在原 IP 层发送<br />\n --privileged            假定用户具有全部权限<br />\n --unprovoleged          假定用户不具有全部权限，创建原始套接字需要 root 权限<br />\n - V                      打印版本信息<br />\n - h                      输出帮助</p>\n<h1 id=\"nmap-例子\"><a class=\"anchor\" href=\"#nmap-例子\">#</a> nmap 例子</h1>\n<p>使用 ping 检测 10.0.0.0/24 这个网段</p>\n<p><code>nmap -sP 10.0.0.0/24</code></p>\n<p>使用 SYN 的方法对全端口进行扫描，在 aggressive (4) 的时间模板下，同时对开放的端口进行端口识别</p>\n<p><code>nmap -p1-65535 -sV -sS -T4 target</code></p>\n<p>PS: -T 代表的是扫描的时候，一些控制选项 (TCP 的延迟时间，探测报文之间的间隔等) 的集合，具体的 man nmap 一下就知道了</p>\n<p>使用 SYN 扫描，在 aggressive (4) 的时间模板下，探测操作系统的类型和版本，还有显示 traceroute 的结果，结果输出较为详细</p>\n<p><code>nmap -v -sS -A -T4 target</code></p>\n<p>使用 SYN 扫描，在 insane (5) 的时间模板下，探测操作系统的类型和版本，还有显示 traceroute 的结果，结果输出较为详细</p>\n<p><code>nmap -v -sS -A -T5 target</code></p>\n<p>使用 SYN 扫描，在 insane (5) 的时间模板下，探测操作系统的类型，还有显示 traceroute 的结果，操作系统的类型，结果输出较为详细</p>\n<p><code>nmap -v -sV -O -sS -T5 target</code></p>\n<p>使用 SYN 的方法对全端口进行扫描，同时对开放的端口进行端口识别，在 aggressive (4) 的时间模板下，探测操作系统的类型还有显示 traceroute 的结果，结果输出较为详细</p>\n<p><code>nmap -v -p 1-65535 -sV -O -sS -T4 target</code></p>\n<p>用 SYN 的方法对全端口进行扫描，同时对开放的端口进行端口识别，在 insane (5) 的时间模板下，探测操作系统的类型，还有显示 traceroute 的结果，结果输出较为详细</p>\n<p><code>nmap -v -p 1-65535 -sV -O -sS -T5 target</code></p>\n<p>从文件中读取需要扫描的 IP 列表</p>\n<p><code>nmap -iL ip-address.txt</code></p>\n<p>Nmap 输出格式</p>\n<ol>\n<li>扫描的结果输出到屏幕，同时会存储一份到 grep-output.txt</li>\n</ol>\n<p><code>nmap -sV -p 139,445 -oG grep-output.txt 10.0.1.0/24</code></p>\n<ol start=\"2\">\n<li>扫描结果输出为 html</li>\n</ol>\n<p><code>nmap -sS -sV -T5 10.0.1.99 --webxml -oX - | xsltproc --output file.html</code></p>\n<p>Nmap 扫描 Netbios</p>\n<ol>\n<li>在子网中发现开放 netbios 的 IP</li>\n</ol>\n<p><code>nmap -sV -v -p139,445 10.0.0.1/24</code></p>\n<ol start=\"2\">\n<li>扫描指定 netbios 的名称</li>\n</ol>\n<p><code>nmap -sU --script nbstat.nse -p 137 target</code></p>\n<p>扫描指定的目标，同时检测相关漏洞</p>\n<p><code>nmap --script-args=unsafe=1 --script smb-check-vulns.nse -p 445 target</code></p>\n<p>将 nmap 的 80 端口的扫描结果，通过管道交给 nikto 进行扫描</p>\n<p><code>Nmap Nikto Scan nmap -p80 10.0.1.0/24 -oG - | nikto.pl -h -</code></p>\n<p>将 nmap 的 80,443 端口的扫描结果，通过管道交给 nikto 进行扫描</p>\n<p><code>nmap -p80,443 10.0.1.0/24 -oG - | nikto.pl -h -</code></p>\n",
            "tags": [
                "web安全",
                "Nmap"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/02/%E5%88%9D%E5%AD%A6webshell%E6%A3%80%E6%B5%8B/",
            "url": "https://self-ferry.github.io/2021/03/02/%E5%88%9D%E5%AD%A6webshell%E6%A3%80%E6%B5%8B/",
            "title": "初学webshell检测",
            "date_published": "2021-03-02T09:51:07.000Z",
            "content_html": "<h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/02/26/%E5%9C%A8Android%E4%B8%8A%E5%AE%89%E8%A3%85kali/",
            "url": "https://self-ferry.github.io/2021/02/26/%E5%9C%A8Android%E4%B8%8A%E5%AE%89%E8%A3%85kali/",
            "title": "在Android上安装kali",
            "date_published": "2021-02-26T05:55:57.000Z",
            "content_html": "<h1 id=\"️正文\"><a class=\"anchor\" href=\"#️正文\">#</a> <span class=\"label success\">✔️正文</span></h1>\n<p>就不多此一举了，还是看国光大佬写的吧<br />\n链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3Fsc2VjLmNvbS8yMDE4LzA1L3Rlcm11eC5odG1s\">https://www.sqlsec.com/2018/05/termux.html</span></p>\n",
            "tags": [
                "Android",
                "Android"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/02/19/linux%E8%BF%9B%E9%98%B6/",
            "url": "https://self-ferry.github.io/2021/02/19/linux%E8%BF%9B%E9%98%B6/",
            "title": "linux进阶学习",
            "date_published": "2021-02-19T06:54:11.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=555964763\"]}]'></div></div>\n<h1 id=\"网络配置\"><a class=\"anchor\" href=\"#网络配置\">#</a> 网络配置</h1>\n<h2 id=\"ifconfig-详解\"><a class=\"anchor\" href=\"#ifconfig-详解\">#</a> ifconfig 详解</h2>\n<p>ifconfig 命令可以显示或配置网络设备 (网络接口卡) , 也可以修改这些配置。<br />\n用 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永久保存，那就要修改网卡的配置文件了。</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>DEVICE=“ens33” 　　# 网卡名称<br />\n // UP：表示 “接口已启用”。<br />\n// BROADCAST ：表示 “主机支持广播”。<br />\n// RUNNING：表示 “接口在工作中”。<br />\n// MULTICAST：表示 “主机支持多播”。<br />\n// MTU:1500（最大传输单元）：1500 字节<br />\n //inet ：网卡的 IP 地址。<br />\n//netmask ：网络掩码。<br />\n//broadcast ：广播地址。<br />\n// 网卡的 IPv6 地址<br />\n // 连接类型：Ethernet (以太网) HWaddr (硬件 mac 地址)<br />\n//txqueuelen (网卡设置的传送队列长度)<br />\n// RX packets 接收时，正确的数据包数。<br />\n// RX bytes 接收的数据量。<br />\n// RX errors 接收时，产生错误的数据包数。<br />\n// RX dropped 接收时，丢弃的数据包数。<br />\n// RX overruns 接收时，由于速度过快而丢失的数据包数。<br />\n// RX frame 接收时，发生 frame 错误而丢失的数据包数。<br />\n// TX packets 发送时，正确的数据包数。<br />\n// TX bytes 发送的数据量。<br />\n// TX errors 发送时，产生错误的数据包数。<br />\n// TX dropped 发送时，丢弃的数据包数。<br />\n// TX overruns 发送时，由于速度过快而丢失的数据包数。<br />\n// TX carrier 发送时，发生 carrier 错误而丢失的数据包数。<br />\n//collisions 冲突信息包的数目。</p>\n<p>lo: 表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。</p>\n<p>ifconfig 的配置针对当前起作用，, 当服务器进行重启启动，配置的 IP 和掩码等信息都会丢失因为 ifconfig 的没有把配置写入到配置文件，当系统重新启动中，会重新加载网络配置文件，因此配置会丢失</p>\n<p>ifconfig 命令 参数具体见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLWlmY29uZmlnLmh0bWw=\"> https://www.runoob.com/linux/linux-comm-ifconfig.html</span></p>\n<h2 id=\"网络配置文件\"><a class=\"anchor\" href=\"#网络配置文件\">#</a> 网络配置文件</h2>\n<p>网络接口配置文件均存放在 /etc/sysconfig/network-scripts/ 目录下</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat /etc/sysconfig/network-scripts/ifcfg-ens33 </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>none</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens33</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>3693f084-6c9a-4b4e-82ef-62377f4c3502</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens33</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.10.100</pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token assign-left variable\">PREFIX</span><span class=\"token operator\">=</span><span class=\"token number\">24</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span><span class=\"token number\">192.198</span>.10.1</pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">#################################</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>下面介绍改配置文件中的每一行的含义。</pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">#################################</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>:网卡设备名</pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token assign-left variable\">HWADDR</span><span class=\"token operator\">=</span>:网卡的物理地址</pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>:网卡的类型</pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>:网卡的UUID</pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span>:IP地址</pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span>:子网掩码</pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span>:网关</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token assign-left variable\">DNS1</span><span class=\"token operator\">=</span>:DNS</pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>:该网卡是否激活</pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token assign-left variable\">NM_CONTROLLED</span><span class=\"token operator\">=</span>:网络是否由NetworkManager进行管理</pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>：启动远程协议为静态设置</pre></td></tr></table></figure><h2 id=\"路由的查看及配置\"><a class=\"anchor\" href=\"#路由的查看及配置\">#</a> 路由的查看及配置</h2>\n<p>路由 (route) 就是分组在因特网上从一台计算机传输到另一台计算机的实际路径。<br />\n因特网上的每个路由器都存储有一张表，称为路由表 (routing table), 路由器正是依据路由表的内容将各个 IP 分组转发到正确的去处。</p>\n<p>路由，路由器，路由表的区别:</p>\n<p>路由：既可以指计算机之间的传输路径，又可以指传输这一动态过程<br />\n路由器：设备，即完成路由这一动态过程的设备<br />\n路由表：信息，是储存在路由器中的用来路由的信息</p>\n<p>查看路由命令：<br />\n <code>netstat -r</code></p>\n<p><code>route -n</code></p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<p>查看本机路由信息<br />\n <code>route -n</code></p>\n<p>添加一条默认路由，临时生效 (重启后就会失效)<br />\n <code>route add default qw 192.168.10.1</code></p>\n<p>删除一条默认路由<br />\n <code>route del default gw 192.168.10.1</code></p>\n<p>添加一条静态路由，发往 192.168.8.62 这个网段的全部要经过网关 192.168.1.1<br />\n <code>route add-net 192.168.8.0 netmask 255.255.255.0 gw 192.168.1.1</code></p>\n<p>删除一条静态路由，删除的时候可以不写网关<br />\n <code>route del -net 192.168.8.0 netmask 255.255.255.0 gw 192.168.1.1</code></p>\n<p>设置包转发功能:</p>\n<p>开启 Liunx 的路由转发功能:<br />\n 编辑 /etc/sysctl.conf 设置 net.pv4.p forward=1</p>\n<p>临时配置：<br />\n <code>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward</code></p>\n<h2 id=\"dns\"><a class=\"anchor\" href=\"#dns\">#</a> DNS</h2>\n<p>Linux 下查看本地的 DNS:<br />\n1.cat /etc/resolv.conf<br />\n2.nslookup <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20=\">www.baidu.com</span></p>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<h3 id=\"dns-查询工具\"><a class=\"anchor\" href=\"#dns-查询工具\">#</a> DNS 查询工具</h3>\n<ol>\n<li>\n<p>nslookup 是一个能够查询互联网域名服务器信息的程序。<br />\n他有两种工作模式，即 &quot;交互模式&quot; 和 &quot;非交互模式&quot;<br />\n在&quot; 交互模式 &quot; 下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。<br />\n而在 “非交互模式 &quot; 下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。</p>\n</li>\n<li>\n<p>Dig 是一个在类 Unix 命令行模式下查询 DNS 包括 NSi 录，A 记录，MX 记录等相关信息的工具。</p>\n</li>\n</ol>\n<p>dig 命令:<br />\n 查询一台主机，但是默认情况下，Dig 的输出信息很详细<br />\n最常用的查询是 A 记录，TXT (文本注释) , MXi 录，NS 记录</p>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n<h3 id=\"dns域名解析中添加的各项解析记录\"><a class=\"anchor\" href=\"#dns域名解析中添加的各项解析记录\">#</a> DNS 域名解析中添加的各项解析记录</h3>\n<p>A 记录： 将域名指向一个 IPv4 地址（例如：100.100.100.100），需要增加 A 记录</p>\n<p>CNAME 记录： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加 CNAME 记录。这个域名一般是主机服务商提供的一个域名</p>\n<p>MX 记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置 MX 记录。建立邮箱时，一般会根据邮箱服务商提供的 MX 记录填写此记录</p>\n<p>NS 记录： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置 NS 记录</p>\n<p>TXT 记录： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做 SPF（反垃圾邮件）记录</p>\n<p>AAAA 记录： 将主机名（或域名）指向一个 IPv6 地址（例如：ff03:0:0:0:0:0:0:c1），需要添加 AAAA 记录</p>\n<p>SRV 记录： 添加服务记录服务器服务记录时会添加此项，SRV 记录了哪台计算机提供了哪个服务。格式为：服务的名字。协议的类型（例如：_example-server._tcp）。</p>\n<p>SOA 记录： SOA 叫做起始授权机构记录，NS 用于标识多台域名解析服务器，SOA 记录用于在众多 NS 记录中那一台是主服务器</p>\n<p>PTR 记录： PTR 记录是 A 记录的逆向记录，又称做 IP 反查记录或指针记录，负责将 IP 反向解析为域名</p>\n<p>显性 URL 转发记录： 将域名指向一个 http (s) 协议地址，访问域名时，自动跳转至目标地址。例如：将 www.liuht.cn 显性转发到 www.itbilu.com 后，访问 www.liuht.cn 时，地址栏显示的地址为：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5pdGJpbHUuY29t\">www.itbilu.com</span>。</p>\n<p>隐性 UR 转发记录 L： 将域名指向一个 http (s) 协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将 www.liuht.cn 显性转发到 www.itbilu.com 后，访问 www.liuht.cn 时，地址栏显示的地址仍然是：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5saXVodC5jbg==\">www.liuht.cn</span>。</p>\n<p><em><strong>Reference:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmx1ZXN0b3JtL3AvMTAzNDUzMzQuaHRtbA==\">https://www.cnblogs.com/bluestorm/p/10345334.html</span></strong></em></p>\n<h1 id=\"iptables详解\"><a class=\"anchor\" href=\"#iptables详解\">#</a> iptables 详解</h1>\n<h2 id=\"防火墙类型\"><a class=\"anchor\" href=\"#防火墙类型\">#</a> 防火墙类型</h2>\n<h3 id=\"包过滤防火墙\"><a class=\"anchor\" href=\"#包过滤防火墙\">#</a> 包过滤防火墙</h3>\n<p>在 Linux 系统下，包过滤功能是内建于核心的 (作为一个核心模块，或者直接内建) , 同时还有一些可以运用于数据包之上的技巧，不过最常用的依然是查看包头以决定包的命运。包过滤防火墙将对每一个接收到的包做出允许或拒绝的决定。具体地讲，它针对每一个数据包的包头，按照包过滤规则进行判定，与规则相匹配的包依据路由信息继续转发，否则就丢弃。包过滤是在 IP 层实现的，包过滤根据数据包的源 P 地址、目的 IP 地址、协议类型 (TCP 包 UDP 包、ICMP 包)、源端口、目的端口等包头信息及数据包传输方向等信息来判断是否允许数据包通过。 包过滤也包括与服务相关的过滤，这是指基于特定的服务进行包过滤，由于绝大多数服务的监听都驻留在特定 TCP/UDP 端口，因此，为阻断所有进入特定服务的链接，防火墙只需将所有包含特定 TCP/UDP 目的端口的包丢弃即可</p>\n<h3 id=\"状态检测防火墙\"><a class=\"anchor\" href=\"#状态检测防火墙\">#</a> 状态检测防火墙</h3>\n<p>状态检测防火墙在网络层有一个检查引擎截获数据包并抽取出与应用层状态有关的信息，并以此为依据决定对该连接是接受还是拒绝。这种技术提供了高度安全的解决方案，同时具有较好的适应性和扩展性。状态检测防火墙基本保持了简单包过滤防火墙的优点，性能比较好，同时对应用是透明的，在此基础上，对于安全性有了大幅提升。这种防火墙摒弃了简单包过滤防火墙仅仅考察进出网络的数据包，不关心数据包状态的缺点，在防火墙的核心部分建立状态连接表，维护了连接，将进出网络的数据当成一个个的事件来处理。可以这样说，状态检测包过滤防火墙规范了网络层和传输层行为，而应用代理型防火墙则是规范了特定的应用协议上的行为。</p>\n<h2 id=\"iptables介绍\"><a class=\"anchor\" href=\"#iptables介绍\">#</a> iptables 介绍</h2>\n<p>netfilter/iptables (简称为 iptables) 组成 Linux 平台下的包过滤防火墙，与大多数的 Linux 软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换 (NAT) 等功能。</p>\n<p>其实 iptables 服务不是真正的防火墙，只是用来定义防火墙规则功能的 &quot;防火墙管理工具&quot;, 将定义好的规则交由内核中的 netfilter 即网络过滤器来读取，从而真正实现防火墙功能。</p>\n<h2 id=\"iptables基本信息\"><a class=\"anchor\" href=\"#iptables基本信息\">#</a> iptables 基本信息</h2>\n<p>规则 (rules) 其实就是网络管理员预定义的条件，规则一般的定义为 &quot;如果数据包头符合这样的条件，就这样处理这个数据包&quot;</p>\n<p>规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议 (如 TCP, UDP,ICMP) 和服务类型 (如 HTTP, FTP 和 SMTP) 等。</p>\n<p>当数据包与规则匹配时，iptables 就根据规则所定义的方法来处理这些数据包，如放行 (accept) 、拒绝 (reject) 和丢弃 (drop) 等。</p>\n<p>配置防火墙的主要工作就是添加、修改和删除这些规则。</p>\n<h2 id=\"表与链介绍\"><a class=\"anchor\" href=\"#表与链介绍\">#</a> 表与链介绍</h2>\n<ul>\n<li>\n<p>表 (tables) 提供特定的功能，iptables 内置了 4 个表，即 filter 表、nat 表、mangle 表和 raw 表，分别用于实现包过滤，网络地址转换、包重构 (修改) 和数据跟踪处理，这些表具有一定的优先级: raw--&gt;mangle--&gt;nat--&gt;filter</p>\n</li>\n<li>\n<p>链 (chains) 是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。</p>\n</li>\n</ul>\n<h2 id=\"规则链\"><a class=\"anchor\" href=\"#规则链\">#</a> 规则链</h2>\n<h3 id=\"一些需要知道的规则链\"><a class=\"anchor\" href=\"#一些需要知道的规则链\">#</a> 一些需要知道的规则链</h3>\n<ol>\n<li>INPUT - 进来的数据包应用此规则链中的策略</li>\n<li>OUTPUT - 外出的数据包应用此规则链中的策略</li>\n<li>FORWARD - 转发数据包时应用此规则链中的策略</li>\n<li>PREROUTING - 对数据包作路由选择前应用此链中的规则 (记住！所有的数据包进来的时候都先由这个链处理)</li>\n<li>POSTROUTING - 对数据包作路由选择后应用此链中的规则 (所有的数据包出来的时候都先由这个链处理)</li>\n</ol>\n<p><span class=\"label\">完整的规则链</span></p>\n<p><img data-src=\"image005.png\" alt=\"\" /></p>\n<p>规则表的先后顺序:<br />\nraw-&gt;mangle-&gt;nat-&gt;filter</p>\n<p>规则链的先后顺序:<br />\n 入站顺序 PREROUTING-&gt;INPUT<br />\n 出站顺序：OUTPUT-&gt;POSTROUTING<br />\n 转发顺序：PREROUTING-&gt;FORWARD-&gt;POSTROUTING</p>\n<h2 id=\"iptables传输数据包的过程\"><a class=\"anchor\" href=\"#iptables传输数据包的过程\">#</a> iptables 传输数据包的过程</h2>\n<p>当一个数据包进入网卡时，它首先进入 PREROUTING 链，内核根据数据包目的 IP 判断是否需要转送出去。</p>\n<p>如果数据包就是进入本机的，它就会向下移动，到达 INPUT 链。数据包到了 INPUT 链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过 OUTPUT 链，然后到达 POSTROUTING 链输出。</p>\n<p>如果数据包是要转发出去的，且内核允许转发，数据包就会经过 FORWARD 链，然后到达 POSTROUTING 链输出。</p>\n<p><img data-src=\"image006.png\" alt=\"\" /></p>\n<h2 id=\"iptables命令\"><a class=\"anchor\" href=\"#iptables命令\">#</a> iptables 命令</h2>\n<p>iptables 格式:<br />\niptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]</p>\n<p><img data-src=\"image007.png\" alt=\"\" /></p>\n<p>详细解释见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdmF0aGUvcC82OTczNjU2Lmh0bWw=\"> https://www.cnblogs.com/vathe/p/6973656.html</span><br />\n 有人总结的挺全的就不造轮子了（懒）。</p>\n<h2 id=\"iptables常识与常用命令\"><a class=\"anchor\" href=\"#iptables常识与常用命令\">#</a> iptables 常识与常用命令</h2>\n<p>CentOS7 默认的防火墙不是 iptables, 而是 firewalle.<br />\n 如果你没有安装 iptables 的话，你可以使用以下命令进行安装<br />\n systemctl stop firewalld<br />\nsystemctl disable firewalld<br />\nsystemctl mask firewalld<br />\n 上面的意思是先屏蔽掉原有的 firewall 防火墙，下面我们就开始安装 iptables，至于为什么要安装 IPtables 我就不讲了<br />\n yum install iptables iptables-services -y</p>\n<p>设置规则<br />\n #查看 iptables 现有规则<br />\n iptables -L -n<br />\n# 先允许所有，不然有可能会杯具<br />\n iptables -P INPUT ACCEPT<br />\n# 清空所有默认规则<br />\n iptables -F<br />\n# 清空所有自定义规则<br />\n iptables -X<br />\n# 所有计数器归 0<br />\niptables -Z<br />\n# 允许来自于 lo 接口的数据包 (本地访问)<br />\niptables -A INPUT -i lo -j ACCEPT<br />\n# 开放 22 端口<br />\n iptables -A INPUT -p tcp --dport 22 -j ACCEPT<br />\n# 开放 21 端口 (FTP)<br />\niptables -A INPUT -p tcp --dport 21 -j ACCEPT<br />\n# 开放 80 端口 (HTTP)<br />\niptables -A INPUT -p tcp --dport 80 -j ACCEPT<br />\n# 开放 443 端口 (HTTPS)<br />\niptables -A INPUT -p tcp --dport 443 -j ACCEPT<br />\n# 允许 ping<br />\niptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT<br />\n# 允许接受本机请求之后的返回数据 RELATED, 是为 FTP 设置的<br />\n iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT<br />\n# 其他入站一律丢弃<br />\n iptables -P INPUT DROP<br />\n# 所有出站一律绿灯<br />\n iptables -P OUTPUT ACCEPT<br />\n# 所有转发一律丢弃<br />\n iptables -P FORWARD DROP</p>\n<p>其他规则设定<br />\n #如果要添加内网 ip 信任（接受其所有 TCP 请求）<br />\niptables -A INPUT -p tcp -s 45.96.174.68 -j ACCEPT<br />\n# 过滤所有非以上规则的请求<br />\n iptables -P INPUT DROP<br />\n# 要封停一个 IP，使用下面这条命令：<br />\niptables -I INPUT -s ... -j DROP<br />\n# 要解封一个 IP，使用下面这条命令:<br />\niptables -D INPUT -s ... -j DROP</p>\n<p>#保存上述规则<br />\n service iptables save<br />\n 开启 iptables 服务<br />\n #注册 iptables 服务<br />\n #相当于以前的 chkconfig iptables on<br />\nsystemctl enable iptables.service<br />\n# 开启服务<br />\n systemctl start iptables.service<br />\n# 查看状态<br />\n systemctl status iptables.service</p>\n<h1 id=\"linux进程\"><a class=\"anchor\" href=\"#linux进程\">#</a> Linux 进程</h1>\n<p>推荐一篇博客，《<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTg0NTEtMS5odG1s\">关于 Linux 进程你所需要知道的一起</span>》</p>\n<h2 id=\"top命令实时的查看进程的状态\"><a class=\"anchor\" href=\"#top命令实时的查看进程的状态\">#</a> top 命令：实时的查看进程的状态</h2>\n<p>top 是一个前台程序，所以是可以交互的</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">常用交互命令</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">q</td>\n<td style=\"text-align:left\">退出程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">l</td>\n<td style=\"text-align:left\">切换显示平均负载和启动时间的信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">P</td>\n<td style=\"text-align:left\">根据 CPU 使用百分比大小进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">M</td>\n<td style=\"text-align:left\">根据驻留内存大小进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i</td>\n<td style=\"text-align:left\">忽略闲置和僵死的进程，这是一个开关式命令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">k</td>\n<td style=\"text-align:left\">终止一个进程，系统提示输入 PID 及发送的信号值。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ps命令\"><a class=\"anchor\" href=\"#ps命令\">#</a> ps 命令</h2>\n<p>ps -ef 显示所有进程的详细信息</p>\n<p><img data-src=\"image008.png\" alt=\"\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">UID</th>\n<th style=\"text-align:left\">PID</th>\n<th style=\"text-align:left\">PPID</th>\n<th style=\"text-align:left\">C</th>\n<th style=\"text-align:left\">STIME</th>\n<th style=\"text-align:left\">TTY</th>\n<th style=\"text-align:left\">CMD</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">用户 ID</td>\n<td style=\"text-align:left\">进程的 ID</td>\n<td style=\"text-align:left\">父进程 ID</td>\n<td style=\"text-align:left\">进程占用 CPU 的百分比</td>\n<td style=\"text-align:left\">进程启动的时间</td>\n<td style=\"text-align:left\">该进程在那个终端上运行。若与终端无关，则显示？若为 pts/0 等，则表示由网络连和参数接主机进程。</td>\n<td style=\"text-align:left\">命令的名称和参数</td>\n</tr>\n</tbody>\n</table>\n<p>ps -aux 显示所有进程信息</p>\n<p><img data-src=\"image009.png\" alt=\"\" /><br />\n<img data-src=\"image010.png\" alt=\"\" /></p>\n<p>ps -A 显示所有的进程信息<br />\n ps -u root 显示指定用户的进程信息<br />\n ps -l 显示目前属于本次登陆得 PID 相关信息</p>\n<p><code>ps -ef|grep sshd|grep -v &quot;grep&quot;</code>  配合管道符与 grep，显示 sshd 的进程信息。</p>\n<h2 id=\"kill-命令\"><a class=\"anchor\" href=\"#kill-命令\">#</a> kill 命令</h2>\n<p>kill 命令：用于删除执行的程序或工作，通过向进程发送指定的信号来结束进程。</p>\n<p>用法：kill  [信号] PID</p>\n<p>常用信号：<br />\n2  结束进程，不是强制性的，&quot;Ctrl + C&quot; 发出的就是 kill -2 信号<br />\n 3  退出<br />\n 9  杀死进程，强制结束进程。</p>\n<h1 id=\"端口\"><a class=\"anchor\" href=\"#端口\">#</a> 端口</h1>\n<p>在 Linux 操作系统下，系统共定义了 65536 个可用的端口。<br />\n对于 0-1023 端口，都需要 root 身份才能启用，这些端口主要用于系统一些常见的通信服务中。比如: 21 ftp 服务、22 ssh 服务、80 http 服务等...<br />\n 端口的开启和关闭也就是软件服务的启动和关闭</p>\n<h2 id=\"chkconfig命令\"><a class=\"anchor\" href=\"#chkconfig命令\">#</a> chkconfig 命令</h2>\n<p>chkconfig 来判断服务是开启还是关闭状态<br />\n例如 chkconfig --list sshd</p>\n<h2 id=\"netstat命令\"><a class=\"anchor\" href=\"#netstat命令\">#</a> netstat 命令</h2>\n<p>netstat 命令：用于显示 tcp, udp 的端口和进程情况<br />\n用法:<br />\nnetstat [选项]<br />\n-a 显示所有<br />\n - t 仅显示 tcp 相关选项<br />\n - u 仅显示 udp 相关选项<br />\n - n 拒绝显示别名，能显示数字的全部转化为数字<br />\n - l 仅列出在 Listen (监听) 的服务状态<br />\n - p 显示建立相关链接的程序名</p>\n<p>常用命令:<br />\nnetstat-antlp // 查看当前所有 tcp 端口<br />\n netstat-antulp|grep 80 // 查看所有 80 端口使用情况</p>\n<h1 id=\"linux计划任务\"><a class=\"anchor\" href=\"#linux计划任务\">#</a> linux 计划任务</h1>\n<p>计划任务，就是在约定好的时间执行已经计划好的工作。<br />\n未来的某时间点执行一次某任务或者周期性的运行某个任务，执行结果会通过邮形式发送给用户。</p>\n<h2 id=\"安全与计划任务\"><a class=\"anchor\" href=\"#安全与计划任务\">#</a> 安全与计划任务</h2>\n<p>挖矿病毒：<br />\n使用 top 查看 CPU，显示进程占 cpu99% 以上。杀掉进程后，到了晚上还是会自动运行进程。<br />\n检测定时任务，发现有一个异常的定时任务</p>\n<h2 id=\"at命令\"><a class=\"anchor\" href=\"#at命令\">#</a> at 命令</h2>\n<p>at 命令 一次性计划任务<br />\n默认自带 at<br />\n <code>yum install at -y</code>     下载 at</p>\n<p>开启服务:<br />\nservice atd start</p>\n<p>用法:<br />\nat (选项)<br />\n 选项<br />\n - f: 指定包含具体指令的任务文件；<br />\n-q: 指定新任务的队列名称；<br />\n-l: 显示待执行任务的列表；<br />\n-d: 删除指定的待执行任务；<br />\n-m: 任务执行完成后向用户发送 E-mail;</p>\n<p><span class=\"label\">实例</span></p>\n<p>at 10:00    确切时间<br />\n at now +10 minutes  十分钟后执行<br />\n at 17:04 04/04/2018  2018483817:04 执行<br />\n at 17:04 04/04/2018  2018483817:04 执行</p>\n<p>at 1am tomorrow 明天上午一点运行作业<br />\n at-c id    根据作业 ID 查看执行细节<br />\n atq        查看待处理的任务<br />\n atrm id    删除 id 的任务</p>\n<h2 id=\"crondtab命令\"><a class=\"anchor\" href=\"#crondtab命令\">#</a> crondtab 命令</h2>\n<p>crondtab 命令 周期性计划任务</p>\n<p>crond 是 linux 下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。</p>\n<p>Linux 系统上系统服务是默认启动的，使用者控制计划任务命令:crontab 命令。</p>\n<p>crontab 其实是一个命令，用来读取和修改名为 crontab 的文件。/etc/crontab 文件包含了要定时执行的程序列表。</p>\n<p>安装 crontab: 默认自带<br />\n <code>yum install crontabs</code></p>\n<p>服务命令:</p>\n<p>service crond start // 启动服务 service crond stop // 关闭服务 service crond restart// 重启服务 service crond reload // 重新载入配置</p>\n<p>crontab 命令 周期性计划任务</p>\n<p>1、命令格式:</p>\n<p>crontab [-u user] file<br />\ncrontab [-u user] 【选项】</p>\n<p>常用选项:</p>\n<p>-e: 编辑计划任务 edit<br />\n-l: 查看计划任务 display<br />\n-u: 指定用户</p>\n<p>常用命令:</p>\n<p>crontab -l 列出当前用户的计划任务<br />\n crontab -r 删除当前用户所有的计划任务<br />\n crontab -e 编辑当前用户的计划任务<br />\n crontab-e -u root 编辑 root 用户的计划任务</p>\n<p>第一列：分钟 (0-59)<br />\n 第二列：小时 (0-23)<br />\n 第三列：天 (1-31)<br />\n 第四列：月 (1-12)<br />\n 第五列：周 (0-6) 0 表示周日</p>\n<p>&quot;<em>&quot; 表示所有的取值，就是</em> / 1&quot;<br />\n&quot;/&quot; 表示每的意思<br />\n */5&quot; 表示每 5 个单位<br />\n &quot;-&quot; 表示从某个数字到某个数字<br />\n &quot;,&quot; 表示分散的数字</p>\n<p><img data-src=\"crontab.png\" alt=\"\" /></p>\n<p><span class=\"label\">实例</span><br />\n<img data-src=\"image011.png\" alt=\"\" /></p>\n<h1 id=\"日志服务\"><a class=\"anchor\" href=\"#日志服务\">#</a> 日志服务</h1>\n<h2 id=\"基础信息\"><a class=\"anchor\" href=\"#基础信息\">#</a> 基础信息</h2>\n<p>在 CentOS 6.x 中，日志服务已经由 rsyslogd 取代了原先的 syslogd.<br />\nrsyslogd 相比 syslogd 具有一些新的特点:<br />\n 基于 TCP 网络协议传输日志信息。<br />\n更安全的网络传输方式。<br />\n有日志信息的即时分析框架。<br />\n后台数据库。<br />\n在配置文件中可以写简单的逻辑判断。<br />\n与 syslog 配置文件相兼容。</p>\n<p>查看 rsyslogd 服务是否启动<br />\n <code>ps aux|grep &quot;rsyslogd&quot;|grep -v &quot;grep&quot;</code> <br />\n 查询 rsyslogd 服务的自启动状态<br />\n <code>chkconfig --list|grep &quot;rsyslog&quot;</code> <br />\n <code>systemctl list-unit-files|grep &quot;rsyslog&quot;</code></p>\n<p>在 Linux 系统中有一部分日志不是由 rsyslogd 服务来管理的，比如 apache 服务，它的日志是由 Apache 软件自己产生并记录的，并没有调用 rsyslogd 服务，但是 apache 日志文件的格式和系统默认日志的格式是一致的。</p>\n<p>在 Linux 系统中有一部分日志不是由 rsyslogd 服务来管理的，比如 apache 服务，它的日志是由 Apache 软件自己产生并记录的，并没有调用 rsyslogd 服务，但是 apache 日志文件的格式和系统默认日志的格式是一致的。</p>\n<p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。这些信息有些非常敏感，所以在 Linux 中这些日志文件只有 root 用户可以读取。<br />\n系统日志文件的保存位置是 /var/log/ 目录</p>\n<p><img data-src=\"image012.png\" alt=\"\" /><br />\n<img data-src=\"image013.png\" alt=\"\" /><br />\n<img data-src=\"image014.png\" alt=\"\" /></p>\n<p>日志服务 rsyslogd 记录的日志文件格式包含以下 4 列:</p>\n<p>1. 事件产生的时间。<br />\n2. 产生事件的服务器的主机名。<br />\n3. 产生事件的服务名或程序名。<br />\n4. 事件的具体信息。</p>\n<p>/var/log/secure 日志文件内容:</p>\n<p><img data-src=\"image015.png\" alt=\"\" /></p>\n<p>/var/log/secure 记录验证和授权方面的倍息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh 的登录、su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</p>\n<p>/var/log/wtmp 永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件</p>\n<p>/var/tun/ulmp 记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。</p>\n<h2 id=\"rsyslogd配置文件\"><a class=\"anchor\" href=\"#rsyslogd配置文件\">#</a> rsyslogd 配置文件</h2>\n<p>rsyslogd 服务的配置文件是 /etc/rsyslog.conf , 其中主要定义了服务的名称、日志等级和日志记录位置。</p>\n<p>该配置文件的基本格式如下所示:</p>\n<p>authpriv.*                  /var/log/secure<br />\n# 服务名称 [连接符号] 日志等级   日志记录位置</p>\n<h2 id=\"日志等级\"><a class=\"anchor\" href=\"#日志等级\">#</a> 日志等级</h2>\n<p><img data-src=\"image016.png\" alt=\"\" /></p>\n<p>详细见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbmJsb2dzLmNvbS9rbGI1NjEvcC8xMjAxNDI2OC5odG1s\"> https://cnblogs.com/klb561/p/12014268.html</span></p>\n<h2 id=\"连接符\"><a class=\"anchor\" href=\"#连接符\">#</a> 连接符</h2>\n<p>连接符号:</p>\n<ol>\n<li>&quot;.&quot; 代表只要比后面的等级高的 (包含该等级) 日志都记录。比如，&quot;<span class=\"exturl\" data-url=\"aHR0cDovL2Nyb24uaW5mbw==\">cron.info</span>&quot; 代表 cron 服务产生的日志，只要日志等级大于等于 info 级别，就记录。</li>\n<li>&quot;.=&quot; 代表只记录所需等级的日志，其他等级的日志都不记录。比如，&quot;*.=emerg&quot; 代表人和日志服务产生的日志，只要等级是 emerg 等级，就记录。这种用法极少见，了解就好。</li>\n<li>&quot;.!&quot; 代表不等于，也就是除该等级的日志外，其他等级的日志都记录。</li>\n</ol>\n<h2 id=\"日志记录位置\"><a class=\"anchor\" href=\"#日志记录位置\">#</a> 日志记录位置</h2>\n<p>日志记录位置：当前日志输出到哪个日志文件中保存</p>\n<p>日志文件的绝对路径。例如: &quot;/ar/log/secure&quot;</p>\n<p>系统设备文件。如 &quot;/dev/lpo&quot; 代表第一台打印机，如果日志保存位置是打印机设备，当有日志时就会在打印机上打印。</p>\n<p>用户名。如果是 &quot;root&quot; , 把日志发送给 root 用户 (用户要在线) &quot;*&quot; 代表发送给所有在线用户，如 &quot;mail**&quot; 就会把 mail 服务产生的所有级别的日志发送给所有在线用户。发给多个在线用户，则用户名之间用 &quot;,&quot; 分隔。</p>\n<p>忽略或丢弃日志。如果接收日志的对象是 &quot;~&quot; , 则代表这个日志不会被记录，而被直接丢弃。如 &quot;local3.*~&quot; 代表忽略 local3 服务类型所有的日志都不记录。</p>\n<h2 id=\"日志管理\"><a class=\"anchor\" href=\"#日志管理\">#</a> 日志管理</h2>\n<p>日志管理:</p>\n<p>日志维护的最主要的工作就是把旧的日志文件删除，从而腾出空间保存新的日志文件。</p>\n<p>logrotate 就是用来进行日志轮替的，就是把旧的日志文件移动并改名，同时创建一个新的空日志文件用来记录新日志，当旧日志文件超出保存的范围时就删除。</p>\n<p>日志文件的命名规则:</p>\n<ol>\n<li>服务加日期</li>\n<li>服务加数字</li>\n</ol>\n<p>查看日志备份文件<br />\n ls /var/log</p>\n<p>logrotate 令可以进行日志转储 (轮替)</p>\n<p>logrotate 命令会依据 /etc/logrotate.conf 配置文件的配置，来判断配置文件中的日志是否符合日志轮替的条件 (比如，日志备份时间已经满一周) , 如果符合，日志就会进行轮替。</p>\n<p>/etc/logrotate.conf 配置文件的<br />\n cat /etc/logrotate.conf<br />\n 详细讲解</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzExMDYuaHRtbA==\">http://c.biancheng.net/view/1106.html</span></p>\n<h1 id=\"系统服务\"><a class=\"anchor\" href=\"#系统服务\">#</a> 系统服务</h1>\n<p>什么是系统服务？<br />\n 服务是在后台运行的应用程序，并且可以提供一些本地系统或网络的功能。<br />\n我们把这些应用程序称作服务，也就是 Service.<br />\nLinux 中常见的服务有那些，这些服务怎么分类，服务如何启动，服务如何自启动，服务如何查看？</p>\n<p>服务 Service, Daemon 这个词也经常伴随着出现。<br />\nDaemon 翻 i 成 &quot;守护进程&quot;<br />\n 守护进程：就是为了实现服务、功能的进程。<br />\n比如，apache 服务就是服务 (Service) , 它是用来实现 Web 服务的。<br />\n那么，启动 apache 服务的进程是哪个进程呢？<br />\nhttpd 这个守护进程 (Daemon) 。<br />\n在 Linux 中就是通过启动 httpd 进程来启动 apache 服务的。<br />\n也就是说，守护进程就是服务在后台运行的真实进程。</p>\n<p><img data-src=\"image017.png\" alt=\"\" /></p>\n<p>Linux 中的服务按照安装方法不同可以分为 RPM 包默认安装的服务和源码包安装的服务两大类。</p>\n<p>区别:</p>\n<p>RPM 包安装到系统默认位置，可以被服务管理命令识别；但是源码包安装到手工指定位置，当然就不能被服务管理命令识别了 (可以手工修改为被服务管理命令识别)。</p>\n<h2 id=\"启动服务\"><a class=\"anchor\" href=\"#启动服务\">#</a> 启动服务</h2>\n<p>启动服务方式:</p>\n<p>1) 使用 /etc/init.d/ 目录中的启动脚本来启动独立的服务</p>\n<p>2) 使用 service 命令来启动独立的服务</p>\n<p>1) 使用 /etc/init.d/ 目录中的启动脚本来启动独立的服务</p>\n<p>所有独立服务的启动脚本都存放在 /etc/init.d/ 目录中，调用脚本就可以启动独立的服务了。</p>\n<p>命令格式如下:</p>\n<p>/etc/init.d/ 独立服务名参数参数:</p>\n<p>start: 启动服务；<br />\nstop: 停止服务；<br />\nstatus: 查看服务状态；<br />\nrestart: 重启动服务；</p>\n<p>2) 使用 service 命令来启动独立的服务</p>\n<p>在 CentOS 系统中，我们还可以依赖 service 命令来启动独立的服务。service 命令实际上只是一个脚本，这个脚本仍然需要调用 /etc/init.d/ 中的启动脚本来启动独立的服务。</p>\n<p>service 命令格式如下:</p>\n<p>service 独立服务名 start|stop|restart|..</p>\n<p><code>service --status-all 查看所有服务</code></p>\n<h2 id=\"服务的自启动\"><a class=\"anchor\" href=\"#服务的自启动\">#</a> 服务的自启动</h2>\n<p>使用 chkconfig 服务自启动管理命令</p>\n<p>格式:</p>\n<p>查看所有服务的自启动状态<br />\n chkconfig -list</p>\n<p>设置某服务的自启动状态</p>\n<p>chkconfig [--level 运行级别][独立服务名][on|off]</p>\n<p><img data-src=\"image018.png\" alt=\"\" /></p>\n<p>想把某个已经安装了的服务添加为系统服务，可以执行以下命令：</p>\n<p><code>chkconfig --add 服务名称</code>           (首先，添加为系统服务，注意 add 前面有两个横杠)</p>\n<p><code>chkconfig -leve 启动级别 服务名 on</code></p>\n<h1 id=\"下载与安装\"><a class=\"anchor\" href=\"#下载与安装\">#</a> 下载与安装</h1>\n<h2 id=\"wget\"><a class=\"anchor\" href=\"#wget\">#</a> wget</h2>\n<p>wget 是一个下载文件的工具，它用在命令行下</p>\n<p>语法：wget [选项] url</p>\n<p>选项：</p>\n<p>-V 显示 wget 版本信息并退出。<br />\n-h 打印此帮助<br />\n - O 指定下载文件的别名。</p>\n<p><img data-src=\"image019.png\" alt=\"\" /></p>\n<h2 id=\"rpm\"><a class=\"anchor\" href=\"#rpm\">#</a> rpm</h2>\n<p>Linux rpm 命令用于管理套件，增强了程序安装卸载的管理。</p>\n<p>RPM 的功能：打包、安装、查询、升级、卸载...</p>\n<p>缺点: RPM 无法解决软件包的依赖关系</p>\n<p>RPM 包的命名规范: name-version-release.os.arch.rpm</p>\n<p><img data-src=\"image020.png\" alt=\"\" /></p>\n<p>!{}(image021.png)</p>\n<h2 id=\"yum\"><a class=\"anchor\" href=\"#yum\">#</a> yum</h2>\n<p>yum 基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包和安装</p>\n<p>优点：可以自动处理关联关系，并且一次安装所有依赖的软件包，无须繁琐地一次下载，安装。</p>\n<p>语法 ：<br />\nyum [选项] [包……]</p>\n<p>选项：<br />\n-h 帮助<br />\n - y 当安装过程中提示选择全部为 “yes”<br />\n-q 不显示安装过程</p>\n<p>检测有没有安装 yum<br />\nyum -h<br />\nrpm -qa | grep yum</p>\n<ol>\n<li><span class=\"label info\">相关命令</span></li>\n</ol>\n<p>1・列出所有可更新的软件清单命令: yum check-update<br />\n2 更新所有软件命令: yum update<br />\n3 仅安装指定的软件命令: yum install 包名称<br />\n 4 仅更新指定的软件命令: yum update 包名称<br />\n 5 列出所有可安装的软件清单命令: yum list<br />\n6 删除删除命令: yum remove 包名称<br />\n 7 清除缓存命令:<br />\n 清除缓存目录 (/var/cache/yum) 下的软件包<br />\n命令：yum clean packages</p>\n<p>清除缓存目录 (/var/cache/yum) 下的 headers<br />\n 命令：yum clean headers</p>\n<p>清除缓存目录 (/var/cache/yum) 下旧的 headers<br />\n 命令：yum clean oldheaders</p>\n<p>清除缓存目录 (/var/cache/yum) 下的软件包及旧的 headers<br />\n 命令：yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</p>\n<ol start=\"2\">\n<li><span class=\"label info\">yum list 相关命令</span></li>\n</ol>\n<p><img data-src=\"iamge022.png\" alt=\"\" /></p>\n<ol start=\"3\">\n<li>安装应用程序</li>\n</ol>\n<p>语法: yum [-y] install 包 1 包 2…… 包 n<br />\nyum install wget    使用安装 wget</p>\n<p>升级软件包</p>\n<p>命令格式: yum update 包 1 包 2…… 包 n<br />\nyum check-update 检测可升级的包</p>\n<p>卸载软件包</p>\n<p>命令格式: yum remove 包 1 包 2…… 包 n<br />\n 注意：卸载时注意依赖关系</p>\n<h1 id=\"文件打包和解压缩\"><a class=\"anchor\" href=\"#文件打包和解压缩\">#</a> 文件打包和解压缩</h1>\n<p>linux 中常用的五种压缩格式: .zip .gz .tar.gz .bz2 .tar.bz2</p>\n<p>打包和压缩:</p>\n<p>打包是指将一大堆文件或目录什么的变成一个总的文件<br />\n压缩则是将一个大的文件通过一些压缩算法变成一个小文件</p>\n<h2 id=\"tar命令\"><a class=\"anchor\" href=\"#tar命令\">#</a> tar 命令</h2>\n<p>Linux 中的很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你就得先借助另它的工具将这一大堆文件先打成一个包，然后再就原来的压缩程序进行压缩。</p>\n<p>Liunx 下最常用的打包命令是 tar, 使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命通常都是以.tar 结尾的。<br />\n生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法</p>\n<p>语法:<br />\ntar 【选项】 打包文件包 源文件<br />\n选项:<br />\n-c: 打包<br />\n - v: 显示详细过程<br />\n - x: 解打包 / 压缩<br />\n - z: 通过 gzip 压缩 / 解压文件<br />\n - j: 通过 bz2 压缩 / 解压文件<br />\n - C: 解压到指定目录<br />\n - f filename: 指定打包后的文件名 (必选，这个参数是最后一个参数，后面只能接文件名)</p>\n<p>常用命令:<br />\ntar -cf all.tar *.jpg  #将所有.jpg 的文件打成一个名为 all.tar 的包<br />\n tar -xvf all.tar  #解出 all.tar 包中所有文件，-x 是解开的意思</p>\n<p>为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能 -- 就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip.bzip2 等。</p>\n<h2 id=\"解压缩与压缩\"><a class=\"anchor\" href=\"#解压缩与压缩\">#</a> <span class=\"label info\">解压缩与压缩</span></h2>\n<p><img data-src=\"image022.png\" alt=\"\" /></p>\n<h2 id=\"zip\"><a class=\"anchor\" href=\"#zip\">#</a> zip</h2>\n<p>zip 【选项】 【压缩文件】</p>\n<p>选项:<br />\n-m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。<br />\n-q 不显示指令执行过程。<br />\n-r 递归处理，将指定目录下的所有文件和子目录一并处理。<br />\n-v 显示指令执行过程或显示版本信息。</p>\n<p>实例</p>\n<p>将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip:</p>\n<p>zip-qr html.zip /home/html</p>\n<h2 id=\"unzip\"><a class=\"anchor\" href=\"#unzip\">#</a> unzip</h2>\n<p>unzip 【选项】 【压缩文件】</p>\n<p>选项:</p>\n<p>-l 显示压缩文件内所包含的文件 - V 执行是时显示详细的信息。<br />\n-q 执行时不显示任何信息。<br />\n-d &lt;目录&gt; 指定文件解压缩后所要存储的目录。</p>\n<p>实例</p>\n<p>解压文件<br />\n <code>unzip abc.zip</code></p>\n<p>查看压缩文件中包含的文件:<br />\n <code>unzip-l abc.zip</code></p>\n<h2 id=\"gzip\"><a class=\"anchor\" href=\"#gzip\">#</a> gzip</h2>\n<ol>\n<li>tar 调用 gzipgzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip.<br />\ntar 中使用 - z 这个参数来调用 gzip 常用命令:</li>\n</ol>\n<p><code>tar-czf all.tar.gz *.jpg</code>   #将所有.jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包 all.tar.gz</p>\n<p><code>tar-xzf all.tar.gz</code>   #将包 all.tar.z 解开</p>\n<ol start=\"2\">\n<li>tar 调用 bzip2bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。与 bzip2 相对的解压程序是 bunzip</li>\n</ol>\n<p>tar 中使用 - j 这个参数来调用 bzip2</p>\n<p>常用命令:</p>\n<p>tar -cjfall.tar.bz2 *.jpg #将所有.jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，包名为 all.tar.bz2</p>\n<p>tar -xjf all.tar.bz2  #将上面产生的包解开</p>\n",
            "tags": [
                "Linux",
                "Linux"
            ]
        }
    ]
}