{
    "version": "https://jsonfeed.org/version/1",
    "title": "1asy",
    "subtitle": "Till I no longer can",
    "icon": "https://self-ferry.github.io/images/favicon.ico",
    "description": "临渊羡鱼，不如退而结网",
    "home_page_url": "https://Self-ferry.github.io",
    "items": [
        {
            "id": "https://self-ferry.github.io/2021/04/25/C%E3%80%81C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "https://self-ferry.github.io/2021/04/25/C%E3%80%81C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "C、C++学习笔记",
            "date_published": "2021-04-25T08:49:55.000Z",
            "content_html": "<h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n<p><a href=\"C%E3%80%81C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.htm\"></a></p>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/04/20/Linux%E4%B8%AD%E7%9A%84su%E4%B8%8Esu-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://self-ferry.github.io/2021/04/20/Linux%E4%B8%AD%E7%9A%84su%E4%B8%8Esu-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "Linux中的su与su -命令的区别",
            "date_published": "2021-04-20T14:26:01.000Z",
            "content_html": "<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p>详情见<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5oYTk3LmNvbS80MDAxLmh0bWw=\"> http://www.ha97.com/4001.html</span></p>\n<h2 id=\"区别\"><a class=\"anchor\" href=\"#区别\">#</a> 区别</h2>\n<p>su 命令和 su - 命令最大的本质区别就是：前者只是切换了 root 身份，但 Shell 环境仍然是普通用户的 Shell；而后者连用户和 Shell 环境一起切换成 root 身份了。只有切换了 Shell 环境才不会出现 PATH 环境变量错误。su 切换成 root 用户以后，pwd 一下，发现工作目录仍然是普通用户的工作目录；而用 su - 命令切换以后，工作目录变成 root 的工作目录了。用 echo $PATH 命令看一下 su 和 su - 以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用 su - 命令。</p>\n",
            "tags": [
                "LInux",
                "Linux"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/04/20/Linux%E9%85%8D%E7%BD%AEvsftp/",
            "url": "https://self-ferry.github.io/2021/04/20/Linux%E9%85%8D%E7%BD%AEvsftp/",
            "title": "Linux配置vsftp",
            "date_published": "2021-04-20T02:41:51.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>Linux 网络服务课的作业。虽然简单，但也让我踩了不少坑，记个笔记吧。<br />\n作业的内容是可以匿名上传或删除文件就可。</p>\n<h1 id=\"正文\"><a class=\"anchor\" href=\"#正文\">#</a> 正文</h1>\n<p>先换个 yum 的源，下载的快一点。<br />\n <code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></p>\n<p>换源前也可以先备份一下。<br />\n这里的详细内容可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1ZGluYW5peWEvYXJ0aWNsZS9kZXRhaWxzLzEwNTc1ODczOQ==\"> https://blog.csdn.net/wudinaniya/article/details/105758739</span></p>\n<h2 id=\"下载vsftp\"><a class=\"anchor\" href=\"#下载vsftp\">#</a> 下载 vsftp</h2>\n<p><code>yum -y install vsftpd</code></p>\n<h2 id=\"查看是否安装成功\"><a class=\"anchor\" href=\"#查看是否安装成功\">#</a> 查看是否安装成功</h2>\n<p><code>rpm -qa|grep vsftpd</code></p>\n<h2 id=\"关闭一切墙策略selinux\"><a class=\"anchor\" href=\"#关闭一切墙策略selinux\">#</a> 关闭一切墙 | 策略 | SELINUX</h2>\n<p><code>systemctl stop firewalld</code> <br />\n <code>iptables -F</code></p>\n<p>关闭 SELINUX，有两种方法：<br />\n临时关闭：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># getenforce</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Enforcing</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># setenforce 0</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># getenforce</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Permissive</pre></td></tr></table></figure><p>永久关闭：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># vim /etc/sysconfig/selinux</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token assign-left variable\">SELINUX</span><span class=\"token operator\">=</span>enforcing 改为 <span class=\"token assign-left variable\">SELINUX</span><span class=\"token operator\">=</span>disabled</pre></td></tr></table></figure><p>重启服务 reboot</p>\n<h2 id=\"修改vsftpdconfig\"><a class=\"anchor\" href=\"#修改vsftpdconfig\">#</a> 修改 vsftpd.config</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>修改配置文件 /etc/vsftpd.conf</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token assign-left variable\">anonymous_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许匿名访问</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token assign-left variable\">write_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许写文件</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token assign-left variable\">anon_upload_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许匿名用户上传文件</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token assign-left variable\">anon_mkdir_write_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许匿名用户创建目录和写权限</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token assign-left variable\">anon_other_write_enable</span><span class=\"token operator\">=</span>YES  <span class=\"token comment\"># 允许匿名用户删除、重命名等其它权限  这个在配置文件里默认找不到</span></pre></td></tr></table></figure><h2 id=\"这里附上详细的vsftpconfig配置\"><a class=\"anchor\" href=\"#这里附上详细的vsftpconfig配置\">#</a> 这里附上详细的 vsftp.config 配置</h2>\n<p>vsftpd 的配置文件在为 vsftpd.conf，一般在 /etc/vsftpd/ 目录下。</p>\n<table>\n    <tr>\n        <th>属性</th>\n        <th>属性值</th>\n        <th align=\"left\">含义</th>\n    </tr>\n    <tr>\n        <td>anonymous_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许匿名用户（anonymous）登录 <code>FTP</code>，如果该设置被注释，则默认允许</td>\n    </tr>\n    <tr>\n        <td>local_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许本地系统用户登录</td>\n    </tr>\n    <tr>\n        <td>write_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否开启任何形式的 <code>FTP</code> 写入命令，上传文件</td>\n    </tr>\n    <tr>\n        <td>local_umask</td>\n        <td>xxx</td>\n        <td align=\"left\">本地用户的 <code>umask</code> 设置，如果注释该设置则默认为 <code>077</code>，但一般都设置成 <code>022</code></td>\n    </tr>\n    <tr>\n        <td>anon_upload_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许匿名用户上传文件，如果要设置为允许，则需要先开启 <code>write_enable</code>，否则无效，此外对应目录还要具有写权限</td>\n    </tr>\n    <tr>\n        <td>anon_mkdir_write_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许匿名用户创建新目录</td>\n    </tr>\n    <tr>\n        <td>dirmessage_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">当进入某个目录时，发送信息提示给远程用户</td>\n    </tr>\n    <tr>\n        <td>xferlog_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否开启 上传/下载 的日志记录</td>\n    </tr>\n    <tr>\n        <td>connect_from_port_20</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否使用 <code>20</code> 端口来连接 <code>FTP</code></td>\n    </tr>\n    <tr>\n        <td>chown_uploads</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">匿名上传的文件是否由某一指定用户 <code>chown_username</code> 所有</td>\n    </tr>\n    <tr>\n        <td>chown_username</td>\n        <td>有效用户名</td>\n        <td align=\"left\">匿名上传的文件由该设定用户所有</td>\n    </tr>\n    <tr>\n        <td>xferlog_file</td>\n        <td>有效路径</td>\n        <td align=\"left\">设置日志文件的保存位置，默认为 <code>/var/log/xferlog</code></td>\n    </tr>\n    <tr>\n        <td>xferlog_std_format</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否使用标准的 <code>ftpd xferlog</code>日志格式，该格式日志默认保存在 <code>/var/log/xferlog</code></td>\n    </tr>\n    <tr>\n        <td>idle_session_timeout</td>\n        <td>数值</td>\n        <td align=\"left\">设置空闲连接的超时时间，单位 秒</td>\n    </tr>\n    <tr>\n        <td>data_connection_timeout</td>\n        <td>数值</td>\n        <td align=\"left\">设置等待数据传输的最大时间，单位 秒（<code>data_connection_timeout</code> 与 <code>idle_session_timeout</code>\n            在同一时间只有一个有效）\n        </td>\n    </tr>\n    <tr>\n        <td>nopriv_user</td>\n        <td>有效用户名</td>\n        <td align=\"left\">指定一个非特权用户，用于运行 <code>vsftpd</code></td>\n    </tr>\n    <tr>\n        <td>async_abor_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否支持异步 <code>ABOR</code> 请求</td>\n    </tr>\n    <tr>\n        <td>ascii_upload_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否开启 <code>ASCII</code> 模式进行文件上传，一般不开启</td>\n    </tr>\n    <tr>\n        <td>ascii_download_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否开启 <code>ASCII</code> 模式进行文件下载，一般不开启</td>\n    </tr>\n    <tr>\n        <td>ftpd_banner</td>\n        <td>…</td>\n        <td align=\"left\">自定义登录标语</td>\n    </tr>\n    <tr>\n        <td>deny_email_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">如果匿名登录，则会要求输入 email 地址，如果不希望一些 email 地址具有登录权限，则可以开启此项，并在 <code>banned_email_file</code>\n            指定的文件中写入对应的 email 地址\n        </td>\n    </tr>\n    <tr>\n        <td>banned_email_file</td>\n        <td>有效文件</td>\n        <td align=\"left\">当开启 <code>deny_email_enable</code> 时，需要通过此项指定一个保存登录无效 email 的文件</td>\n    </tr>\n    <tr>\n        <td>chroot_local_user</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否将所有用户限制在主目录，当为 <code>NO</code> 时， <code>FTP</code> 用户可以切换到其他目录</td>\n    </tr>\n    <tr>\n        <td>chroot_list_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否启用限制用户的名单列表</td>\n    </tr>\n    <tr>\n        <td>chroot_list_file</td>\n        <td>有效文件</td>\n        <td align=\"left\">用户列表，其作用与 <code>chroot_local_user</code> 和 <code>chroot_local_user</code> 的组合有关，详见下表</td>\n    </tr>\n    <tr>\n        <td>allow_writeable_chroot</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许用户对 ftp 根目录具有写权限，如果设置成不允许而目录实际上却具备写权限，则会报错</td>\n    </tr>\n    <tr>\n        <td>ls_recurse_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许 <code>ls -R</code> 指令来递归查询，递归查询比较耗资源</td>\n    </tr>\n    <tr>\n        <td>listen</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">如果为 <code>YES</code>，<code>vsftpd</code> 将以独立模式运行并监听 <code>IPv4</code> 的套接字，处理相关连接请求（该指令不能与\n            <code>listen_ipv6</code> 一起使用）\n        </td>\n    </tr>\n    <tr>\n        <td>listen_ipv6</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否允许监听 <code>IPv6</code> 套接字</td>\n    </tr>\n    <tr>\n        <td>pam_service_name</td>\n        <td>…</td>\n        <td align=\"left\">设置 <code>PAM</code> 外挂模块提供的认证服务所使用的配置文件名 ，即 <code>/etc/pam.d/vsftpd</code> 文件，此文件中 <code>file=/etc/vsftpd/ftpusers</code>\n            字段，说明了 <code>PAM</code> 模块能抵挡的帐号内容来自文件 <code>/etc/vsftpd/ftpusers</code> 中\n        </td>\n    </tr>\n    <tr>\n        <td>userlist_enable</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否启用 <code>user_list</code> 文件来控制用户登录</td>\n    </tr>\n    <tr>\n        <td>userlist_deny</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否拒绝 <code>user_list</code> 中的用户登录，此属性设置需在 <code>userlist_enable = YES</code> 时才有效</td>\n    </tr>\n    <tr>\n        <td>tcp_wrappers</td>\n        <td><code>YES</code>/<code>NO</code></td>\n        <td align=\"left\">是否使用 <code>tcp_wrappers</code> 作为主机访问控制方式</td>\n    </tr>\n    <tr>\n        <td>max_clients</td>\n        <td>数值</td>\n        <td align=\"left\">同一时间允许的最大连接数</td>\n    </tr>\n    <tr>\n        <td>max_per_ip</td>\n        <td>数值</td>\n        <td align=\"left\">同一个IP客户端连接的最大值</td>\n    </tr>\n    <tr>\n        <td>local_root</td>\n        <td>有效目录</td>\n        <td align=\"left\">系统用户登录后的根目录</td>\n    </tr>\n    <tr>\n        <td>anon_root</td>\n        <td>有效目录</td>\n        <td align=\"left\">匿名用户登录后的根目录</td>\n    </tr>\n    <tr>\n        <td>user_config_dir</td>\n        <td>有效目录</td>\n        <td align=\"left\">用户单独配置文件存放目录，该目录下用户的文件名就是对应用户名</td>\n    </tr>\n</table>\n<h2 id=\"以上搞完之后还要把ftp目录的权限给更改\"><a class=\"anchor\" href=\"#以上搞完之后还要把ftp目录的权限给更改\">#</a> 以上搞完之后还要把 ftp 目录的权限给更改</h2>\n<p><code>chmod 777 /var/ftp/pub</code></p>\n<p>这里只能更改 ftp 目录下的子目录的权限。这就是个坑，当更改 /etc/ftp/ 这个目录的权限时，都没法登陆这个 ftp 服务器了。<br />\n当然是可以更改 ftp 下的目录的，在 vsftpd.config 中配置。</p>\n",
            "tags": [
                "Linux",
                "CentOS7配置vsftp"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/30/win32%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8B%E4%BB%B6%E6%B6%88%E6%81%AF/",
            "url": "https://self-ferry.github.io/2021/03/30/win32%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8B%E4%BB%B6%E6%B6%88%E6%81%AF/",
            "title": "win32（二）事件消息",
            "date_published": "2021-03-30T14:32:27.000Z",
            "content_html": "<h1 id=\"事件-消息\"><a class=\"anchor\" href=\"#事件-消息\">#</a> 事件 消息</h1>\n<p>Windows 中的事件是一个 &quot;动作&quot;，这个动作可能是用户操作应用程序产生的，也可能是 Windows 自己产生的.</p>\n<p>而消息，就是用来描述这些 &quot;动作&quot; 的，比如：</p>\n<p>这个动作是什么时候产生的？</p>\n<p>哪个应用程序产生的？</p>\n<p>在什么位置产生的？<br />\n等等。。。</p>\n<p><span class=\"label\">事件驱动消息，消息封装事件</span></p>\n<p>Windows 为了能够准确的描述这些信息，提供了一个结构体：MSG，该结构体里面记录的事件的详细信息.</p>\n<pre><code class=\"language-c++\">typedef struct tagMSG &#123;    \n\nHWND hwnd;     // 窗口句柄\n\nUINT message;     //消息类型\n\nWPARAM wParam;     // 对消息类型进一步描述\n\nLPARAM lParam;     //同上\n\nDWORD time;     // 动作发生时间\n\nPOINT pt;     //坐标，结构体封装了，内部是x，y\n\n&#125; MSG, *PMSG;     \n</code></pre>\n<p>说明：</p>\n<p>1、hwnd：</p>\n<p>表示消息所属的窗口</p>\n<p>一个消息一般都是与某个窗口相关联的</p>\n<p>在 Windows 中 HWND 类型的变量通常用来标识窗口。</p>\n<p>2、message</p>\n<p>在 Windows 中，消息是由一个数值来表示的</p>\n<p>但是由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏（WM == Window Message）</p>\n<p>鼠标左键按下 WM_LBUTTONDOWN        键盘按下 WM_KEYDOWN</p>\n<p>3、wParam 和 lParam</p>\n<p>32 位消息的特定附加信息，具体表示什么处决于 message</p>\n<p>4、time</p>\n<p>消息创建时的时间</p>\n<p>5、消息创建时的鼠标位置</p>\n<p>具体来说：如下图，用户输入后，封装成消息，加入系统的消息队列，然后应用程序那还有队列</p>\n<p>用来存储自己的消息队列，所以系统队列到应用程序队列是分流而治的过程。</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>从队列中取出消息，使用的是循环机制，就是不停的取出消息，而后面的判断消息类型是不是我们关心的意思其实是</p>\n<p>我们是否写了该消息下的响应函数，或者说回调函数。</p>\n<p>具体流程如下图：</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<h1 id=\"创建一个窗口程序\"><a class=\"anchor\" href=\"#创建一个窗口程序\">#</a> 创建一个窗口程序</h1>\n<p>步骤 1：创建 Windows 应用程序 选择空项目</p>\n<p>步骤 2：在新建项窗口中选 C++ 代码文件 创建一个新的 cpp 文件</p>\n<p>步骤 3：在新的 cpp 文件中添加: <code>#include &lt;Windows.h&gt;</code></p>\n<p>并添加入口函数：</p>\n<pre><code class=\"language-c++\">int CALLBACK WinMain(                 CALLBACK 是一个宏             \n\n_In_ HINSTANCE hInstance,         #define CALLBACK __stdcall    \n\n_In_ HINSTANCE hPrevInstance,     \n\n_In_ LPSTR lpCmdLine,                 \n\n_In_ int nCmdShow             \n\n)                     所有的Win32 API函数都遵循该约定    \n\n&#123;                     \n\nreturn 0;             \n\n&#125;                     \n\n</code></pre>\n<p>步骤 4：设计窗口类</p>\n<p>代码：</p>\n<pre><code class=\"language-c++\">\n//窗口的类名    \n\nTCHAR className[] = &quot;My First Window&quot;;     \n\n// 创建窗口类的对象     \n\nWNDCLASS wndclass = &#123;0&#125;;        //一定要先将所有值赋值    \n\nwndclass.hbrBackground = (HBRUSH)COLOR_MENU;        //窗口的背景色    \n\nwndclass.lpfnWndProc = WindowProc;        //窗口过程函数    \n\nwndclass.lpszClassName = className;        //窗口类的名字    \n\nwndclass.hInstance = hInstance;        //定义窗口类的应用程序的实例句柄    \n\n</code></pre>\n<p>步骤 5：注册窗口类    ，这是什么？哈哈哈，就是把结构体赋值后传参调用。</p>\n<pre><code class=\"language-c++\">RegisterClass(&amp;wndclass);     \n\n</code></pre>\n<p>步骤 6：创建窗口</p>\n<pre><code class=\"language-c++\">// 创建窗口     \n\nHWND hwnd = CreateWindow(     \n\nclassName,        //类名    \n\nTEXT(&quot;我的第一个窗口&quot;),        //窗口标题    \n\nWS_OVERLAPPEDWINDOW,        //窗口外观样式     \n\n10,        //相对于父窗口的X坐标    \n\n10,        //相对于父窗口的Y坐标    \n\n600,        //窗口的宽度     \n\n300,        //窗口的高度     \n\nNULL,        //父窗口句柄，为NULL     \n\nNULL,        //菜单句柄，为NULL     \n\nhInstance,        //当前应用程序的句柄     \n\nNULL);        //附加数据一般为NULL    \n\nif(hwnd == NULL)        //是否创建成功     \n\nreturn 0;     \n\n</code></pre>\n<p>步骤 7：显示窗口</p>\n<pre><code class=\"language-c++\">// 显示窗口     \n\nShowWindow(hwnd, SW_SHOW);     \n</code></pre>\n<p>步骤 8：消息循环</p>\n<pre><code class=\"language-c++\">MSG msg;     \n\nwhile(GetMessage(&amp;msg, NULL, 0, 0))     \n\n&#123;     \n\nTranslateMessage(&amp;msg);     \n\nDispatchMessage(&amp;msg);     \n\n&#125;     \n</code></pre>\n<p>步骤 9：回调函数</p>\n<pre><code class=\"language-c++\">/*                        \n\n窗口消息处理程序 窗口回调函数：            \n\n1、窗口回调函数处理过的消息，必须传回0.        \n\n2、窗口回调不处理的消息，由DefWindowProc来处理.    \n\n*/                        \n\nLRESULT CALLBACK WindowProc(         \n\nIN HWND hwnd,     \n\nIN UINT uMsg,     \n\nIN WPARAM wParam,     \n\nIN LPARAM lParam     \n\n)     \n\n&#123;     \n\nswitch(uMsg)    \n\n&#123;    \n\n//窗口消息    \n\ncase WM_CREATE:     \n\n&#123;    \n\nDbgPrintf(&quot;WM_CREATE %d %d\\n&quot;,wParam,lParam);    \n\nCREATESTRUCT* createst = (CREATESTRUCT*)lParam;    \n\nDbgPrintf(&quot;CREATESTRUCT %s\\n&quot;,createst-&gt;lpszClass);    \n\nreturn 0;    \n\n&#125;    \n\ncase WM_MOVE:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_MOVE %d %d\\n&quot;,wParam,lParam);    \n\nPOINTS points = MAKEPOINTS(lParam);    \n\nDbgPrintf(&quot;X Y %d %d\\n&quot;,points.x,points.y);    \n\nreturn 0;    \n\n&#125;    \n\ncase WM_SIZE:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_SIZE %d %d\\n&quot;,wParam,lParam);    \n\nint newWidth = (int)(short) LOWORD(lParam);     \n\nint newHeight = (int)(short) HIWORD(lParam);     \n\nDbgPrintf(&quot;WM_SIZE %d %d\\n&quot;,newWidth,newHeight);    \n\nreturn 0;    \n\n&#125;    \n\ncase WM_DESTROY:    //销毁\n\n&#123;    \n\nDbgPrintf(&quot;WM_DESTROY %d %d\\n&quot;,wParam,lParam);    \n\nPostQuitMessage(0);    \n\nreturn 0;    \n\n&#125;    \n\n//键盘消息    \n\ncase WM_KEYUP:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_KEYUP %d %d\\n&quot;,wParam,lParam);    \n\nreturn 0;    \n\n&#125;    \n\ncase WM_KEYDOWN:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_KEYDOWN %d %d\\n&quot;,wParam,lParam);    \n\nreturn 0;    \n\n&#125;    \n\n//鼠标消息    \n\ncase WM_LBUTTONDOWN:    \n\n&#123;    \n\nDbgPrintf(&quot;WM_LBUTTONDOWN %d %d\\n&quot;,wParam,lParam);    \n\nPOINTS points = MAKEPOINTS(lParam);    \n\nDbgPrintf(&quot;WM_LBUTTONDOWN %d %d\\n&quot;,points.x,points.y);    \n\nreturn 0;    \n\n&#125;    \n\n&#125;    \n\nreturn DefWindowProc(hwnd,uMsg,wParam,lParam);    //扔给windows处理其他消息\n\n&#125;     \n\n</code></pre>\n<p>MFC 就是基于此封装</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p>滴水逆向课件</p>\n",
            "tags": [
                "win32",
                "widows"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/30/win32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/",
            "url": "https://self-ferry.github.io/2021/03/30/win32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/",
            "title": "win32学习（一）",
            "date_published": "2021-03-30T07:14:33.000Z",
            "content_html": "<h1 id=\"winmain-函数\"><a class=\"anchor\" href=\"#winmain-函数\">#</a> WinMain 函数</h1>\n<pre><code class=\"language-c++\">int WINAPI WinMain(\n  HINSTANCE hInstance, // 应用程序当前实例的句柄\n\tHINSTANCE hPrevInstance, // 应用程序的先前实例的句柄。同一个程序打开两次，出现两个窗口，第一次打开的窗口就是先前实例的窗口。对于一个32位程序，该参数总为NULL。\n\tLPSTR IpCmdLine, // 命令行的字符串的指针\n\tint nShowCmd  // 窗口显示方式、默认为SW_SHOWDEFAULT\n);\n</code></pre>\n<p>WinMain 函数接收 4 个参数，这些参数都是在系统调用 WinMain 函数时，传递给应用程序的。</p>\n<p>第一个参数 hInstance 表示该程序当前运行的实例的句柄，这是一个数值。当程序在 Windows 下运行时，它唯一标识运行中的实例（注意，只有运行中的程序实例，才有实例句柄）。一个应用程序可以运行多个实例，每运行一个实例，系统都会给该实例分配一个句柄值，并通过 hInstance 参数传递给 WinMain 函数。</p>\n<p>第二个参数 hPrevInstance 表示当前实例的前一个实例的句柄。通过查看 MSDN 我们可以知道，在 Win32 环境下，这个参数总是 NULL ，即在 Win32 环境下，这个参数不再起作用。</p>\n<p>第三个参数 lpCmdLine 是一个以空终止的字符串，指定传递给应用程序的命令行参数。 例如：在 D 盘下有一个 sunxin.txt 文件，当我们用鼠标双击这个文件时将启动记事本程序（ notepad.exe ），此时系统会将 D:/sunxin.txt 作为命令行参数传递给记事本程序的 WinMain 函数，记事本程序在得到这个文件的全路径名后，就在窗口中显示该文件的内容。要在 VC++ 开发环境中向应用程序传递参数，可以单击菜单 【 Project 】→【 Settings 】，选择 “Debug” 选项卡，在 “ Program arguments ” 编辑框中输入你想传递给应用程序的参数。</p>\n<p>第四个参数 nCmdShow 指定程序的窗口应该如何显示，例如最大化、最小化、隐藏等。这个参数的值由该程序的调用者所指定，在调用 ShowWindow () 时可以使用到该值</p>\n<p>=============================================================</p>\n<p><span class=\"label\">应用程序句柄</span></p>\n<p>WinMain 函数的第一个参数 hInstance 就是可执行文件的实例句柄，实际上是个内存地址，它指出系统在何处把 exe 文件装载入进程的地址空间！<br />\nPE 中的 ImageBase</p>\n<p><span class=\"label\">窗口显示方式</span></p>\n<p>第四个参数 nCmdShow，指定窗口第一次出现 (程序刚刚启动时) 时的显示方式。显示方式有多种，比如：</p>\n<p>不显示，nCmdShow = 0;<br />\n 正常显示，nCmdShow = 1;(默认为 1)<br />\n 最小化显示，nCmdShow = 2;<br />\n 最大化显示，nCmdShow = 3;<br />\n 如果需要改变系统的默认的显示方式，需要在创建窗口之前指定 nCmdShow 的值 (通过一个简单的赋值语句 nCmdShow = n)</p>\n<p>不过，其实这里要让 nCmdShow 起作用，需要把 nCmdShow 作为参数传递给 ShowWindow 函数</p>\n<pre><code class=\"language-c++\">/*\n * ShowWindow() Commands\n */\n#define SW_HIDE             0\n#define SW_SHOWNORMAL       1\n#define SW_NORMAL           1     激活并显示一个窗口。如果窗口被最小化或最大化，系统 将其恢复到原来的尺寸和大小。应用程序 在第一次显示窗口的时候应该指定此标志。\n#define SW_SHOWMINIMIZED    2     激活窗口并将其最小化。\n#define SW_SHOWMAXIMIZED    3     激活窗口并将其最大化。\n#define SW_MAXIMIZE         3     最大化指定的窗口。\n#define SW_SHOWNOACTIVATE   4     以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。\n#define SW_SHOW             5     在窗口原来的位置以原来的尺寸激活和显示窗口。\n#define SW_MINIMIZE         6     最小化指定的窗口并且激活在Z序中的下一个顶层窗口。\n#define SW_SHOWMINNOACTIVE  7\n#define SW_SHOWNA           8     以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。\n#define SW_RESTORE          9     激活并显示窗口。如果窗口最小化或最大化，则系统 将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序 应该指定这个标志。\n#define SW_SHOWDEFAULT      10     依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序 的程序 传递给CreateProcess函数的。\n#define SW_FORCEMINIMIZE    11     在WindowNT5.0中最小化窗口，即使拥有窗口的线程被挂起也会最小化。在从其他线程最小化窗口时才使用这个参数。\n#define SW_MAX              11\n</code></pre>\n<h1 id=\"winapi和apientry\"><a class=\"anchor\" href=\"#winapi和apientry\">#</a> WINAPI 和 APIENTRY</h1>\n<p>另外，这里稍微说明一下  <code>WINAPI</code>  这个宏定义，我们看 WinMain 函数的原型：</p>\n<pre><code class=\"language-c++\">int WINAPI WinMain(\n    HINSTANCE hInstance,\n    HINSTANCE hPreInstance,\n    LPSTR     lpCmdLine,\n    int       nCmdShow\n);\n</code></pre>\n<p>WINAPI 是这样定义的：</p>\n<p><code>#define WINAPI      __stdcall</code></p>\n<p>在 VC6.0 下生成的 WinMain 函数，实际上是：</p>\n<pre><code class=\"language-c++\">int APIENTRY WinMain(\n    HINSTANCE hInstance,\n    HINSTANCE hPreInstance,\n    LPSTR     lpCmdLine,\n    int       nCmdShow\n);\n</code></pre>\n<p>APIENTRY 这个定义为：</p>\n<p><code>#define APIENTRY    WINAPI</code></p>\n<p>所以归根到底都是  <code>__stdcall</code> ，这个是什么东西了？这里解释一下：</p>\n<p><code>__stdcall</code>  一种调用约定 (调用函数时候的一种约定)，其他的调用约定有：</p>\n<p><code>__cdecl 和 __fastcall</code></p>\n<p>调用约定将决定以下内容：</p>\n<p>1) 函数参数的压栈顺序，</p>\n<p>2) 由调用者还是被调用者把参数弹出栈，</p>\n<p>3) 以及产生函数修饰名的方法。</p>\n<p>WIN32API 使用的是 <code>__stdcall</code>  调用约定</p>\n<p>标准 C，C++ 使用的是 <code>__cdecl</code>  调用约定</p>\n<p><code>__stdcall</code>  调用约定：函数的参数自右向左压栈，被调用的函数在返回前清理传送参数的内存栈</p>\n<p><code>__cdecl</code>  调用约定：每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用 <code>_stdcall</code>  函数的大。函数采用从右到左的压栈方式。注意：对于可变参数的成员函数，始终使用 <code>__cdecl</code>  的调用约定</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zMDI0Nzc4MS9hcnRpY2xlL2RldGFpbHMvOTcxNDE1MTg=\">https://blog.csdn.net/weixin_30247781/article/details/97141518</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjMzMzU1MS9hcnRpY2xlL2RldGFpbHMvMTEzMjUwOTk5\">https://blog.csdn.net/weixin_42333551/article/details/113250999</span></p>\n",
            "tags": [
                "win32",
                "WinMain函数"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/24/%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0/",
            "url": "https://self-ferry.github.io/2021/03/24/%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0/",
            "title": "汇编复习",
            "date_published": "2021-03-24T12:19:17.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>之前学的，因为一些事情就耽搁了，转而学其他的了，现在有时间了，打算接着学，发现忘的差不多了。只能重学了。<br />\n逆水行舟，不进则退。</p>\n<h1 id=\"内存格式\"><a class=\"anchor\" href=\"#内存格式\">#</a> 内存格式</h1>\n<ol>\n<li>每个内存单元宽度为 8</li>\n<li>【0x 编号】称为内存地址</li>\n<li>内存是存储数据的，内存地址是对存储数据的一个标识，指向数据却不是数据，通过内存地址的指引，可以访问到内存当中指向的数据.</li>\n</ol>\n<p>内存最小的单位是一个字节 ==&gt;&gt; 8 个二进制数  ==&gt;&gt; 两位的十六进制数</p>\n<p>一个内存单元能存一个两位的十六进制数，而这就是内存数据</p>\n<h1 id=\"简单指令intel汇编语法\"><a class=\"anchor\" href=\"#简单指令intel汇编语法\">#</a> 简单指令 (intel 汇编语法)</h1>\n<h2 id=\"mov\"><a class=\"anchor\" href=\"#mov\">#</a> mov</h2>\n<p>格式：  <code>mov destination, source</code></p>\n<p><code>mov eax, ebx</code>   // 将 EBX 中的内容复制到 EAX 寄存器中<br />\n <code>mov eax, 0x42</code>  // 将立即数 0x42 复制到 EAX 寄存器中<br />\n <code>mov eax, [0x443212C4]</code>  // 将内存地址 0x443212C4 的四个字节复制到 EAX 寄存器<br />\n <code>mov eax, [ebx+esi*4]</code>   // 将 ebx+esi*4 等式结果只想的内存地址处 4 个字节复制至 EAX</p>\n<h2 id=\"lea\"><a class=\"anchor\" href=\"#lea\">#</a> lea</h2>\n<p>格式：  <code>lea destination, source</code></p>\n<p>lea 指令用来将一个内存地址赋给目的操作数。<br />\n例如，  <code>lea eax, [ebx+8]</code>  就是将 EBX+8 的值给 EAX。<br />\n相反的， <code>mov eax, [ebx+8]</code>  则加载内存中地址为 EBX+8 处的数据。</p>\n<h2 id=\"算术运算\"><a class=\"anchor\" href=\"#算术运算\">#</a> 算术运算</h2>\n<h3 id=\"加减运算\"><a class=\"anchor\" href=\"#加减运算\">#</a> 加减运算</h3>\n<p><span class=\"label\">例子</span></p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:left\">指令</td>\n<td style=\"text-align:left\">描述</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sub eax,0x10</td>\n<td style=\"text-align:left\">EAX 寄存器值减去 0x10</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">add eax,ebx</td>\n<td style=\"text-align:left\">将 EBX 值加入 EAX 并将结果保存至 EAX</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">inc edx</td>\n<td style=\"text-align:left\">EDX 值递增 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dec ecx</td>\n<td style=\"text-align:left\">ECX 值递减 1</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"乘除运算\"><a class=\"anchor\" href=\"#乘除运算\">#</a> 乘除运算</h3>\n<p>乘法和除法都使用了一个预先规定的寄存器。因此其运算就是指令码加上寄存器要去乘除的值。<br />\n <code>mul</code>  和 <code>div</code>  指令要操作的寄存器一般会在之前许多条指令的地方被赋值，因此你可能需要在程序的上下文中来寻找。<br />\n <code>mul value</code>  指令总是将 <code>eax</code>  乘上 <code>value</code> 。因此， <code>EAX</code>  寄存器必须在乘法指令出现前就赋值好。</p>\n<p>乘法的结果以 64 位的形式分开存储在两个寄存器中： <code>EDX</code>  和 <code>EAX</code> 。其中 EDX 存储了高的 32 位，EAX 存储低的 32 位。</p>\n<p>32 位模式下，MUL（无符号数乘法）指令有三种类型：</p>\n<pre><code>第一种执行 8 位操作数与 AL 寄存器的乘法；\n第二种执行 16 位操作数与 AX 寄存器的乘法；\n第三种执行 32 位操作数与 EAX 寄存器的乘法。\n</code></pre>\n<p>乘数和被乘数的大小必须保持一致，乘积的大小则是它们的一倍。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数：</p>\n<pre><code>MUL reg/mem8\nMUL reg/meml6\nMUL reg/mem32\n</code></pre>\n<p>MUL 指令中的单操作数是乘数。下表按照乘数的大小，列出了默认的被乘数和乘积。由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。</p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:left\">被乘数</td>\n<td style=\"text-align:left\">乘数</td>\n<td style=\"text-align:left\">乘积</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AL</td>\n<td style=\"text-align:left\">reg/mem8</td>\n<td style=\"text-align:left\">AX</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AX</td>\n<td style=\"text-align:left\">reg/mem16</td>\n<td style=\"text-align:left\">DX:AX</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">EAX</td>\n<td style=\"text-align:left\">reg/mem32</td>\n<td style=\"text-align:left\">EDX:EAX</td>\n</tr>\n</tbody>\n</table>\n<p>如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置 1。因为进位标志位常常用于无符号数的算术运算，在此我们也主要说明这种情况。例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。</p>\n<p>有个很好的理由要求在执行 MUL 后检查进位标志位，即，确认忽略乘积的高半部分是否安全。</p>\n<p>32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下：</p>\n<pre><code>DIV reg/mem8\nDIV reg/meml6\nDIV reg/mem32\n</code></pre>\n<p>下表给出了被除数、除数、商和余数之间的关系：</p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:left\">被除数</td>\n<td style=\"text-align:left\">除数</td>\n<td style=\"text-align:left\">商</td>\n<td>余数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AX</td>\n<td style=\"text-align:left\">reg/mem8</td>\n<td style=\"text-align:left\">AL</td>\n<td>AH</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DX:AX</td>\n<td style=\"text-align:left\">reg/mem16</td>\n<td style=\"text-align:left\">AX</td>\n<td>DX</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">EDX:EAX</td>\n<td style=\"text-align:left\">reg/mem32</td>\n<td style=\"text-align:left\">EAX</td>\n<td>EDX</td>\n</tr>\n</tbody>\n</table>\n<p>64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数，商存放到 RAX，余数存放在 RDX 中。</p>\n<h2 id=\"逻辑运算符\"><a class=\"anchor\" href=\"#逻辑运算符\">#</a> 逻辑运算符</h2>\n<ol>\n<li>否操作指令 NOT</li>\n</ol>\n<p><code>NOT OPRD</code></p>\n<p>把 OPRD 取反，再回送给 OPRD</p>\n<p>对标志位没有影响</p>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<ol start=\"2\">\n<li>与操作指令 AND [与]</li>\n</ol>\n<p><code>AND OPRD1，OPRD2</code></p>\n<p>OPRD1 和 OPRD2 执行与操作，结果送到 OPRD1</p>\n<p>执行后，CF＝OF＝0，标志 PF，ZF，SF 反映运算结果，AF 未定义</p>\n<p>某个操作数自身与，值不变，可使进位标志 CF＝0</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p><span class=\"label\">例子</span></p>\n<p><code>mov al, 00001111b</code> <br />\n <code>and al, 11110101b</code></p>\n<p>最后 <code>al</code>  的结果就是 <code>00000101b</code></p>\n<ol start=\"3\">\n<li>或操作指令 OR [或]</li>\n</ol>\n<p><code>OR OPRD1 OPRD2</code></p>\n<p>标志位同与运算指令</p>\n<p>某个操作数自身或，值不变，可使进位标志 CF＝0</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<ol start=\"4\">\n<li>异或操作指令 XOR [异或]</li>\n</ol>\n<p><code>XOR OPRD1 OPRD2</code></p>\n<p>标志位同与运算指令</p>\n<p>某个操作数自身异或，值不变，可使进位标志 CF＝0</p>\n<p>与 0 异或，不变，与 1 异或，取反。</p>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n<ol start=\"5\">\n<li>测试指令 TEST</li>\n</ol>\n<p><code>TEST OPRD1 OPRD2</code></p>\n<p>指令与 AND 类似，但结果不回送</p>\n<p>指令执行后，ZF，PF，SF 反映运算结果，CF＝OF＝0</p>\n<h2 id=\"移位指令\"><a class=\"anchor\" href=\"#移位指令\">#</a> 移位指令</h2>\n<p>移位指令分为算术移位和逻辑移位。</p>\n<p>移动操作数的位有两种方法。第一种是逻辑移位 (logic shift)，空出来的位用 0 填充。如下图所示，一个字节的数据向右移动一位。也就是说，每一位都被移动到其旁边的低位上。注意，位 7 被填充为 0：</p>\n<p><img data-src=\"image005.png\" alt=\"\" /></p>\n<p>下图所示为二进制数 1100 1111 逻辑右移一位，得到 OllOOlll。最低位移入进位标志位：</p>\n<p><img data-src=\"image006.png\" alt=\"\" /></p>\n<p>另一种移位的方法是算术移位 (arithmetic shift)，空出来的位用原数据的符号位填充：</p>\n<p><img data-src=\"image007.png\" alt=\"\" /></p>\n<p>例如，二进制数 1100 1111，符号位为 1。算术右移一位后，得到 1110 0111：</p>\n<p><img data-src=\"image008.png\" alt=\"\" /></p>\n<p>逻辑移位:   <code>SHL</code> 、 <code>SHR</code> <br />\n 算术移位:   <code>CAL</code> 、 <code>CAR</code></p>\n<p>无符号数的乘法和除法可以用逻辑移位；<br />\n 有符号数的乘法和除法可以用算术移位；</p>\n<h3 id=\"逻辑移位指令\"><a class=\"anchor\" href=\"#逻辑移位指令\">#</a> 逻辑移位指令</h3>\n<p>SHL（左移）指令使目的操作数逻辑左移一位，最低位用 0 填充。最高位移入进位标志位，而进位标志位中原来的数值被丢弃<br />\n SHR（右移）指令使目的操作数逻辑右移一位，最高位用 0 填充。最低位复制到进位标志位，而进位标志位中原来的数值被丢弃</p>\n<p>SHL/SHR 的第一个操作数是目的操作数，第二个操作数是移位次数：<br />\nSHL/SHR destination,count</p>\n<p>该指令可用的操作数类型如下所示：<br />\nSHL/SHR reg, imm8<br />\nSHL/SHR mem, imm8<br />\nSHL/SHR reg, CL<br />\nSHL/SHR mem, CL</p>\n<p>x86 处理器允许 imm8 为 0〜255 中的任何整数。另外，CL 寄存器包含的是移位计数。上述格式同样适用于 SHR、SAL、SAR、ROR、ROL、RCR 和 RCL 指令。</p>\n<h3 id=\"算术移位指令\"><a class=\"anchor\" href=\"#算术移位指令\">#</a> 算术移位指令</h3>\n<p>算数移位指令分为：算数左移 SAL (Shift Algebraic Left) 和算数右移 SAR (Shift Algebraic Right);<br />\n 指令格式:  <code>SAL/SAR reg/mem,CL/imm</code> <br />\n 受影响的标志位：CF,OF,PF,SF,ZF; 对 AF 的影响无定义；</p>\n<h3 id=\"循环移位指令\"><a class=\"anchor\" href=\"#循环移位指令\">#</a> 循环移位指令</h3>\n<p>循环移位指令 ror 和 rol 与移位指令类似，但移出的那一位会被填到另一端空出来的位置上，即右循环指令（ror）会将最低位循环一到最高位；左循环移位（rol）则相反。</p>\n<h2 id=\"nop指令\"><a class=\"anchor\" href=\"#nop指令\">#</a> NOP 指令</h2>\n<p>nop 指令什么也不做。当它出现时，直接执行下一条指令。<br />\nnop 指令实际上是 xchg eax,eax 的一个谓名字</p>\n<h1 id=\"栈\"><a class=\"anchor\" href=\"#栈\">#</a> 栈</h1>\n<h2 id=\"posh-指令\"><a class=\"anchor\" href=\"#posh-指令\">#</a> posh 指令</h2>\n<h1 id=\"renference\"><a class=\"anchor\" href=\"#renference\">#</a> Renference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjI3MjM1L2FydGljbGUvZGV0YWlscy84MDM2ODI1NA==\">https://blog.csdn.net/qq_41627235/article/details/80368254</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZW5rdS5iYWlkdS5jb20vdmlldy81MThkM2U4NWRmMzZhMzJkNzM3NWE0MTc4NjZmYjg0YWU0NWNjMzg2Lmh0bWw=\">https://wenku.baidu.com/view/518d3e85df36a32d7375a417866fb84ae45cc386.html</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodWhlamlhbzE1MTYvYXJ0aWNsZS9kZXRhaWxzLzEwMDg3NTEwNQ==\">https://blog.csdn.net/chuhejiao1516/article/details/100875105</span><br />\n<span class=\"exturl\" data-url=\"aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzM1ODkuaHRtbA==\">http://c.biancheng.net/view/3589.html</span></p>\n",
            "tags": [
                "汇编",
                "x86汇编指令"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/24/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/",
            "url": "https://self-ferry.github.io/2021/03/24/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/",
            "title": "密码学数论基础",
            "date_published": "2021-03-24T06:19:48.000Z",
            "content_html": "<h1 id=\"数论基础\"><a class=\"anchor\" href=\"#数论基础\">#</a> 数论基础</h1>\n<h2 id=\"整除性和带余除法\"><a class=\"anchor\" href=\"#整除性和带余除法\">#</a> 整除性和带余除法</h2>\n<h2 id=\"整除性\"><a class=\"anchor\" href=\"#整除性\">#</a> 整除性</h2>\n<p><span class=\"label\">定义：</span><br />\na、b 是两个整数，b≠0 ，如果存在一个整数 m 使等式 a=m*b 成立，则称 b 整除 a，记为 b|a,a 是被除数，b 是除数。</p>\n<p>a/b 记为 b|a a 除以 b 记为 b 整除 a</p>\n<p><span class=\"label\">性质：</span></p>\n<ul>\n<li>若 a|1， 则 a=±1。</li>\n<li>若 a|b 且 b|a，则 a=±b。</li>\n<li>任何不等于零的数整除 0。</li>\n<li>若 a|b 且 b|c，则 a|c。<br />\n <code>11|66 且 66|198 =&gt; 11|198</code></li>\n<li>对任意整数 m，n，若 b|g 且 b|h，则可得出 b|（mg+nh）。</li>\n</ul>\n<p>之所以得出最后一条结论，是因为：</p>\n<ul>\n<li>若 b|g，存在 g1，使得 g 可以表示为 g=b*g1</li>\n<li>若 b|h, 则存在 h1，使得还可以表示为 h=b*h1</li>\n</ul>\n<p>所以：<br />\n <code>mg + nh = mbg1 + nbh1 = b * (mg1 + nh1)</code> <br />\n 得出 b 整除 mg+nh。</p>\n<p><span class=\"label\">例题</span><br />\n<img data-src=\"image001.png\" alt=\"\" /></p>\n<h3 id=\"带余除法\"><a class=\"anchor\" href=\"#带余除法\">#</a> 带余除法</h3>\n<p>对给定的任意一个正整数 n 和任意非负整数 a, 若用 n 除 a, 得到整数商 q 和整数余数 r, 则满足以下关系式:<br />\n <code>a = qn + r, 0 ≤ r &lt; n; q = |(a|b)|</code></p>\n<h2 id=\"欧几里得算法\"><a class=\"anchor\" href=\"#欧几里得算法\">#</a> 欧几里得算法</h2>\n<h3 id=\"最大公约数\"><a class=\"anchor\" href=\"#最大公约数\">#</a> 最大公约数</h3>\n<p>最大公约数，也称最大公因数、最大公因子，指两个或多个整数共有约数中最大的一个。</p>\n<p>对于整数 a,b,m, 若满足 a=mb, 则称非零整数 b 是 a 的一个因子。我们用 gcd (a,b) 来表示 a 的最大公因子。a 和 b 的最大公因子是能同时整除 a 和 b 的最大整数。另外，定义 gcd (0,0)=0。<br />\n更正式的描述是，正整数 c 称为 a 和 b 的最大公因子，如果<br />\n (1) c 是 a 和 b 的因子。<br />\n(2) a、b 的因子都是 c 的一个因子。</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n",
            "tags": [
                "密码编码学与网络安全",
                "数论基础"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/23/%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/",
            "url": "https://self-ferry.github.io/2021/03/23/%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/",
            "title": "数组与矩阵",
            "date_published": "2021-03-23T11:09:25.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=\"]}]'></div></div>\n<h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/03/23/pandas%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "url": "https://self-ferry.github.io/2021/03/23/pandas%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "title": "pandas库学习",
            "date_published": "2021-03-23T11:08:13.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=\"]}]'></div></div>\n<h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/03/23/numpy%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "url": "https://self-ferry.github.io/2021/03/23/numpy%E5%BA%93%E5%AD%A6%E4%B9%A0/",
            "title": "numpy库学习",
            "date_published": "2021-03-23T11:07:40.000Z",
            "content_html": "<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9udW1weS9udW1weS10dXRvcmlhbC5odG1s\">https://www.runoob.com/numpy/numpy-tutorial.html</span></p>\n<h1 id=\"numpy库简介\"><a class=\"anchor\" href=\"#numpy库简介\">#</a> Numpy 库简介</h1>\n<p>NumPy (Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p>\n<p>NumPy 的前身 Numeric 最早是由 Jim Hugunin 与其它协作者共同开发，2005 年，Travis Oliphant 在 Numeric 中结合了另一个同性质的程序库 Numarray 的特色，并加入了其它扩展而开发了 NumPy。NumPy 为开放源代码并且由许多协作者共同维护开发。</p>\n<p>NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：</p>\n<ul>\n<li>一个强大的 N 维数组对象 ndarray</li>\n<li>广播功能函数</li>\n<li>整合 C/C++/Fortran 代码的工具</li>\n<li>线性代数、傅里叶变换、随机数生成等功能</li>\n</ul>\n<h1 id=\"numpy-应用\"><a class=\"anchor\" href=\"#numpy-应用\">#</a> NumPy 应用</h1>\n<p>NumPy 通常与 SciPy（Scientific Python）和 Matplotlib（绘图库）一起使用， 这种组合广泛用于替代 MatLab，是一个强大的科学计算环境，有助于我们通过 Python 学习数据科学或者机器学习。</p>\n<p>SciPy 是一个开源的 Python 算法库和数学工具包。</p>\n<p>SciPy 包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。</p>\n<p>Matplotlib 是 Python 编程语言及其数值数学扩展包 NumPy 的可视化操作界面。它为利用通用的图形用户界面工具包，如 Tkinter, wxPython, Qt 或 GTK+ 向应用程序嵌入式绘图提供了应用程序接口（API）。</p>\n<h1 id=\"相关链接\"><a class=\"anchor\" href=\"#相关链接\">#</a> 相关链接</h1>\n<p>NumPy 官网 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5udW1weS5vcmcv\">http://www.numpy.org/</span><br />\nNumPy 源代码：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL251bXB5L251bXB5\">https://github.com/numpy/numpy</span></p>\n<h1 id=\"numpy-ndarray对象\"><a class=\"anchor\" href=\"#numpy-ndarray对象\">#</a> Numpy Ndarray 对象</h1>\n<p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</p>\n<p>ndarray 对象是用于存放同类型元素的多维数组。</p>\n<p>ndarray 中的每个元素在内存中都有相同存储大小的区域。</p>\n<p>ndarray 内部由以下内容组成：</p>\n<ul>\n<li>\n<p>一个指向数据（内存或内存映射文件中的一块数据）的指针。</p>\n</li>\n<li>\n<p>数据类型或 dtype，描述在数组中的固定大小值的格子。</p>\n</li>\n<li>\n<p>一个表示数组形状（shape）的元组，表示各维度大小的元组。</p>\n</li>\n<li>\n<p>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要 &quot;跨过&quot; 的字节数。</p>\n</li>\n</ul>\n<h1 id=\"创建ndarray\"><a class=\"anchor\" href=\"#创建ndarray\">#</a> 创建 Ndarray</h1>\n<p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：<br />\n <code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p>\n<p>参数说明：</p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:right\">名称</td>\n<td style=\"text-align:left\">描述</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">object</td>\n<td style=\"text-align:left\">数组或嵌套的数列</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">dtype</td>\n<td style=\"text-align:left\">数组元素的数据类型，可选</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">copy</td>\n<td style=\"text-align:left\">对象是否需要复制，可选</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">order</td>\n<td style=\"text-align:left\">创建数组的样式，C 为行方向，F 为列方向，A 为任意方向（默认）</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">subok</td>\n<td style=\"text-align:left\">默认返回一个与基类类型一致的数组</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">ndmin</td>\n<td style=\"text-align:left\">指定生成数组的最小维度</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"认识numpy的数组对象ndarray\"><a class=\"anchor\" href=\"#认识numpy的数组对象ndarray\">#</a> 认识 Numpy 的数组对象 Ndarray</h1>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># -*- coding: utf-8 -*-</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 代码 2-1</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np  <span class=\"token comment\"># 导入 NumPy 库</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>arr1 <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 创建一维数组</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">' 创建的数组为： '</span><span class=\"token punctuation\">,</span> arr1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># 创建二维数组</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>arr2 <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的数组为：\\n'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组类型为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">.</span>dtype<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看数组类型</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组元素个数为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看数组元素个数</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组每个元素大小为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">.</span>itemsize<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看数组每个元素大小</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\"># 代码 2-2</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>arr2<span class=\"token punctuation\">.</span>shape <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span>  <span class=\"token comment\"># 重新设置 shape</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'重新设置shape 后的arr2 为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\"># 代码 2-3</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用arange函数创建的数组为：\\n'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\"># 代码 2-4</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用linspace函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>linspace<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\"># 代码 2-5</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用logspace函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>logspace<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token comment\"># 代码 2-6</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用zeros函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>zeros<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\"># 代码 2-7</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用eye函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>eye<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\"># 代码 2-8</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用diag函数创建的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>diag<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token comment\"># 代码 2-9</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用ones函数的数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>ones<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token comment\"># 代码 2-10</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>float64<span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 整型转换为浮点型</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>int8<span class=\"token punctuation\">(</span><span class=\"token number\">42.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 浮点型转换为整型</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 整型转换为布尔型</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 整型转换为布尔型</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span><span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 布尔型转换为浮点型</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'转换结果为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span><span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 布尔型转换为浮点型</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre></pre></td></tr><tr><td data-num=\"50\"></td><td><pre><span class=\"token comment\"># 代码 2-11</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>df <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>dtype<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>str_<span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"numitems\"</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>int64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>               <span class=\"token punctuation\">(</span><span class=\"token string\">\"price\"</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>float64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数据类型为：'</span><span class=\"token punctuation\">,</span> df<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre></pre></td></tr><tr><td data-num=\"55\"></td><td><pre><span class=\"token comment\"># 代码 2-12</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数据类型为：'</span><span class=\"token punctuation\">,</span> df<span class=\"token punctuation\">[</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数据类型为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>dtype<span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">[</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre></pre></td></tr><tr><td data-num=\"59\"></td><td><pre><span class=\"token comment\"># 代码 2-13</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>itemz <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tomatoes\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4.14</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"cabbages\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">13</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.72</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>                 dtype<span class=\"token operator\">=</span>df<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'自定义数据为：'</span><span class=\"token punctuation\">,</span> itemz<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre></pre></td></tr><tr><td data-num=\"64\"></td><td><pre><span class=\"token comment\"># 代码 2-14</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'生成的随机数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre></pre></td></tr><tr><td data-num=\"67\"></td><td><pre><span class=\"token comment\"># 代码 2-15</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'生成的随机数组为：\\n'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>rand<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre></pre></td></tr><tr><td data-num=\"70\"></td><td><pre><span class=\"token comment\"># 代码 2-16</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'生成的随机数组为：\\n'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>randn<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre></pre></td></tr><tr><td data-num=\"73\"></td><td><pre><span class=\"token comment\"># 代码 2-17</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'生成的随机数组为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>randint<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> size<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre></pre></td></tr><tr><td data-num=\"76\"></td><td><pre><span class=\"token comment\"># 代码 2-18</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 用整数作为下标可以获取数组中的某个元素</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre><span class=\"token comment\"># 用范围作为下标获取数组的一个切片，包括 arr [3] 不包括 arr [5]</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 省略开始下标，表示从 arr [0] 开始</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre><span class=\"token comment\"># 下标可以使用负数，-1 表示从数组后往前数的第一个元素</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>arr<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">101</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 下标还可以用来修改元素的值</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre><span class=\"token comment\"># 范围中的第三个参数表示步长，2 表示隔一个元素取一个元素</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 步长为负数时，开始下标必须大于结束下标</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre></pre></td></tr><tr><td data-num=\"91\"></td><td><pre><span class=\"token comment\"># 代码 2-19</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的二维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 索引第 0 行中第 3 和第 4 列的元素</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre><span class=\"token comment\"># 索引第 2 和第 3 行中第 3 列、第 4 列和第 5 列的元素</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：\\n'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 索引第 2 列的元素</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre></pre></td></tr><tr><td data-num=\"99\"></td><td><pre><span class=\"token comment\"># 代码 2-20</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre><span class=\"token comment\"># 从两个序列的对应位置取出两个整数组成下标：arr [0,1], arr [1,2], arr [2,3]</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 索引第 2、3 行中第 0、2、3 列的元素</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>mask <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span>np<span class=\"token punctuation\">.</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"105\"></td><td><pre><span class=\"token comment\"># mask 是一个布尔数组，它索引第 1、3 行中第 2 列的元素</span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'索引结果为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>mask<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre></pre></td></tr><tr><td data-num=\"108\"></td><td><pre><span class=\"token comment\"># 代码 2-21</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 创建一维数组</span></pre></td></tr><tr><td data-num=\"110\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的一维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"111\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'新的一维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 设置数组的形状</span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组维度为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>ndim<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看数组维度</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre></pre></td></tr><tr><td data-num=\"114\"></td><td><pre><span class=\"token comment\"># 代码 2-22</span></pre></td></tr><tr><td data-num=\"115\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"116\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的二维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"117\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组展平后为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>ravel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"118\"></td><td><pre></pre></td></tr><tr><td data-num=\"119\"></td><td><pre><span class=\"token comment\"># 代码 2-23</span></pre></td></tr><tr><td data-num=\"120\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组展平为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>flatten<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 横向展平</span></pre></td></tr><tr><td data-num=\"121\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'数组展平为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">.</span>flatten<span class=\"token punctuation\">(</span><span class=\"token string\">'F'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 纵向展平</span></pre></td></tr><tr><td data-num=\"122\"></td><td><pre></pre></td></tr><tr><td data-num=\"123\"></td><td><pre><span class=\"token comment\"># 代码 2-24</span></pre></td></tr><tr><td data-num=\"124\"></td><td><pre>arr1 <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"125\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的数组1为：'</span><span class=\"token punctuation\">,</span> arr1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"126\"></td><td><pre></pre></td></tr><tr><td data-num=\"127\"></td><td><pre>arr2 <span class=\"token operator\">=</span> arr1 <span class=\"token operator\">*</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"128\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的数组2为：'</span><span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"129\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'横向组合为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>hstack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># hstack 函数横向组合</span></pre></td></tr><tr><td data-num=\"130\"></td><td><pre></pre></td></tr><tr><td data-num=\"131\"></td><td><pre><span class=\"token comment\"># 代码 2-25</span></pre></td></tr><tr><td data-num=\"132\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'纵向组合为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>vstack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># vstack 函数纵向组合</span></pre></td></tr><tr><td data-num=\"133\"></td><td><pre></pre></td></tr><tr><td data-num=\"134\"></td><td><pre><span class=\"token comment\"># 代码 2-26</span></pre></td></tr><tr><td data-num=\"135\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'横向组合为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>concatenate<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> axis<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># concatenate 函数横向组合</span></pre></td></tr><tr><td data-num=\"136\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'纵向组合为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>concatenate<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">,</span> arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> axis<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># concatenate 函数纵向组合</span></pre></td></tr><tr><td data-num=\"137\"></td><td><pre></pre></td></tr><tr><td data-num=\"138\"></td><td><pre><span class=\"token comment\"># 代码 2-27</span></pre></td></tr><tr><td data-num=\"139\"></td><td><pre>arr <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>arange<span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"140\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'创建的二维数组为：'</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"141\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'横向分割为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>hsplit<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># hsplit 函数横向分割</span></pre></td></tr><tr><td data-num=\"142\"></td><td><pre></pre></td></tr><tr><td data-num=\"143\"></td><td><pre><span class=\"token comment\"># 代码 2-28</span></pre></td></tr><tr><td data-num=\"144\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'纵向分割为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>vsplit<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># vsplit 函数纵向分割</span></pre></td></tr><tr><td data-num=\"145\"></td><td><pre></pre></td></tr><tr><td data-num=\"146\"></td><td><pre><span class=\"token comment\"># 代码 2-29</span></pre></td></tr><tr><td data-num=\"147\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'横向分割为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> axis<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># split 函数横向分割</span></pre></td></tr><tr><td data-num=\"148\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'纵向分割为：'</span><span class=\"token punctuation\">,</span> np<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> axis<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># split 函数纵向分割</span></pre></td></tr></table></figure>",
            "tags": [
                "python",
                "数据分析"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/09/web%E6%BC%8F%E6%B4%9E-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/",
            "url": "https://self-ferry.github.io/2021/03/09/web%E6%BC%8F%E6%B4%9E-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/",
            "title": "web漏洞-业务逻辑漏洞",
            "date_published": "2021-03-09T08:15:23.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=491097414\"]}]'></div></div>\n<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>又要鸽了 0，有事情要忙。</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzE5NTgzNy5odG1s\">逻辑漏洞挖掘初步总结篇</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vWC1jYWlqaS9wLzExMjA5OTYzLmh0bWw=\">Web 安全测试中常见逻辑漏洞解析（实战篇）</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5OTE2OTIvYXJ0aWNsZS9kZXRhaWxzLzgyOTUzMjEz\">常见逻辑漏洞</span></p>\n<p>挖掘出属于自己思维的逻辑漏洞。</p>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/03/09/Nmap%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/",
            "url": "https://self-ferry.github.io/2021/03/09/Nmap%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/",
            "title": "Nmap速查手册",
            "date_published": "2021-03-09T08:14:20.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=30621618\"]}]'></div></div>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuMmN0by5jb20vQXJ0aWNsZS8yMDE0MTIvMzYyMTg4Lmh0bWw=\">https://www.2cto.com/Article/201412/362188.html</span></p>\n<h1 id=\"nmap-简介\"><a class=\"anchor\" href=\"#nmap-简介\">#</a> Nmap 简介</h1>\n<p>Nmap 是 Network Mapper 的简称<br />\n Nmap 是一款开源免费的网络发现（Network Discovery）和安全审计（Security Auditing）工具<br />\n 1997 年由 Fyodor 创建</p>\n<p>Nmap 四项基本功能：</p>\n<p>1. 主机发现（Host Discovery）<br />\n2. 端口扫描（Port Scanning）<br />\n3. 版本侦测（Version Detection）<br />\n4. 操作系统侦测（Operating System Detection）</p>\n<p>这四项功能之间，又存在大致的依赖关系（通常情况下的顺序关系，但特殊应用另外考虑），首先需要进行主机发现，随<br />\n后确定端口状况，然后确定端口上运行具体应用程序与版本信息，然后可以进行操作系统的侦测。而在四项基本功能的基<br />\n础上，Nmap 提供防火墙与 IDS（IntrusionDetection System, 入侵检测系统）的规避技巧，可以综合应用到四个基本功<br />\n能的各个阶段；另外 Nmap 提供强大的 NSE（Nmap Scripting Language）脚本引擎功能，脚本可以对基本功能进行补充<br />\n和扩展。</p>\n<p><span class=\"label info\">大致功能为:</span></p>\n<ol>\n<li>主机存活检测</li>\n<li>端口探测</li>\n<li>服务识别</li>\n<li>操作系统识别</li>\n<li>硬件地址检测</li>\n<li>服务版本识别</li>\n<li>漏洞扫描，使用 nmap 自带脚本</li>\n</ol>\n<h1 id=\"nmap参数详解\"><a class=\"anchor\" href=\"#nmap参数详解\">#</a> Nmap 参数详解</h1>\n<h2 id=\"nmap支持主机名ip网段的表示方式\"><a class=\"anchor\" href=\"#nmap支持主机名ip网段的表示方式\">#</a> Nmap 支持主机名，ip, 网段的表示方式</h2>\n<p>例如:blah.highon.coffee, <span class=\"exturl\" data-url=\"aHR0cDovL25hbXAub3JnLzI0\">namp.org/24</span>, 192.168.0.1;10.0.0-25.1-254</p>\n<p>-iL filename                    从文件中读取待检测的目标，文件中的表示方法支持机名，ip, 网段<br />\n - iR hostnum                     随机选取，进行扫描。如果 - iR 指定为 0, 则是无休止的扫描<br />\n --exclude host1 [, host2]        从扫描任务中需要排除的主机<br />\n --exculdefile exclude_file      排除文件中的 IP, 格式和 - iL 指定扫描文件的格式相同</p>\n<h2 id=\"0x00-主机发现\"><a class=\"anchor\" href=\"#0x00-主机发现\">#</a> 0x00 主机发现</h2>\n<p>-sL                     仅仅是显示，扫描的 IP 数目，不会进行任何扫描<br />\n - sn                     ping 扫描，即主机发现<br />\n - Pn                     不检测主机存活<br />\n - PS/PA/PU/PY [portlist]  TCP SYN Ping/TCP ACK Ping/UDP Ping 发现<br />\n - PE/PP/PM               使用 ICMP echo, timestamp and netmask 请求包发现主机<br />\n - PO [prococol list]      使用 IP 协议包探测对方主机是否开启<br />\n - n/-R                   不对 IP 进行域名反向解析 / 为所有的 IP 都进行域名的反响解析</p>\n<h2 id=\"0x01-扫描技巧\"><a class=\"anchor\" href=\"#0x01-扫描技巧\">#</a> 0x01 扫描技巧</h2>\n<p>-sS/sT/sA/sW/sM                 TCP SYN/TCP connect ()/ACK/TCP 窗口扫描 / TCP Maimon 扫描<br />\n - sU                             UDP 扫描<br />\n - sN/sF/sX                       TCP Null，FIN，and Xmas 扫描<br />\n --scanflags                     自定义 TCP 包中的 flags<br />\n-sI zombie host[:probeport]     Idlescan<br />\n-sY/sZ                          SCTP INIT/COOKIE-ECHO 扫描<br />\n - sO                             使用 IP protocol 扫描确定目标机支持的协议类型<br />\n - b “FTP relay host” 使用 FTP bounce scan</p>\n<h2 id=\"0x02-指定端口和扫描顺序\"><a class=\"anchor\" href=\"#0x02-指定端口和扫描顺序\">#</a> 0x02 指定端口和扫描顺序</h2>\n<p>-p                      特定的端口 -p80,443 或者 -p1-65535<br />\n-p U:PORT               扫描 udp 的某个端口，-p U:53<br />\n-F                      快速扫描模式，比默认的扫描端口还少<br />\n - r                      不随机扫描端口，默认是随机扫描的<br />\n --top-ports &quot;number&quot;    扫描开放概率最高的 number 个端口，出现的概率需要参考 nmap-services 文件，ubuntu 中该文件位于 /usr/share/nmap.nmap 默认扫前 1000 个<br />\n --port-ratio &quot;ratio&quot;    扫描指定频率以上的端口</p>\n<h2 id=\"0x03-服务版本识别\"><a class=\"anchor\" href=\"#0x03-服务版本识别\">#</a> 0x03 服务版本识别</h2>\n<p>-sV                             开放版本探测，可以直接使用 - A 同时打开操作系统探测和版本探测<br />\n --version-intensity &quot;level&quot;     设置版本扫描强度，强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是 7<br />\n--version-light                 打开轻量级模式，为 --version-intensity 2 的别名<br />\n --version-all                   尝试所有探测，为 --version-intensity 9 的别名<br />\n --version-trace                 显示出详细的版本侦测过程信息</p>\n<h2 id=\"0x04-脚本扫描\"><a class=\"anchor\" href=\"#0x04-脚本扫描\">#</a> 0x04 脚本扫描</h2>\n<p>-sC                             根据端口识别的服务，调用默认脚本<br />\n --script=”Lua scripts”          调用的脚本名<br />\n --script-args=n1=v1,[n2=v2]     调用的脚本传递的参数<br />\n --script-args-file=filename     使用文本传递参数<br />\n --script-trace                  显示所有发送和接收到的数据<br />\n --script-updatedb               更新脚本的数据库<br />\n --script-help=”Lua script”      显示指定脚本的帮助</p>\n<h2 id=\"0x05-os识别\"><a class=\"anchor\" href=\"#0x05-os识别\">#</a> 0x05 OS 识别</h2>\n<p>-O              启用操作系统检测，-A 来同时启用操作系统检测和版本检测<br />\n --osscan-limit  针对指定的目标进行操作系统检测 (至少需确知该主机分别有一个 open 和 closed 的端口)<br />\n--osscan-guess  推测操作系统检测结果，当 Nmap 无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap 默认进行这种匹配</p>\n<h2 id=\"0x06-防火墙ids躲避和欺骗\"><a class=\"anchor\" href=\"#0x06-防火墙ids躲避和欺骗\">#</a> 0x06 防火墙 / IDS 躲避和欺骗</h2>\n<p>-f; --mtu value                 指定使用分片、指定数据包的 MTU.<br />\n-D decoy1,decoy2,ME             使用诱饵隐蔽扫描<br />\n - S IP-ADDRESS                   源地址欺骗<br />\n - e interface                    使用指定的接口<br />\n - g/--source-port PROTNUM       使用指定源端口<br />\n --proxies url1,[url2],...       使用 HTTP 或者 SOCKS4 的代理</p>\n<p>--data-length NUM               填充随机数据让数据包长度达到 NUM<br />\n--ip-options OPTIONS            使用指定的 IP 选项来发送数据包<br />\n --ttl VALUE                     设置 IP time-to-live 域<br />\n --spoof-mac ADDR/PREFIX/VEBDOR  MAC 地址伪装<br />\n --badsum                        使用错误的 checksum 来发送数据包</p>\n<h2 id=\"0x07-输出\"><a class=\"anchor\" href=\"#0x07-输出\">#</a> 0x07 输出</h2>\n<p>-oN                     将标准输出直接写入指定的文件<br />\n - oX                     输出 xml 文件<br />\n - oS                     将所有的输出都改为大写<br />\n - oG                     输出便于通过 bash 或者 perl 处理的格式，非 xml<br />\n-oA BASENAME            可将扫描结果以标准格式、XML 格式和 Grep 格式一次性输出<br />\n - v                      提高输出信息的详细度<br />\n - d level                设置 debug 级别，最高是 9<br />\n--reason                显示端口处于带确认状态的原因<br />\n --open                  只输出端口状态为 open 的端口<br />\n --packet-trace          显示所有发送或者接收到的数据包<br />\n --iflist                显示路由信息和接口，便于调试<br />\n --log-errors            把日志等级为 errors/warings 的日志输出<br />\n --append-output         追加到指定的文件<br />\n --resume FILENAME       恢复已停止的扫描<br />\n --stylesheet PATH/URL   设置 XSL 样式表，转换 XML 输出<br />\n --webxml                从 namp.org 得到 XML 的样式<br />\n --no-sytlesheet         忽略 XML 声明的 XSL 样式表</p>\n<h2 id=\"0x08-其他选项\"><a class=\"anchor\" href=\"#0x08-其他选项\">#</a> 0x08 其他选项</h2>\n<p>-6                      开启 IPv6<br />\n-A                      OS 识别，版本探测，脚本扫描和 traceroute<br />\n--datedir DIRNAME       说明用户 Nmap 数据文件位置<br />\n --send-eth /--send-ip  使用原以太网帧发送 / 在原 IP 层发送<br />\n --privileged            假定用户具有全部权限<br />\n --unprovoleged          假定用户不具有全部权限，创建原始套接字需要 root 权限<br />\n - V                      打印版本信息<br />\n - h                      输出帮助</p>\n<h1 id=\"nmap-例子\"><a class=\"anchor\" href=\"#nmap-例子\">#</a> nmap 例子</h1>\n<p>使用 ping 检测 10.0.0.0/24 这个网段</p>\n<p><code>nmap -sP 10.0.0.0/24</code></p>\n<p>使用 SYN 的方法对全端口进行扫描，在 aggressive (4) 的时间模板下，同时对开放的端口进行端口识别</p>\n<p><code>nmap -p1-65535 -sV -sS -T4 target</code></p>\n<p>PS: -T 代表的是扫描的时候，一些控制选项 (TCP 的延迟时间，探测报文之间的间隔等) 的集合，具体的 man nmap 一下就知道了</p>\n<p>使用 SYN 扫描，在 aggressive (4) 的时间模板下，探测操作系统的类型和版本，还有显示 traceroute 的结果，结果输出较为详细</p>\n<p><code>nmap -v -sS -A -T4 target</code></p>\n<p>使用 SYN 扫描，在 insane (5) 的时间模板下，探测操作系统的类型和版本，还有显示 traceroute 的结果，结果输出较为详细</p>\n<p><code>nmap -v -sS -A -T5 target</code></p>\n<p>使用 SYN 扫描，在 insane (5) 的时间模板下，探测操作系统的类型，还有显示 traceroute 的结果，操作系统的类型，结果输出较为详细</p>\n<p><code>nmap -v -sV -O -sS -T5 target</code></p>\n<p>使用 SYN 的方法对全端口进行扫描，同时对开放的端口进行端口识别，在 aggressive (4) 的时间模板下，探测操作系统的类型还有显示 traceroute 的结果，结果输出较为详细</p>\n<p><code>nmap -v -p 1-65535 -sV -O -sS -T4 target</code></p>\n<p>用 SYN 的方法对全端口进行扫描，同时对开放的端口进行端口识别，在 insane (5) 的时间模板下，探测操作系统的类型，还有显示 traceroute 的结果，结果输出较为详细</p>\n<p><code>nmap -v -p 1-65535 -sV -O -sS -T5 target</code></p>\n<p>从文件中读取需要扫描的 IP 列表</p>\n<p><code>nmap -iL ip-address.txt</code></p>\n<p>Nmap 输出格式</p>\n<ol>\n<li>扫描的结果输出到屏幕，同时会存储一份到 grep-output.txt</li>\n</ol>\n<p><code>nmap -sV -p 139,445 -oG grep-output.txt 10.0.1.0/24</code></p>\n<ol start=\"2\">\n<li>扫描结果输出为 html</li>\n</ol>\n<p><code>nmap -sS -sV -T5 10.0.1.99 --webxml -oX - | xsltproc --output file.html</code></p>\n<p>Nmap 扫描 Netbios</p>\n<ol>\n<li>在子网中发现开放 netbios 的 IP</li>\n</ol>\n<p><code>nmap -sV -v -p139,445 10.0.0.1/24</code></p>\n<ol start=\"2\">\n<li>扫描指定 netbios 的名称</li>\n</ol>\n<p><code>nmap -sU --script nbstat.nse -p 137 target</code></p>\n<p>扫描指定的目标，同时检测相关漏洞</p>\n<p><code>nmap --script-args=unsafe=1 --script smb-check-vulns.nse -p 445 target</code></p>\n<p>将 nmap 的 80 端口的扫描结果，通过管道交给 nikto 进行扫描</p>\n<p><code>Nmap Nikto Scan nmap -p80 10.0.1.0/24 -oG - | nikto.pl -h -</code></p>\n<p>将 nmap 的 80,443 端口的扫描结果，通过管道交给 nikto 进行扫描</p>\n<p><code>nmap -p80,443 10.0.1.0/24 -oG - | nikto.pl -h -</code></p>\n",
            "tags": [
                "web安全",
                "Nmap"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/03/02/%E5%88%9D%E5%AD%A6webshell%E6%A3%80%E6%B5%8B/",
            "url": "https://self-ferry.github.io/2021/03/02/%E5%88%9D%E5%AD%A6webshell%E6%A3%80%E6%B5%8B/",
            "title": "初学webshell检测",
            "date_published": "2021-03-02T09:51:07.000Z",
            "content_html": "<h1 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h1>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/02/26/%E5%9C%A8Android%E4%B8%8A%E5%AE%89%E8%A3%85kali/",
            "url": "https://self-ferry.github.io/2021/02/26/%E5%9C%A8Android%E4%B8%8A%E5%AE%89%E8%A3%85kali/",
            "title": "在Android上安装kali",
            "date_published": "2021-02-26T05:55:57.000Z",
            "content_html": "<h1 id=\"️正文\"><a class=\"anchor\" href=\"#️正文\">#</a> <span class=\"label success\">✔️正文</span></h1>\n<p>就不多此一举了，还是看国光大佬写的吧<br />\n链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3Fsc2VjLmNvbS8yMDE4LzA1L3Rlcm11eC5odG1s\">https://www.sqlsec.com/2018/05/termux.html</span></p>\n",
            "tags": [
                "Android",
                "Android"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/02/19/linux%E8%BF%9B%E9%98%B6/",
            "url": "https://self-ferry.github.io/2021/02/19/linux%E8%BF%9B%E9%98%B6/",
            "title": "linux进阶学习",
            "date_published": "2021-02-19T06:54:11.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=555964763\"]}]'></div></div>\n<h1 id=\"网络配置\"><a class=\"anchor\" href=\"#网络配置\">#</a> 网络配置</h1>\n<h2 id=\"ifconfig-详解\"><a class=\"anchor\" href=\"#ifconfig-详解\">#</a> ifconfig 详解</h2>\n<p>ifconfig 命令可以显示或配置网络设备 (网络接口卡) , 也可以修改这些配置。<br />\n用 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永久保存，那就要修改网卡的配置文件了。</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>DEVICE=“ens33” 　　# 网卡名称<br />\n // UP：表示 “接口已启用”。<br />\n// BROADCAST ：表示 “主机支持广播”。<br />\n// RUNNING：表示 “接口在工作中”。<br />\n// MULTICAST：表示 “主机支持多播”。<br />\n// MTU:1500（最大传输单元）：1500 字节<br />\n //inet ：网卡的 IP 地址。<br />\n//netmask ：网络掩码。<br />\n//broadcast ：广播地址。<br />\n// 网卡的 IPv6 地址<br />\n // 连接类型：Ethernet (以太网) HWaddr (硬件 mac 地址)<br />\n//txqueuelen (网卡设置的传送队列长度)<br />\n// RX packets 接收时，正确的数据包数。<br />\n// RX bytes 接收的数据量。<br />\n// RX errors 接收时，产生错误的数据包数。<br />\n// RX dropped 接收时，丢弃的数据包数。<br />\n// RX overruns 接收时，由于速度过快而丢失的数据包数。<br />\n// RX frame 接收时，发生 frame 错误而丢失的数据包数。<br />\n// TX packets 发送时，正确的数据包数。<br />\n// TX bytes 发送的数据量。<br />\n// TX errors 发送时，产生错误的数据包数。<br />\n// TX dropped 发送时，丢弃的数据包数。<br />\n// TX overruns 发送时，由于速度过快而丢失的数据包数。<br />\n// TX carrier 发送时，发生 carrier 错误而丢失的数据包数。<br />\n//collisions 冲突信息包的数目。</p>\n<p>lo: 表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。</p>\n<p>ifconfig 的配置针对当前起作用，, 当服务器进行重启启动，配置的 IP 和掩码等信息都会丢失因为 ifconfig 的没有把配置写入到配置文件，当系统重新启动中，会重新加载网络配置文件，因此配置会丢失</p>\n<p>ifconfig 命令 参数具体见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLWlmY29uZmlnLmh0bWw=\"> https://www.runoob.com/linux/linux-comm-ifconfig.html</span></p>\n<h2 id=\"网络配置文件\"><a class=\"anchor\" href=\"#网络配置文件\">#</a> 网络配置文件</h2>\n<p>网络接口配置文件均存放在 /etc/sysconfig/network-scripts/ 目录下</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@node ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat /etc/sysconfig/network-scripts/ifcfg-ens33 </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>none</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens33</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>3693f084-6c9a-4b4e-82ef-62377f4c3502</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens33</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes</pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.10.100</pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token assign-left variable\">PREFIX</span><span class=\"token operator\">=</span><span class=\"token number\">24</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span><span class=\"token number\">192.198</span>.10.1</pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">#################################</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>下面介绍改配置文件中的每一行的含义。</pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token comment\">#################################</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>:网卡设备名</pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token assign-left variable\">HWADDR</span><span class=\"token operator\">=</span>:网卡的物理地址</pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>:网卡的类型</pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>:网卡的UUID</pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span>:IP地址</pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span>:子网掩码</pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span>:网关</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token assign-left variable\">DNS1</span><span class=\"token operator\">=</span>:DNS</pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>:该网卡是否激活</pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token assign-left variable\">NM_CONTROLLED</span><span class=\"token operator\">=</span>:网络是否由NetworkManager进行管理</pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>：启动远程协议为静态设置</pre></td></tr></table></figure><h2 id=\"路由的查看及配置\"><a class=\"anchor\" href=\"#路由的查看及配置\">#</a> 路由的查看及配置</h2>\n<p>路由 (route) 就是分组在因特网上从一台计算机传输到另一台计算机的实际路径。<br />\n因特网上的每个路由器都存储有一张表，称为路由表 (routing table), 路由器正是依据路由表的内容将各个 IP 分组转发到正确的去处。</p>\n<p>路由，路由器，路由表的区别:</p>\n<p>路由：既可以指计算机之间的传输路径，又可以指传输这一动态过程<br />\n路由器：设备，即完成路由这一动态过程的设备<br />\n路由表：信息，是储存在路由器中的用来路由的信息</p>\n<p>查看路由命令：<br />\n <code>netstat -r</code></p>\n<p><code>route -n</code></p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<p>查看本机路由信息<br />\n <code>route -n</code></p>\n<p>添加一条默认路由，临时生效 (重启后就会失效)<br />\n <code>route add default qw 192.168.10.1</code></p>\n<p>删除一条默认路由<br />\n <code>route del default gw 192.168.10.1</code></p>\n<p>添加一条静态路由，发往 192.168.8.62 这个网段的全部要经过网关 192.168.1.1<br />\n <code>route add-net 192.168.8.0 netmask 255.255.255.0 gw 192.168.1.1</code></p>\n<p>删除一条静态路由，删除的时候可以不写网关<br />\n <code>route del -net 192.168.8.0 netmask 255.255.255.0 gw 192.168.1.1</code></p>\n<p>设置包转发功能:</p>\n<p>开启 Liunx 的路由转发功能:<br />\n 编辑 /etc/sysctl.conf 设置 net.pv4.p forward=1</p>\n<p>临时配置：<br />\n <code>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward</code></p>\n<h2 id=\"dns\"><a class=\"anchor\" href=\"#dns\">#</a> DNS</h2>\n<p>Linux 下查看本地的 DNS:<br />\n1.cat /etc/resolv.conf<br />\n2.nslookup <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20=\">www.baidu.com</span></p>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<h3 id=\"dns-查询工具\"><a class=\"anchor\" href=\"#dns-查询工具\">#</a> DNS 查询工具</h3>\n<ol>\n<li>\n<p>nslookup 是一个能够查询互联网域名服务器信息的程序。<br />\n他有两种工作模式，即 &quot;交互模式&quot; 和 &quot;非交互模式&quot;<br />\n在&quot; 交互模式 &quot; 下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。<br />\n而在 “非交互模式 &quot; 下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。</p>\n</li>\n<li>\n<p>Dig 是一个在类 Unix 命令行模式下查询 DNS 包括 NSi 录，A 记录，MX 记录等相关信息的工具。</p>\n</li>\n</ol>\n<p>dig 命令:<br />\n 查询一台主机，但是默认情况下，Dig 的输出信息很详细<br />\n最常用的查询是 A 记录，TXT (文本注释) , MXi 录，NS 记录</p>\n<p><img data-src=\"image004.png\" alt=\"\" /></p>\n<h3 id=\"dns域名解析中添加的各项解析记录\"><a class=\"anchor\" href=\"#dns域名解析中添加的各项解析记录\">#</a> DNS 域名解析中添加的各项解析记录</h3>\n<p>A 记录： 将域名指向一个 IPv4 地址（例如：100.100.100.100），需要增加 A 记录</p>\n<p>CNAME 记录： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加 CNAME 记录。这个域名一般是主机服务商提供的一个域名</p>\n<p>MX 记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置 MX 记录。建立邮箱时，一般会根据邮箱服务商提供的 MX 记录填写此记录</p>\n<p>NS 记录： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置 NS 记录</p>\n<p>TXT 记录： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做 SPF（反垃圾邮件）记录</p>\n<p>AAAA 记录： 将主机名（或域名）指向一个 IPv6 地址（例如：ff03:0:0:0:0:0:0:c1），需要添加 AAAA 记录</p>\n<p>SRV 记录： 添加服务记录服务器服务记录时会添加此项，SRV 记录了哪台计算机提供了哪个服务。格式为：服务的名字。协议的类型（例如：_example-server._tcp）。</p>\n<p>SOA 记录： SOA 叫做起始授权机构记录，NS 用于标识多台域名解析服务器，SOA 记录用于在众多 NS 记录中那一台是主服务器</p>\n<p>PTR 记录： PTR 记录是 A 记录的逆向记录，又称做 IP 反查记录或指针记录，负责将 IP 反向解析为域名</p>\n<p>显性 URL 转发记录： 将域名指向一个 http (s) 协议地址，访问域名时，自动跳转至目标地址。例如：将 www.liuht.cn 显性转发到 www.itbilu.com 后，访问 www.liuht.cn 时，地址栏显示的地址为：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5pdGJpbHUuY29t\">www.itbilu.com</span>。</p>\n<p>隐性 UR 转发记录 L： 将域名指向一个 http (s) 协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将 www.liuht.cn 显性转发到 www.itbilu.com 后，访问 www.liuht.cn 时，地址栏显示的地址仍然是：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5saXVodC5jbg==\">www.liuht.cn</span>。</p>\n<p><em><strong>Reference:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmx1ZXN0b3JtL3AvMTAzNDUzMzQuaHRtbA==\">https://www.cnblogs.com/bluestorm/p/10345334.html</span></strong></em></p>\n<h1 id=\"iptables详解\"><a class=\"anchor\" href=\"#iptables详解\">#</a> iptables 详解</h1>\n<h2 id=\"防火墙类型\"><a class=\"anchor\" href=\"#防火墙类型\">#</a> 防火墙类型</h2>\n<h3 id=\"包过滤防火墙\"><a class=\"anchor\" href=\"#包过滤防火墙\">#</a> 包过滤防火墙</h3>\n<p>在 Linux 系统下，包过滤功能是内建于核心的 (作为一个核心模块，或者直接内建) , 同时还有一些可以运用于数据包之上的技巧，不过最常用的依然是查看包头以决定包的命运。包过滤防火墙将对每一个接收到的包做出允许或拒绝的决定。具体地讲，它针对每一个数据包的包头，按照包过滤规则进行判定，与规则相匹配的包依据路由信息继续转发，否则就丢弃。包过滤是在 IP 层实现的，包过滤根据数据包的源 P 地址、目的 IP 地址、协议类型 (TCP 包 UDP 包、ICMP 包)、源端口、目的端口等包头信息及数据包传输方向等信息来判断是否允许数据包通过。 包过滤也包括与服务相关的过滤，这是指基于特定的服务进行包过滤，由于绝大多数服务的监听都驻留在特定 TCP/UDP 端口，因此，为阻断所有进入特定服务的链接，防火墙只需将所有包含特定 TCP/UDP 目的端口的包丢弃即可</p>\n<h3 id=\"状态检测防火墙\"><a class=\"anchor\" href=\"#状态检测防火墙\">#</a> 状态检测防火墙</h3>\n<p>状态检测防火墙在网络层有一个检查引擎截获数据包并抽取出与应用层状态有关的信息，并以此为依据决定对该连接是接受还是拒绝。这种技术提供了高度安全的解决方案，同时具有较好的适应性和扩展性。状态检测防火墙基本保持了简单包过滤防火墙的优点，性能比较好，同时对应用是透明的，在此基础上，对于安全性有了大幅提升。这种防火墙摒弃了简单包过滤防火墙仅仅考察进出网络的数据包，不关心数据包状态的缺点，在防火墙的核心部分建立状态连接表，维护了连接，将进出网络的数据当成一个个的事件来处理。可以这样说，状态检测包过滤防火墙规范了网络层和传输层行为，而应用代理型防火墙则是规范了特定的应用协议上的行为。</p>\n<h2 id=\"iptables介绍\"><a class=\"anchor\" href=\"#iptables介绍\">#</a> iptables 介绍</h2>\n<p>netfilter/iptables (简称为 iptables) 组成 Linux 平台下的包过滤防火墙，与大多数的 Linux 软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换 (NAT) 等功能。</p>\n<p>其实 iptables 服务不是真正的防火墙，只是用来定义防火墙规则功能的 &quot;防火墙管理工具&quot;, 将定义好的规则交由内核中的 netfilter 即网络过滤器来读取，从而真正实现防火墙功能。</p>\n<h2 id=\"iptables基本信息\"><a class=\"anchor\" href=\"#iptables基本信息\">#</a> iptables 基本信息</h2>\n<p>规则 (rules) 其实就是网络管理员预定义的条件，规则一般的定义为 &quot;如果数据包头符合这样的条件，就这样处理这个数据包&quot;</p>\n<p>规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议 (如 TCP, UDP,ICMP) 和服务类型 (如 HTTP, FTP 和 SMTP) 等。</p>\n<p>当数据包与规则匹配时，iptables 就根据规则所定义的方法来处理这些数据包，如放行 (accept) 、拒绝 (reject) 和丢弃 (drop) 等。</p>\n<p>配置防火墙的主要工作就是添加、修改和删除这些规则。</p>\n<h2 id=\"表与链介绍\"><a class=\"anchor\" href=\"#表与链介绍\">#</a> 表与链介绍</h2>\n<ul>\n<li>\n<p>表 (tables) 提供特定的功能，iptables 内置了 4 个表，即 filter 表、nat 表、mangle 表和 raw 表，分别用于实现包过滤，网络地址转换、包重构 (修改) 和数据跟踪处理，这些表具有一定的优先级: raw--&gt;mangle--&gt;nat--&gt;filter</p>\n</li>\n<li>\n<p>链 (chains) 是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。</p>\n</li>\n</ul>\n<h2 id=\"规则链\"><a class=\"anchor\" href=\"#规则链\">#</a> 规则链</h2>\n<h3 id=\"一些需要知道的规则链\"><a class=\"anchor\" href=\"#一些需要知道的规则链\">#</a> 一些需要知道的规则链</h3>\n<ol>\n<li>INPUT - 进来的数据包应用此规则链中的策略</li>\n<li>OUTPUT - 外出的数据包应用此规则链中的策略</li>\n<li>FORWARD - 转发数据包时应用此规则链中的策略</li>\n<li>PREROUTING - 对数据包作路由选择前应用此链中的规则 (记住！所有的数据包进来的时候都先由这个链处理)</li>\n<li>POSTROUTING - 对数据包作路由选择后应用此链中的规则 (所有的数据包出来的时候都先由这个链处理)</li>\n</ol>\n<p><span class=\"label\">完整的规则链</span></p>\n<p><img data-src=\"image005.png\" alt=\"\" /></p>\n<p>规则表的先后顺序:<br />\nraw-&gt;mangle-&gt;nat-&gt;filter</p>\n<p>规则链的先后顺序:<br />\n 入站顺序 PREROUTING-&gt;INPUT<br />\n 出站顺序：OUTPUT-&gt;POSTROUTING<br />\n 转发顺序：PREROUTING-&gt;FORWARD-&gt;POSTROUTING</p>\n<h2 id=\"iptables传输数据包的过程\"><a class=\"anchor\" href=\"#iptables传输数据包的过程\">#</a> iptables 传输数据包的过程</h2>\n<p>当一个数据包进入网卡时，它首先进入 PREROUTING 链，内核根据数据包目的 IP 判断是否需要转送出去。</p>\n<p>如果数据包就是进入本机的，它就会向下移动，到达 INPUT 链。数据包到了 INPUT 链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过 OUTPUT 链，然后到达 POSTROUTING 链输出。</p>\n<p>如果数据包是要转发出去的，且内核允许转发，数据包就会经过 FORWARD 链，然后到达 POSTROUTING 链输出。</p>\n<p><img data-src=\"image006.png\" alt=\"\" /></p>\n<h2 id=\"iptables命令\"><a class=\"anchor\" href=\"#iptables命令\">#</a> iptables 命令</h2>\n<p>iptables 格式:<br />\niptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]</p>\n<p><img data-src=\"image007.png\" alt=\"\" /></p>\n<p>详细解释见<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdmF0aGUvcC82OTczNjU2Lmh0bWw=\"> https://www.cnblogs.com/vathe/p/6973656.html</span><br />\n 有人总结的挺全的就不造轮子了（懒）。</p>\n<h2 id=\"iptables常识与常用命令\"><a class=\"anchor\" href=\"#iptables常识与常用命令\">#</a> iptables 常识与常用命令</h2>\n<p>CentOS7 默认的防火墙不是 iptables, 而是 firewalle.<br />\n 如果你没有安装 iptables 的话，你可以使用以下命令进行安装<br />\n systemctl stop firewalld<br />\nsystemctl disable firewalld<br />\nsystemctl mask firewalld<br />\n 上面的意思是先屏蔽掉原有的 firewall 防火墙，下面我们就开始安装 iptables，至于为什么要安装 IPtables 我就不讲了<br />\n yum install iptables iptables-services -y</p>\n<p>设置规则<br />\n #查看 iptables 现有规则<br />\n iptables -L -n<br />\n# 先允许所有，不然有可能会杯具<br />\n iptables -P INPUT ACCEPT<br />\n# 清空所有默认规则<br />\n iptables -F<br />\n# 清空所有自定义规则<br />\n iptables -X<br />\n# 所有计数器归 0<br />\niptables -Z<br />\n# 允许来自于 lo 接口的数据包 (本地访问)<br />\niptables -A INPUT -i lo -j ACCEPT<br />\n# 开放 22 端口<br />\n iptables -A INPUT -p tcp --dport 22 -j ACCEPT<br />\n# 开放 21 端口 (FTP)<br />\niptables -A INPUT -p tcp --dport 21 -j ACCEPT<br />\n# 开放 80 端口 (HTTP)<br />\niptables -A INPUT -p tcp --dport 80 -j ACCEPT<br />\n# 开放 443 端口 (HTTPS)<br />\niptables -A INPUT -p tcp --dport 443 -j ACCEPT<br />\n# 允许 ping<br />\niptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT<br />\n# 允许接受本机请求之后的返回数据 RELATED, 是为 FTP 设置的<br />\n iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT<br />\n# 其他入站一律丢弃<br />\n iptables -P INPUT DROP<br />\n# 所有出站一律绿灯<br />\n iptables -P OUTPUT ACCEPT<br />\n# 所有转发一律丢弃<br />\n iptables -P FORWARD DROP</p>\n<p>其他规则设定<br />\n #如果要添加内网 ip 信任（接受其所有 TCP 请求）<br />\niptables -A INPUT -p tcp -s 45.96.174.68 -j ACCEPT<br />\n# 过滤所有非以上规则的请求<br />\n iptables -P INPUT DROP<br />\n# 要封停一个 IP，使用下面这条命令：<br />\niptables -I INPUT -s ... -j DROP<br />\n# 要解封一个 IP，使用下面这条命令:<br />\niptables -D INPUT -s ... -j DROP</p>\n<p>#保存上述规则<br />\n service iptables save<br />\n 开启 iptables 服务<br />\n #注册 iptables 服务<br />\n #相当于以前的 chkconfig iptables on<br />\nsystemctl enable iptables.service<br />\n# 开启服务<br />\n systemctl start iptables.service<br />\n# 查看状态<br />\n systemctl status iptables.service</p>\n<h1 id=\"linux进程\"><a class=\"anchor\" href=\"#linux进程\">#</a> Linux 进程</h1>\n<p>推荐一篇博客，《<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTg0NTEtMS5odG1s\">关于 Linux 进程你所需要知道的一起</span>》</p>\n<h2 id=\"top命令实时的查看进程的状态\"><a class=\"anchor\" href=\"#top命令实时的查看进程的状态\">#</a> top 命令：实时的查看进程的状态</h2>\n<p>top 是一个前台程序，所以是可以交互的</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">常用交互命令</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">q</td>\n<td style=\"text-align:left\">退出程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">l</td>\n<td style=\"text-align:left\">切换显示平均负载和启动时间的信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">P</td>\n<td style=\"text-align:left\">根据 CPU 使用百分比大小进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">M</td>\n<td style=\"text-align:left\">根据驻留内存大小进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i</td>\n<td style=\"text-align:left\">忽略闲置和僵死的进程，这是一个开关式命令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">k</td>\n<td style=\"text-align:left\">终止一个进程，系统提示输入 PID 及发送的信号值。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ps命令\"><a class=\"anchor\" href=\"#ps命令\">#</a> ps 命令</h2>\n<p>ps -ef 显示所有进程的详细信息</p>\n<p><img data-src=\"image008.png\" alt=\"\" /></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">UID</th>\n<th style=\"text-align:left\">PID</th>\n<th style=\"text-align:left\">PPID</th>\n<th style=\"text-align:left\">C</th>\n<th style=\"text-align:left\">STIME</th>\n<th style=\"text-align:left\">TTY</th>\n<th style=\"text-align:left\">CMD</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">用户 ID</td>\n<td style=\"text-align:left\">进程的 ID</td>\n<td style=\"text-align:left\">父进程 ID</td>\n<td style=\"text-align:left\">进程占用 CPU 的百分比</td>\n<td style=\"text-align:left\">进程启动的时间</td>\n<td style=\"text-align:left\">该进程在那个终端上运行。若与终端无关，则显示？若为 pts/0 等，则表示由网络连和参数接主机进程。</td>\n<td style=\"text-align:left\">命令的名称和参数</td>\n</tr>\n</tbody>\n</table>\n<p>ps -aux 显示所有进程信息</p>\n<p><img data-src=\"image009.png\" alt=\"\" /><br />\n<img data-src=\"image010.png\" alt=\"\" /></p>\n<p>ps -A 显示所有的进程信息<br />\n ps -u root 显示指定用户的进程信息<br />\n ps -l 显示目前属于本次登陆得 PID 相关信息</p>\n<p><code>ps -ef|grep sshd|grep -v &quot;grep&quot;</code>  配合管道符与 grep，显示 sshd 的进程信息。</p>\n<h2 id=\"kill-命令\"><a class=\"anchor\" href=\"#kill-命令\">#</a> kill 命令</h2>\n<p>kill 命令：用于删除执行的程序或工作，通过向进程发送指定的信号来结束进程。</p>\n<p>用法：kill  [信号] PID</p>\n<p>常用信号：<br />\n2  结束进程，不是强制性的，&quot;Ctrl + C&quot; 发出的就是 kill -2 信号<br />\n 3  退出<br />\n 9  杀死进程，强制结束进程。</p>\n<h1 id=\"端口\"><a class=\"anchor\" href=\"#端口\">#</a> 端口</h1>\n<p>在 Linux 操作系统下，系统共定义了 65536 个可用的端口。<br />\n对于 0-1023 端口，都需要 root 身份才能启用，这些端口主要用于系统一些常见的通信服务中。比如: 21 ftp 服务、22 ssh 服务、80 http 服务等...<br />\n 端口的开启和关闭也就是软件服务的启动和关闭</p>\n<h2 id=\"chkconfig命令\"><a class=\"anchor\" href=\"#chkconfig命令\">#</a> chkconfig 命令</h2>\n<p>chkconfig 来判断服务是开启还是关闭状态<br />\n例如 chkconfig --list sshd</p>\n<h2 id=\"netstat命令\"><a class=\"anchor\" href=\"#netstat命令\">#</a> netstat 命令</h2>\n<p>netstat 命令：用于显示 tcp, udp 的端口和进程情况<br />\n用法:<br />\nnetstat [选项]<br />\n-a 显示所有<br />\n - t 仅显示 tcp 相关选项<br />\n - u 仅显示 udp 相关选项<br />\n - n 拒绝显示别名，能显示数字的全部转化为数字<br />\n - l 仅列出在 Listen (监听) 的服务状态<br />\n - p 显示建立相关链接的程序名</p>\n<p>常用命令:<br />\nnetstat-antlp // 查看当前所有 tcp 端口<br />\n netstat-antulp|grep 80 // 查看所有 80 端口使用情况</p>\n<h1 id=\"linux计划任务\"><a class=\"anchor\" href=\"#linux计划任务\">#</a> linux 计划任务</h1>\n<p>计划任务，就是在约定好的时间执行已经计划好的工作。<br />\n未来的某时间点执行一次某任务或者周期性的运行某个任务，执行结果会通过邮形式发送给用户。</p>\n<h2 id=\"安全与计划任务\"><a class=\"anchor\" href=\"#安全与计划任务\">#</a> 安全与计划任务</h2>\n<p>挖矿病毒：<br />\n使用 top 查看 CPU，显示进程占 cpu99% 以上。杀掉进程后，到了晚上还是会自动运行进程。<br />\n检测定时任务，发现有一个异常的定时任务</p>\n<h2 id=\"at命令\"><a class=\"anchor\" href=\"#at命令\">#</a> at 命令</h2>\n<p>at 命令 一次性计划任务<br />\n默认自带 at<br />\n <code>yum install at -y</code>     下载 at</p>\n<p>开启服务:<br />\nservice atd start</p>\n<p>用法:<br />\nat (选项)<br />\n 选项<br />\n - f: 指定包含具体指令的任务文件；<br />\n-q: 指定新任务的队列名称；<br />\n-l: 显示待执行任务的列表；<br />\n-d: 删除指定的待执行任务；<br />\n-m: 任务执行完成后向用户发送 E-mail;</p>\n<p><span class=\"label\">实例</span></p>\n<p>at 10:00    确切时间<br />\n at now +10 minutes  十分钟后执行<br />\n at 17:04 04/04/2018  2018483817:04 执行<br />\n at 17:04 04/04/2018  2018483817:04 执行</p>\n<p>at 1am tomorrow 明天上午一点运行作业<br />\n at-c id    根据作业 ID 查看执行细节<br />\n atq        查看待处理的任务<br />\n atrm id    删除 id 的任务</p>\n<h2 id=\"crondtab命令\"><a class=\"anchor\" href=\"#crondtab命令\">#</a> crondtab 命令</h2>\n<p>crondtab 命令 周期性计划任务</p>\n<p>crond 是 linux 下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。</p>\n<p>Linux 系统上系统服务是默认启动的，使用者控制计划任务命令:crontab 命令。</p>\n<p>crontab 其实是一个命令，用来读取和修改名为 crontab 的文件。/etc/crontab 文件包含了要定时执行的程序列表。</p>\n<p>安装 crontab: 默认自带<br />\n <code>yum install crontabs</code></p>\n<p>服务命令:</p>\n<p>service crond start // 启动服务 service crond stop // 关闭服务 service crond restart// 重启服务 service crond reload // 重新载入配置</p>\n<p>crontab 命令 周期性计划任务</p>\n<p>1、命令格式:</p>\n<p>crontab [-u user] file<br />\ncrontab [-u user] 【选项】</p>\n<p>常用选项:</p>\n<p>-e: 编辑计划任务 edit<br />\n-l: 查看计划任务 display<br />\n-u: 指定用户</p>\n<p>常用命令:</p>\n<p>crontab -l 列出当前用户的计划任务<br />\n crontab -r 删除当前用户所有的计划任务<br />\n crontab -e 编辑当前用户的计划任务<br />\n crontab-e -u root 编辑 root 用户的计划任务</p>\n<p>第一列：分钟 (0-59)<br />\n 第二列：小时 (0-23)<br />\n 第三列：天 (1-31)<br />\n 第四列：月 (1-12)<br />\n 第五列：周 (0-6) 0 表示周日</p>\n<p>&quot;<em>&quot; 表示所有的取值，就是</em> / 1&quot;<br />\n&quot;/&quot; 表示每的意思<br />\n */5&quot; 表示每 5 个单位<br />\n &quot;-&quot; 表示从某个数字到某个数字<br />\n &quot;,&quot; 表示分散的数字</p>\n<p><img data-src=\"crontab.png\" alt=\"\" /></p>\n<p><span class=\"label\">实例</span><br />\n<img data-src=\"image011.png\" alt=\"\" /></p>\n<h1 id=\"日志服务\"><a class=\"anchor\" href=\"#日志服务\">#</a> 日志服务</h1>\n<h2 id=\"基础信息\"><a class=\"anchor\" href=\"#基础信息\">#</a> 基础信息</h2>\n<p>在 CentOS 6.x 中，日志服务已经由 rsyslogd 取代了原先的 syslogd.<br />\nrsyslogd 相比 syslogd 具有一些新的特点:<br />\n 基于 TCP 网络协议传输日志信息。<br />\n更安全的网络传输方式。<br />\n有日志信息的即时分析框架。<br />\n后台数据库。<br />\n在配置文件中可以写简单的逻辑判断。<br />\n与 syslog 配置文件相兼容。</p>\n<p>查看 rsyslogd 服务是否启动<br />\n <code>ps aux|grep &quot;rsyslogd&quot;|grep -v &quot;grep&quot;</code> <br />\n 查询 rsyslogd 服务的自启动状态<br />\n <code>chkconfig --list|grep &quot;rsyslog&quot;</code> <br />\n <code>systemctl list-unit-files|grep &quot;rsyslog&quot;</code></p>\n<p>在 Linux 系统中有一部分日志不是由 rsyslogd 服务来管理的，比如 apache 服务，它的日志是由 Apache 软件自己产生并记录的，并没有调用 rsyslogd 服务，但是 apache 日志文件的格式和系统默认日志的格式是一致的。</p>\n<p>在 Linux 系统中有一部分日志不是由 rsyslogd 服务来管理的，比如 apache 服务，它的日志是由 Apache 软件自己产生并记录的，并没有调用 rsyslogd 服务，但是 apache 日志文件的格式和系统默认日志的格式是一致的。</p>\n<p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。这些信息有些非常敏感，所以在 Linux 中这些日志文件只有 root 用户可以读取。<br />\n系统日志文件的保存位置是 /var/log/ 目录</p>\n<p><img data-src=\"image012.png\" alt=\"\" /><br />\n<img data-src=\"image013.png\" alt=\"\" /><br />\n<img data-src=\"image014.png\" alt=\"\" /></p>\n<p>日志服务 rsyslogd 记录的日志文件格式包含以下 4 列:</p>\n<p>1. 事件产生的时间。<br />\n2. 产生事件的服务器的主机名。<br />\n3. 产生事件的服务名或程序名。<br />\n4. 事件的具体信息。</p>\n<p>/var/log/secure 日志文件内容:</p>\n<p><img data-src=\"image015.png\" alt=\"\" /></p>\n<p>/var/log/secure 记录验证和授权方面的倍息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh 的登录、su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</p>\n<p>/var/log/wtmp 永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件</p>\n<p>/var/tun/ulmp 记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。</p>\n<h2 id=\"rsyslogd配置文件\"><a class=\"anchor\" href=\"#rsyslogd配置文件\">#</a> rsyslogd 配置文件</h2>\n<p>rsyslogd 服务的配置文件是 /etc/rsyslog.conf , 其中主要定义了服务的名称、日志等级和日志记录位置。</p>\n<p>该配置文件的基本格式如下所示:</p>\n<p>authpriv.*                  /var/log/secure<br />\n# 服务名称 [连接符号] 日志等级   日志记录位置</p>\n<h2 id=\"日志等级\"><a class=\"anchor\" href=\"#日志等级\">#</a> 日志等级</h2>\n<p><img data-src=\"image016.png\" alt=\"\" /></p>\n<p>详细见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbmJsb2dzLmNvbS9rbGI1NjEvcC8xMjAxNDI2OC5odG1s\"> https://cnblogs.com/klb561/p/12014268.html</span></p>\n<h2 id=\"连接符\"><a class=\"anchor\" href=\"#连接符\">#</a> 连接符</h2>\n<p>连接符号:</p>\n<ol>\n<li>&quot;.&quot; 代表只要比后面的等级高的 (包含该等级) 日志都记录。比如，&quot;<span class=\"exturl\" data-url=\"aHR0cDovL2Nyb24uaW5mbw==\">cron.info</span>&quot; 代表 cron 服务产生的日志，只要日志等级大于等于 info 级别，就记录。</li>\n<li>&quot;.=&quot; 代表只记录所需等级的日志，其他等级的日志都不记录。比如，&quot;*.=emerg&quot; 代表人和日志服务产生的日志，只要等级是 emerg 等级，就记录。这种用法极少见，了解就好。</li>\n<li>&quot;.!&quot; 代表不等于，也就是除该等级的日志外，其他等级的日志都记录。</li>\n</ol>\n<h2 id=\"日志记录位置\"><a class=\"anchor\" href=\"#日志记录位置\">#</a> 日志记录位置</h2>\n<p>日志记录位置：当前日志输出到哪个日志文件中保存</p>\n<p>日志文件的绝对路径。例如: &quot;/ar/log/secure&quot;</p>\n<p>系统设备文件。如 &quot;/dev/lpo&quot; 代表第一台打印机，如果日志保存位置是打印机设备，当有日志时就会在打印机上打印。</p>\n<p>用户名。如果是 &quot;root&quot; , 把日志发送给 root 用户 (用户要在线) &quot;*&quot; 代表发送给所有在线用户，如 &quot;mail**&quot; 就会把 mail 服务产生的所有级别的日志发送给所有在线用户。发给多个在线用户，则用户名之间用 &quot;,&quot; 分隔。</p>\n<p>忽略或丢弃日志。如果接收日志的对象是 &quot;~&quot; , 则代表这个日志不会被记录，而被直接丢弃。如 &quot;local3.*~&quot; 代表忽略 local3 服务类型所有的日志都不记录。</p>\n<h2 id=\"日志管理\"><a class=\"anchor\" href=\"#日志管理\">#</a> 日志管理</h2>\n<p>日志管理:</p>\n<p>日志维护的最主要的工作就是把旧的日志文件删除，从而腾出空间保存新的日志文件。</p>\n<p>logrotate 就是用来进行日志轮替的，就是把旧的日志文件移动并改名，同时创建一个新的空日志文件用来记录新日志，当旧日志文件超出保存的范围时就删除。</p>\n<p>日志文件的命名规则:</p>\n<ol>\n<li>服务加日期</li>\n<li>服务加数字</li>\n</ol>\n<p>查看日志备份文件<br />\n ls /var/log</p>\n<p>logrotate 令可以进行日志转储 (轮替)</p>\n<p>logrotate 命令会依据 /etc/logrotate.conf 配置文件的配置，来判断配置文件中的日志是否符合日志轮替的条件 (比如，日志备份时间已经满一周) , 如果符合，日志就会进行轮替。</p>\n<p>/etc/logrotate.conf 配置文件的<br />\n cat /etc/logrotate.conf<br />\n 详细讲解</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzExMDYuaHRtbA==\">http://c.biancheng.net/view/1106.html</span></p>\n<h1 id=\"系统服务\"><a class=\"anchor\" href=\"#系统服务\">#</a> 系统服务</h1>\n<p>什么是系统服务？<br />\n 服务是在后台运行的应用程序，并且可以提供一些本地系统或网络的功能。<br />\n我们把这些应用程序称作服务，也就是 Service.<br />\nLinux 中常见的服务有那些，这些服务怎么分类，服务如何启动，服务如何自启动，服务如何查看？</p>\n<p>服务 Service, Daemon 这个词也经常伴随着出现。<br />\nDaemon 翻 i 成 &quot;守护进程&quot;<br />\n 守护进程：就是为了实现服务、功能的进程。<br />\n比如，apache 服务就是服务 (Service) , 它是用来实现 Web 服务的。<br />\n那么，启动 apache 服务的进程是哪个进程呢？<br />\nhttpd 这个守护进程 (Daemon) 。<br />\n在 Linux 中就是通过启动 httpd 进程来启动 apache 服务的。<br />\n也就是说，守护进程就是服务在后台运行的真实进程。</p>\n<p><img data-src=\"image017.png\" alt=\"\" /></p>\n<p>Linux 中的服务按照安装方法不同可以分为 RPM 包默认安装的服务和源码包安装的服务两大类。</p>\n<p>区别:</p>\n<p>RPM 包安装到系统默认位置，可以被服务管理命令识别；但是源码包安装到手工指定位置，当然就不能被服务管理命令识别了 (可以手工修改为被服务管理命令识别)。</p>\n<h2 id=\"启动服务\"><a class=\"anchor\" href=\"#启动服务\">#</a> 启动服务</h2>\n<p>启动服务方式:</p>\n<p>1) 使用 /etc/init.d/ 目录中的启动脚本来启动独立的服务</p>\n<p>2) 使用 service 命令来启动独立的服务</p>\n<p>1) 使用 /etc/init.d/ 目录中的启动脚本来启动独立的服务</p>\n<p>所有独立服务的启动脚本都存放在 /etc/init.d/ 目录中，调用脚本就可以启动独立的服务了。</p>\n<p>命令格式如下:</p>\n<p>/etc/init.d/ 独立服务名参数参数:</p>\n<p>start: 启动服务；<br />\nstop: 停止服务；<br />\nstatus: 查看服务状态；<br />\nrestart: 重启动服务；</p>\n<p>2) 使用 service 命令来启动独立的服务</p>\n<p>在 CentOS 系统中，我们还可以依赖 service 命令来启动独立的服务。service 命令实际上只是一个脚本，这个脚本仍然需要调用 /etc/init.d/ 中的启动脚本来启动独立的服务。</p>\n<p>service 命令格式如下:</p>\n<p>service 独立服务名 start|stop|restart|..</p>\n<p><code>service --status-all 查看所有服务</code></p>\n<h2 id=\"服务的自启动\"><a class=\"anchor\" href=\"#服务的自启动\">#</a> 服务的自启动</h2>\n<p>使用 chkconfig 服务自启动管理命令</p>\n<p>格式:</p>\n<p>查看所有服务的自启动状态<br />\n chkconfig -list</p>\n<p>设置某服务的自启动状态</p>\n<p>chkconfig [--level 运行级别][独立服务名][on|off]</p>\n<p><img data-src=\"image018.png\" alt=\"\" /></p>\n<p>想把某个已经安装了的服务添加为系统服务，可以执行以下命令：</p>\n<p><code>chkconfig --add 服务名称</code>           (首先，添加为系统服务，注意 add 前面有两个横杠)</p>\n<p><code>chkconfig -leve 启动级别 服务名 on</code></p>\n<h1 id=\"下载与安装\"><a class=\"anchor\" href=\"#下载与安装\">#</a> 下载与安装</h1>\n<h2 id=\"wget\"><a class=\"anchor\" href=\"#wget\">#</a> wget</h2>\n<p>wget 是一个下载文件的工具，它用在命令行下</p>\n<p>语法：wget [选项] url</p>\n<p>选项：</p>\n<p>-V 显示 wget 版本信息并退出。<br />\n-h 打印此帮助<br />\n - O 指定下载文件的别名。</p>\n<p><img data-src=\"image019.png\" alt=\"\" /></p>\n<h2 id=\"rpm\"><a class=\"anchor\" href=\"#rpm\">#</a> rpm</h2>\n<p>Linux rpm 命令用于管理套件，增强了程序安装卸载的管理。</p>\n<p>RPM 的功能：打包、安装、查询、升级、卸载...</p>\n<p>缺点: RPM 无法解决软件包的依赖关系</p>\n<p>RPM 包的命名规范: name-version-release.os.arch.rpm</p>\n<p><img data-src=\"image020.png\" alt=\"\" /></p>\n<p>!{}(image021.png)</p>\n<h2 id=\"yum\"><a class=\"anchor\" href=\"#yum\">#</a> yum</h2>\n<p>yum 基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包和安装</p>\n<p>优点：可以自动处理关联关系，并且一次安装所有依赖的软件包，无须繁琐地一次下载，安装。</p>\n<p>语法 ：<br />\nyum [选项] [包……]</p>\n<p>选项：<br />\n-h 帮助<br />\n - y 当安装过程中提示选择全部为 “yes”<br />\n-q 不显示安装过程</p>\n<p>检测有没有安装 yum<br />\nyum -h<br />\nrpm -qa | grep yum</p>\n<ol>\n<li><span class=\"label info\">相关命令</span></li>\n</ol>\n<p>1・列出所有可更新的软件清单命令: yum check-update<br />\n2 更新所有软件命令: yum update<br />\n3 仅安装指定的软件命令: yum install 包名称<br />\n 4 仅更新指定的软件命令: yum update 包名称<br />\n 5 列出所有可安装的软件清单命令: yum list<br />\n6 删除删除命令: yum remove 包名称<br />\n 7 清除缓存命令:<br />\n 清除缓存目录 (/var/cache/yum) 下的软件包<br />\n命令：yum clean packages</p>\n<p>清除缓存目录 (/var/cache/yum) 下的 headers<br />\n 命令：yum clean headers</p>\n<p>清除缓存目录 (/var/cache/yum) 下旧的 headers<br />\n 命令：yum clean oldheaders</p>\n<p>清除缓存目录 (/var/cache/yum) 下的软件包及旧的 headers<br />\n 命令：yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</p>\n<ol start=\"2\">\n<li><span class=\"label info\">yum list 相关命令</span></li>\n</ol>\n<p><img data-src=\"iamge022.png\" alt=\"\" /></p>\n<ol start=\"3\">\n<li>安装应用程序</li>\n</ol>\n<p>语法: yum [-y] install 包 1 包 2…… 包 n<br />\nyum install wget    使用安装 wget</p>\n<p>升级软件包</p>\n<p>命令格式: yum update 包 1 包 2…… 包 n<br />\nyum check-update 检测可升级的包</p>\n<p>卸载软件包</p>\n<p>命令格式: yum remove 包 1 包 2…… 包 n<br />\n 注意：卸载时注意依赖关系</p>\n<h1 id=\"文件打包和解压缩\"><a class=\"anchor\" href=\"#文件打包和解压缩\">#</a> 文件打包和解压缩</h1>\n<p>linux 中常用的五种压缩格式: .zip .gz .tar.gz .bz2 .tar.bz2</p>\n<p>打包和压缩:</p>\n<p>打包是指将一大堆文件或目录什么的变成一个总的文件<br />\n压缩则是将一个大的文件通过一些压缩算法变成一个小文件</p>\n<h2 id=\"tar命令\"><a class=\"anchor\" href=\"#tar命令\">#</a> tar 命令</h2>\n<p>Linux 中的很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你就得先借助另它的工具将这一大堆文件先打成一个包，然后再就原来的压缩程序进行压缩。</p>\n<p>Liunx 下最常用的打包命令是 tar, 使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命通常都是以.tar 结尾的。<br />\n生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法</p>\n<p>语法:<br />\ntar 【选项】 打包文件包 源文件<br />\n选项:<br />\n-c: 打包<br />\n - v: 显示详细过程<br />\n - x: 解打包 / 压缩<br />\n - z: 通过 gzip 压缩 / 解压文件<br />\n - j: 通过 bz2 压缩 / 解压文件<br />\n - C: 解压到指定目录<br />\n - f filename: 指定打包后的文件名 (必选，这个参数是最后一个参数，后面只能接文件名)</p>\n<p>常用命令:<br />\ntar -cf all.tar *.jpg  #将所有.jpg 的文件打成一个名为 all.tar 的包<br />\n tar -xvf all.tar  #解出 all.tar 包中所有文件，-x 是解开的意思</p>\n<p>为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能 -- 就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip.bzip2 等。</p>\n<h2 id=\"解压缩与压缩\"><a class=\"anchor\" href=\"#解压缩与压缩\">#</a> <span class=\"label info\">解压缩与压缩</span></h2>\n<p><img data-src=\"image022.png\" alt=\"\" /></p>\n<h2 id=\"zip\"><a class=\"anchor\" href=\"#zip\">#</a> zip</h2>\n<p>zip 【选项】 【压缩文件】</p>\n<p>选项:<br />\n-m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。<br />\n-q 不显示指令执行过程。<br />\n-r 递归处理，将指定目录下的所有文件和子目录一并处理。<br />\n-v 显示指令执行过程或显示版本信息。</p>\n<p>实例</p>\n<p>将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip:</p>\n<p>zip-qr html.zip /home/html</p>\n<h2 id=\"unzip\"><a class=\"anchor\" href=\"#unzip\">#</a> unzip</h2>\n<p>unzip 【选项】 【压缩文件】</p>\n<p>选项:</p>\n<p>-l 显示压缩文件内所包含的文件 - V 执行是时显示详细的信息。<br />\n-q 执行时不显示任何信息。<br />\n-d &lt;目录&gt; 指定文件解压缩后所要存储的目录。</p>\n<p>实例</p>\n<p>解压文件<br />\n <code>unzip abc.zip</code></p>\n<p>查看压缩文件中包含的文件:<br />\n <code>unzip-l abc.zip</code></p>\n<h2 id=\"gzip\"><a class=\"anchor\" href=\"#gzip\">#</a> gzip</h2>\n<ol>\n<li>tar 调用 gzipgzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip.<br />\ntar 中使用 - z 这个参数来调用 gzip 常用命令:</li>\n</ol>\n<p><code>tar-czf all.tar.gz *.jpg</code>   #将所有.jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包 all.tar.gz</p>\n<p><code>tar-xzf all.tar.gz</code>   #将包 all.tar.z 解开</p>\n<ol start=\"2\">\n<li>tar 调用 bzip2bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。与 bzip2 相对的解压程序是 bunzip</li>\n</ol>\n<p>tar 中使用 - j 这个参数来调用 bzip2</p>\n<p>常用命令:</p>\n<p>tar -cjfall.tar.bz2 *.jpg #将所有.jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，包名为 all.tar.bz2</p>\n<p>tar -xjf all.tar.bz2  #将上面产生的包解开</p>\n",
            "tags": [
                "Linux",
                "Linux"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/02/07/%E5%88%9D%E8%AF%86python%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/",
            "url": "https://self-ferry.github.io/2021/02/07/%E5%88%9D%E8%AF%86python%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/",
            "title": "初识python测试驱动开发",
            "date_published": "2021-02-07T12:20:18.000Z",
            "content_html": "<p><span class=\"label success\">✔️Music！</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=1384407086\"]}]'></div></div>\n<h1 id=\"导读\"><a class=\"anchor\" href=\"#导读\">#</a> 导读</h1>\n<p>本章主要介绍敏捷开发模式。敏捷开发是 20 世纪 90 年代兴起的一种新型软件开发方法，能快速应对需求的变化。他需要分析人员与程序开发人员紧密协作，采用面对面的有效沟通方式频繁交付新的软件版本。测试驱动是敏捷开发的重要组成部分，python 是敏捷开发项目常采用的一种语言。本章重点介绍测试驱动开发的特点、步骤和环境建立，以及 Python 单元测试，doctest 和 Epydoc 的使用。</p>\n<h1 id=\"正文\"><a class=\"anchor\" href=\"#正文\">#</a> 正文</h1>\n<h2 id=\"测试驱动开发\"><a class=\"anchor\" href=\"#测试驱动开发\">#</a> 测试驱动开发</h2>\n<p>测试驱动开发 (Test-Driven-Development)，简称 TDD，是一种有别于传统开发的新型开发方法。它要求在编写某个功能的代码之前先编写测试代码，让后编写是测试通过的代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，以便加速开发进程。</p>\n<h3 id=\"测试驱动开发模式tdd\"><a class=\"anchor\" href=\"#测试驱动开发模式tdd\">#</a> 测试驱动开发模式 (TDD)</h3>\n<p>当下科技高速发展，软件规模越来越大，软件开发人员也越来越多，因此软件开发过程必须要有知道开发的软件模式。一些小项目也许可以采用边做边改的开发模式，项目一旦做大，这样的开发模式就不能满足需求了。</p>\n<p>瀑布模型作为传统的开发模式，曾一度受到追捧，它将软件生命周期划外为制定计划，需求分析、软件设计、程序开发、软件测试和运行维护六个阶段，这六个阶段的各项活动严格按照线性方式进行，每一个阶段的工作成果都需要进行验证，验证通过才能进入下一阶段，否则返回修改。</p>\n<p>传统的开发模型除了瀑布模型外，还有造代模型、快速原型模型、增量模型、螺旋模型，但这些模型都有自身的缺点，如何适应瞬息万变的需求变化，如何高效地实施软件开发，是每个软件行业人员必须思考的问题。</p>\n<p>敏捷开发在这样的环境下应运而生，它是一种以人为核心、迭代、循序渐进的开发方法，开发过程中，软件项目的构建被切分成多个子项目，各个子项目既相对独立又相互联系，可以分别完成，开发过程中软件一直处于可使用状态。</p>\n<p>测试驱动开发模式 TDD 是敏捷开发的重要组成部分，也是一种设计方法论，其基本思想就是在开发某个功能代码前，先编写测试代码，然后编写功能代码并用测试代码进行验证，如此循环直到完成全部功能的开发。</p>\n<p>测试模型中的 V 模型和 X 模型都是 TDD 的最好体现方式，V 模型如图所示：</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>V 模型在开发的各个阶段，包括需求分析、概要设计、详细设计、编码过程中都考虑相对应的测试工作，完成相关的测试用例设计和测试脚本编写。</p>\n<p>X 模型是对详细阶段和编码阶段进行建模，针对某个功能进行对应的测试驱动开发。X 模型的左侧描述的是针对单独程序片段所进行的相互分离的编码和测试，此后进行频繁的集成，通过集成最终成为可执行的程序，然后再对这些可执行程序进行测试. X 模型还定位了探索性测试，这是不进行事先计划的特殊类型的测试，这一方式往往能帮助有经验的测试人员在测试计划之外发现更多的软件错误。</p>\n<p>X 模型如图所示</p>\n<p><img data-src=\"image002.png\" alt=\"\" /></p>\n<p>TDD 的优点：节省了调试程序及挑错的时间，在任意一个开发节点都可以拿出一个可以使用含少量 bug 并具有一定功能和能够发布的产品。<br />\nTDD 的缺点：增加代码量，测试代码是系统代码的两倍或更多倍。</p>\n<h3 id=\"tdd使用步骤\"><a class=\"anchor\" href=\"#tdd使用步骤\">#</a> TDD 使用步骤</h3>\n<p>TDD 在满足软件开发目标的同时，也要实现代码的简单整洁。<br />\n在明确软件需求后，对一个新功能的开发过程包括以下步骤，如图 4-3 所示。<br />\n步骤 01: 明确当前代码要完成的功能。可以记录成一个列表，必要时需写相关接口。<br />\n步骤 02: 快速新增对要完成功能的测试。<br />\n步骤 03 : 运行测试，判断测试代码是否通过，通过则执行步骤 06, 不通过则执行步骤 04。<br />\n步骤 04: 编写对应的功能代码。<br />\n步骤 05 : 重新运行测试，保证全部通过。<br />\n步骤 06: 对代码进行重构，优化代码结构。<br />\n步骤 07: 循环完成所有功能的开发。</p>\n<p><img data-src=\"image003.png\" alt=\"\" /></p>\n<h3 id=\"tips\"><a class=\"anchor\" href=\"#tips\">#</a> Tips</h3>\n<p>要完成一个系统，代码的功能点可能很多，需求也可能随时变化，任何阶段想添加功能，都应吧相关的功能点加到测试列表中，避免疏漏。</p>\n<h2 id=\"unittest测试框架\"><a class=\"anchor\" href=\"#unittest测试框架\">#</a> unittest 测试框架</h2>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veW91bGl4aXNoaS9hcnRpY2xlcy8zNTUxOTkyLmh0bWw=\">https://www.cnblogs.com/youlixishi/articles/3551992.html</span><br />\n《python 网络编程从入门到精通》</p>\n",
            "tags": []
        },
        {
            "id": "https://self-ferry.github.io/2021/02/07/python%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/",
            "url": "https://self-ferry.github.io/2021/02/07/python%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/",
            "title": "python数据库编程",
            "date_published": "2021-02-07T08:36:30.000Z",
            "content_html": "<p><span class=\"label success\">✔️来首音乐吧</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=464863017\"]}]'></div></div>\n<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>在看《python 网络编程从入门到精通》，顺便做个笔记。</p>\n<h1 id=\"正文\"><a class=\"anchor\" href=\"#正文\">#</a> 正文</h1>\n<p><ins>本章以 MySQL 为例说明</ins></p>\n<p>python 操作数据库主要涉及 connection 和 cursor 两个对象，操作流程图如下：</p>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<h2 id=\"connection对象\"><a class=\"anchor\" href=\"#connection对象\">#</a> connection 对象</h2>\n<p>connection 对象，与数据源唯一的会话，可以使用 connection 对象的集合、方法、属性实现与数据的连接。</p>\n<p><span class=\"label\">connection 参数列表</span></p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:left\">参数名</td>\n<td style=\"text-align:left\">类型</td>\n<td style=\"text-align:left\">说明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">host</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">连接数据库服务器主机名，默认为本地主机 (localhost)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">port</td>\n<td style=\"text-align:left\">数字</td>\n<td style=\"text-align:left\">MySQL 服务器端口号，默认是 3306</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">user</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">连接数据库的用户名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">password</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">连接数据库的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">db</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">数据库名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">charset</td>\n<td style=\"text-align:left\">字符串</td>\n<td style=\"text-align:left\">连接编码</td>\n</tr>\n</tbody>\n</table>\n<p><span class=\"label\">connection 方法列表</span></p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:left\">方法名</td>\n<td style=\"text-align:left\">说明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">cursor()</td>\n<td style=\"text-align:left\">使用该连接创建并返回游标</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">commit()</td>\n<td style=\"text-align:left\">提交当前事务</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rollback()</td>\n<td style=\"text-align:left\">回滚当前事务</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">close()</td>\n<td style=\"text-align:left\">关闭连接</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"cursor对象\"><a class=\"anchor\" href=\"#cursor对象\">#</a> cursor 对象</h2>\n<p>cursor 对象是游标对象，用户可以用它查询和获取结果。</p>\n<p><span class=\"label\">cursor 对象方法列表</span></p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align:left\">方法名</td>\n<td style=\"text-align:left\">说明</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">execute</td>\n<td style=\"text-align:left\">执行一个数据库命令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fecthone</td>\n<td style=\"text-align:left\">取结果集下一行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fechmany(size)</td>\n<td style=\"text-align:left\">取结果集下几行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fechall()</td>\n<td style=\"text-align:left\">取结果集中剩余的所有行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rowcount</td>\n<td style=\"text-align:left\">最近一次 execute 返回数据的行数或影响行数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">close()</td>\n<td style=\"text-align:left\">关闭游标对象</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"一个例子\"><a class=\"anchor\" href=\"#一个例子\">#</a> 一个例子</h2>\n<p>搬一个菜鸟教程里<ins>插入操作</ins>的例子。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#!/usr/bin/python</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># -*- coding: UTF-8 -*-</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> MySQLdb</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># 打开数据库连接</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>db <span class=\"token operator\">=</span> MySQLdb<span class=\"token punctuation\">.</span>connect<span class=\"token punctuation\">(</span><span class=\"token string\">\"localhost\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"testuser\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"test123\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"TESTDB\"</span><span class=\"token punctuation\">,</span> charset<span class=\"token operator\">=</span><span class=\"token string\">'utf8'</span> <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># 使用 cursor () 方法获取操作游标 </span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>cursor <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span>cursor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># SQL 插入语句</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>sql <span class=\"token operator\">=</span> \"INSERT INTO EMPLOYEE<span class=\"token punctuation\">(</span>FIRST_NAME<span class=\"token punctuation\">,</span> \\</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>       LAST_NAME<span class=\"token punctuation\">,</span> AGE<span class=\"token punctuation\">,</span> SEX<span class=\"token punctuation\">,</span> INCOME<span class=\"token punctuation\">)</span> \\</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>       VALUES <span class=\"token punctuation\">(</span><span class=\"token operator\">%</span>s<span class=\"token punctuation\">,</span> <span class=\"token operator\">%</span>s<span class=\"token punctuation\">,</span> <span class=\"token operator\">%</span>s<span class=\"token punctuation\">,</span> <span class=\"token operator\">%</span>s<span class=\"token punctuation\">,</span> <span class=\"token operator\">%</span>s <span class=\"token punctuation\">)</span>\" <span class=\"token operator\">%</span> \\</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>       <span class=\"token punctuation\">(</span><span class=\"token string\">'Mac'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Mohan'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'M'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>   <span class=\"token comment\"># 执行 sql 语句</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>   cursor<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span>sql<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>   <span class=\"token comment\"># 提交到数据库执行</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>   db<span class=\"token punctuation\">.</span>commit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">except</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>   <span class=\"token comment\"># 发生错误时回滚</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>   db<span class=\"token punctuation\">.</span>rollback<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token comment\"># 关闭数据库连接</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>db<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure>",
            "tags": [
                "python",
                "数据库编程"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/02/05/python%E6%A8%A1%E5%9D%97%E7%9A%84%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7/",
            "url": "https://self-ferry.github.io/2021/02/05/python%E6%A8%A1%E5%9D%97%E7%9A%84%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7/",
            "title": "python模块的内置属性",
            "date_published": "2021-02-05T12:59:31.000Z",
            "content_html": "<p><span class=\"label success\">✔️嘘，请安静</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=532950140\"]}]'></div></div>\n<h1 id=\"模块的内置属性\"><a class=\"anchor\" href=\"#模块的内置属性\">#</a> 模块的内置属性</h1>\n<p>对于任何一个 python 文件来说，当 python 解释器运行一个 py 文件，会自动将一些内容加载到内置的属性中；一个模块我们可以看做是一个比类更大的对象。</p>\n<h2 id=\"查看内置属性\"><a class=\"anchor\" href=\"#查看内置属性\">#</a> 查看内置属性</h2>\n<p>我们可以通过 dir () 方法获取该模块所有的显式或隐式属性。<br />\n附上 dir () 的介绍：<br />\n<img data-src=\"image001.png\" alt=\"\" /></p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># -*- coding:utf-8 -*-</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token triple-quoted-string string\">'''</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>doc......</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>'''</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">import</span> os</pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>var <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">\"__main__\"</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">dir</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">####### 输出结果 #######</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token string\">'Test'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__annotations__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__builtins__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__cached__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__doc__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__file__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__loader__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__name__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__package__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'__spec__'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'os'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'var'</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><div class=\"note warning\">\n<p>这里有些内容不确定：<br />\n《python 网络编程从入门到精通》这本书上写原话是<br />\n <code>可以看到隐式属性有['Test', '__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'os', 'var']</code></p>\n<p>而在网上的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3dwLWJnL3AvOTg1NjMzOS5odG1s\"> https://www.cnblogs.com/cwp-bg/p/9856339.html</span> 博客中这样写的<br />\n <code>可看到隐式的属性有__annotations__,__builtins__,__cached__,__annotations__,__doc__,__file__,__loader__,__name__;</code></p>\n</div>\n<p>我们打印一下每个魔法属性：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token triple-quoted-string string\">'''</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>doc......</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>'''</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> os</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>var <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">\"__main__\"</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\"># print(dir())</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>__name__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>__annotations__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>__builtins__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>__cached__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>__doc__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>__file__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>__loader__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>__package__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>__spec__<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">######### 输出结果 ###############</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>__main__</pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token operator\">&lt;</span>module <span class=\"token string\">'builtins'</span> <span class=\"token punctuation\">(</span>built<span class=\"token operator\">-</span><span class=\"token keyword\">in</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>doc<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>G<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span>Text_Files<span class=\"token operator\">/</span>py<span class=\"token operator\">/</span><span class=\"token number\">1.</span>py</pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token operator\">&lt;</span>_frozen_importlib_external<span class=\"token punctuation\">.</span>SourceFileLoader <span class=\"token builtin\">object</span> at <span class=\"token number\">0x0000018C7E37F8B0</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token comment\">## 空行是打印时就有的</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token comment\"># 其中__name__、__doc__、__file__、__package__是可以直接使用的，其它的内置属性一般不允许直接使用。</span></pre></td></tr></table></figure><h2 id=\"内置魔法属性\"><a class=\"anchor\" href=\"#内置魔法属性\">#</a> 内置魔法属性</h2>\n<ol>\n<li>\n<p>_<em>name</em>_<br />\n该属性代表当前模块的名字，每个 py 文件默认的属性，如果当前模块是主程序，值为 “<strong>main</strong>”，如果不是主程序，值为模块名。这个属性经常用来区分主程序和作为被导入模块的程序。</p>\n</li>\n<li>\n<p>_<em>builtins</em>_<br />\n该属性代表内置模块 builtins，即所有的内建函数、内置类型、内置异常等；在 python 执行一个 py 文件时，会将内置模块赋值给这个属性；如果不是主程序，那么这个属性是一个 builtins 模块所有方法的字典。</p>\n</li>\n<li>\n<p>_<em>doc</em>_<br />\n模块的说明文档，py 文件初始化时，将文件开始的说明字符串赋值给这个属性。</p>\n</li>\n<li>\n<p>_<em>file</em>_<br />\n该属性代表文件的绝对路径，任何一个模块使用这个属性就可获得本模块的绝对路径；但是该属性只在 windows 环境下可用，在 linux 环境下不可用。</p>\n</li>\n<li>\n<p>_<em>cached</em>_<br />\n缓存文件，如果是主程序，那么该属性为 None，其他模块的该属性指向该模块的 pyc 字节文件，这样在 py 文件不发生修改的情况下可以减少编译的时间，更快地加载上下文环境。</p>\n</li>\n<li>\n<p>_<em>annotations</em>_<br />\n该属性对于模块文件来说，没有开放给用户使用；但对于函数来说，这个方法用来记录参数的类型和返回值。</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">get_sum</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>get_sum<span class=\"token punctuation\">.</span>__annotations__<span class=\"token punctuation\">)</span> <span class=\"token comment\">#输出结果 &#123;&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">get_sum</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>get_sum<span class=\"token punctuation\">.</span>__annotations__<span class=\"token punctuation\">)</span> <span class=\"token comment\"># &#123;'y': &lt;class 'int'>, 'return': &lt;class 'int'>&#125;</span></pre></td></tr></table></figure><p>函数的参数和返回值如果在定义的时候指定了类型，那么它们就会以键值对的形式记录到函数的__annotations__属性中，但对于匿名函数来说，这个属性是不存在的。</p>\n<ol start=\"7\">\n<li>\n<p>_<em>loader</em>_<br />\n该属性 py3.3 之前没有，引用了本模块的加载器对象，即该模块的上下文是由这个加载器加载到内存中的。</p>\n</li>\n<li>\n<p>_<em>package</em>_<br />\n该属性是一个文件是否是包的标志，在主程序中该属性的值永远是 None，不要使用它；当一个包被导入到主程序中，该包的__package__属性为包的名字。</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># test</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token operator\">-</span>__init__<span class=\"token punctuation\">.</span>py</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># main.py</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> test</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>test<span class=\"token punctuation\">.</span>__package__<span class=\"token punctuation\">)</span> <span class=\"token comment\"># test</span></pre></td></tr></table></figure><ol start=\"9\">\n<li><em>spec</em><br />\n 该属性记录一个模块的详细信息，是一个 ModuleSpec 对象，</li>\n</ol>\n<h2 id=\"其他魔法属性\"><a class=\"anchor\" href=\"#其他魔法属性\">#</a> 其他魔法属性</h2>\n<ol>\n<li><em>author</em><br />\n 该属性用来定义模块的作者信息，可以是字符串，也可以是列表、字典等数据结构。</li>\n</ol>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 可以在 python 文件中加入</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>__author__ <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">'auth'</span><span class=\"token punctuation\">:</span><span class=\"token string\">'1asy'</span><span class=\"token punctuation\">;</span><span class=\"token string\">'bg'</span><span class=\"token punctuation\">:</span><span class=\"token string\">'https://self-ferry.github.io/'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 或</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>__author__ <span class=\"token operator\">=</span> <span class=\"token string\">'1asy'</span></pre></td></tr></table></figure><ol start=\"2\">\n<li><em>all</em><br />\n 该属性不是模块默认的，需要手动定义，它的功能有二：</li>\n</ol>\n<p>记录一个模块有哪些重要的、对外开发的类、方法或变量等，或记录一个包哪些对外开放的模块；</p>\n<p>限制导入，当使用 <code>“from xxx import *”</code>  形式导入时，实际导入的只有__all__属性中的同名的对象而不是所有，但对于 <code>“from xxx import xxx”</code>  指定了具体的名字则 all 属性被忽略。</p>\n<h2 id=\"魔法方法\"><a class=\"anchor\" href=\"#魔法方法\">#</a> 魔法方法</h2>\n<h3 id=\"_import_\"><a class=\"anchor\" href=\"#_import_\">#</a> _<em>import</em>_</h3>\n<p>该魔法方法是 import 触发，即 <code>import os </code> 相当于 <code>os = __import__('os')</code> ，也可以直接使用，主要用于模块延迟加载，或重载模块。</p>\n<p><span class=\"label\">参数：</span><br />\nname: 模块的名字；<br />\nglobal: 包含全局变量的字典，采用默认值 global ()<br />\n local: 包含局部变量的字典，采用默认值 local ()<br />\n fromlist: 被导入的子模块的名称<br />\n level: 指定使用绝对导入还是相对导入，0 表示只执行绝对导入。</p>\n<p><span class=\"label\">实例</span></p>\n<p>这段代码能在 Linux 下调用 shell</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">loader</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    a <span class=\"token operator\">=</span> <span class=\"token builtin\">__import__</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token builtin\">getattr</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">\"__main__\"</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    loader<span class=\"token punctuation\">(</span><span class=\"token string\">\"os\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"system\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/bin/sh\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>__import__函数返回的是一个变量，代表一个模块，所有后续方法的调用都要在这个变量的基础上。</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3dwLWJnL3AvOTg1NjMzOS5odG1s\">https://www.cnblogs.com/cwp-bg/p/9856339.html</span></p>\n",
            "tags": [
                "python",
                "python内置属性"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/02/01/web%E6%BC%8F%E6%B4%9E-SSRF/",
            "url": "https://self-ferry.github.io/2021/02/01/web%E6%BC%8F%E6%B4%9E-SSRF/",
            "title": "web漏洞-SSRF",
            "date_published": "2021-02-01T11:54:22.000Z",
            "content_html": "<p><span class=\"label success\">✔️嘘，请安静</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=1355292203\"]}]'></div></div>\n<h1 id=\"ssrf的定义与成因\"><a class=\"anchor\" href=\"#ssrf的定义与成因\">#</a> SSRF 的定义与成因</h1>\n<p>SSRF (Server-Side Request Forgery: 服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>\n<p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定 URL 地址获取网页文本内容，加载指定地址的图片，下载等等。</p>\n<p>注释：除了 http/https 等方式可以造成 ssrf，类似 tcp connect 方式也可以探测内网一些 ip 的端口是否开发服务，只不过危害比较小而已。</p>\n<h1 id=\"可能出现的地方\"><a class=\"anchor\" href=\"#可能出现的地方\">#</a> 可能出现的地方</h1>\n<p>1. 社交分享功能：获取超链接的标题等内容进行显示</p>\n<p>2. 转码服务：通过 URL 地址把原地址的网页内容调优使其适合手机屏幕浏览</p>\n<p>3. 在线翻译：给网址翻译对应网页的内容</p>\n<p>4. 图片加载 / 下载：例如富文本编辑器中的点击下载图片到本地；通过 URL 地址加载或下载图片</p>\n<p>5. 图片 / 文章收藏功能：主要其会取 URL 地址中 title 以及文本的内容作为显示以求一个好的用具体验</p>\n<p>6. 云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行 ssrf 测试</p>\n<p>7. 网站采集，网站抓取的地方：一些网站会针对你输入的 url 进行一些信息采集工作</p>\n<p>8. 数据库内置功能：数据库的比如 mongodb 的 copyDatabase 函数</p>\n<p>9. 邮件系统：比如接收邮件服务器地址</p>\n<p>10. 编码处理，属性信息处理，文件处理：比如 ffpmg，ImageMagick，docx，pdf，xml 处理器等</p>\n<p>11. 未公开的 api 实现以及其他扩展调用 URL 的功能：可以利用 google 语法加上这些关键字去寻找 SSRF 漏洞</p>\n<p>一些的 url 中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</p>\n<p>12. 从远程服务器请求资源（upload from url 如 discuz！；import &amp; expost rss feed 如 web blog；使用了 xml 引擎对象的地方 如 wordpress xmlrpc.php）</p>\n<h1 id=\"漏洞验证\"><a class=\"anchor\" href=\"#漏洞验证\">#</a> 漏洞验证</h1>\n<p>1. 排除法：浏览器 f12 查看源代码看是否是在本地进行了请求</p>\n<p>比如：该资源地址类型为  <code>http://www.xxx.com/a.php?image=（地址）</code> 的就可能存在 SSRF 漏洞</p>\n<p>2.dnslog 等工具进行测试，看是否被访问</p>\n<p>-- 可以在盲打后台用例中将当前准备请求的 uri 和参数编码成 base64，这样盲打后台解码后就知道是哪台机器哪个 cgi 触发的请求。</p>\n<p>3. 抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在 HTTP 服务的内网地址</p>\n<p>-- 从漏洞平台中的历史漏洞寻找泄漏的存在 web 应用内网地址</p>\n<p>-- 通过二级域名暴力猜解工具模糊猜测内网地址</p>\n<p>4. 直接返回的 Banner、title、content 等信息</p>\n<p>5. 留意 bool 型 SSRF</p>\n<h1 id=\"利用方式\"><a class=\"anchor\" href=\"#利用方式\">#</a> 利用方式</h1>\n<p>1. 让服务端去访问相应的网址</p>\n<p>2. 让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的 cms</p>\n<p>3. 可以使用 file、dict、gopher [11]、ftp 协议进行请求访问相应的文件</p>\n<p>4. 攻击内网 web 应用（可以向内部任意主机的任意端口发送精心构造的数据包 {payload}）</p>\n<p>5. 攻击内网应用程序（利用跨协议通信技术）</p>\n<p>6. 判断内网主机是否存活：方法是访问看是否有端口开放</p>\n<p>7.DoS 攻击（请求大文件，始终保持连接 keep-alive always）</p>\n<h1 id=\"绕过限制方法\"><a class=\"anchor\" href=\"#绕过限制方法\">#</a> 绕过限制方法</h1>\n<p>详细绕过参考 -----&gt;<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2VjcHVsc2UuY29tL2FyY2hpdmVzLzY1ODMyLmh0bWw=\">https://www.secpulse.com/archives/65832.html</span></p>\n<p>1. <code>http://xxxx.com@www.baidu.com/</code>  与 <code>http://www.baidu.com/</code>  请求时是相同的</p>\n<p>2. 各种 IP 地址的进制转换</p>\n<p>可以是十六进制，八进制等。<br />\n115.239.210.26  &gt;&gt;&gt;  16373751032<br />\n 首先把这四段数字给分别转成 16 进制，结果：73 ef d2 1a<br />\n 然后把 73efd21a 这十六进制一起转换成 8 进制<br />\n记得访问的时候加 0 表示使用八进制 (可以是一个 0 也可以是多个 0 跟 XSS 中多加几个 0 来绕过过滤一样)，十六进制加 0x</p>\n<p>127.0.0.1 =&gt; 2130706433<br />\n<img data-src=\"image001.png\" alt=\"\" /></p>\n<p>3.URL 跳转绕过： <code>http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/</code></p>\n<p>4. 短网址绕过  <code>http://t.cn/RwbLKDx</code></p>\n<p>短网址原理请参考<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy52ZXJ5aXRtYW4uY29tLzIwMTkvMTEvMjQvJUU3JTlGJUFEJUU1JTlDJUIwJUU1JTlEJTgwJUU1JThFJTlGJUU3JTkwJTg2Lw==\"> http://www.veryitman.com/2019/11/24 / 短地址原理 /</span></p>\n<p>5.xip.io 来绕过： <code>http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意）</code></p>\n<p>指向任意 ip 的域名：<span class=\"exturl\" data-url=\"aHR0cDovL3hpcC5pbw==\">xip.io</span> (37signals 开发实现的定制 DNS 服务)</p>\n<p>6. 限制了子网段，可以加 :80 端口绕过。 <code>http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80</code></p>\n<p>7. 探测内网域名，或者将自己的域名解析到内网 ip</p>\n<p>8. 例如  <code>http://10.153.138.81/ts.php</code>  , 修复时容易出现的获取 host 时以 / 分割来确定 host，</p>\n<p>但这样可以用  <code>http://abc@10.153.138.81/</code>  绕过</p>\n<p>9. 利用 Enclosed alphanumerics</p>\n<pre><code class=\"language-txt\">利用Enclosed alphanumerics\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com\nList:\n① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ \n⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ \n⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ \n⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ \nⒶ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ \nⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ \n⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ \n⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿\n</code></pre>\n<h1 id=\"漏洞示例\"><a class=\"anchor\" href=\"#漏洞示例\">#</a> 漏洞示例</h1>\n<p>1.Wordpress3.5.1 以下版本 xmlrpc.php pingback 的缺陷与 ssrf</p>\n<p>2.discuz！的 ssrf （利用 php 的 header 函数来绕过，其实就是 302 跳转实现协议转换）</p>\n<p>3.weblogic 的 ssrf</p>\n<p>.....</p>\n<h1 id=\"漏洞修复\"><a class=\"anchor\" href=\"#漏洞修复\">#</a> 漏洞修复</h1>\n<p>1. 禁止跳转</p>\n<p>2. 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果 web 应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>\n<p>3. 禁用不需要的协议，仅仅允许 http 和 https 请求。可以防止类似于 file://, gopher://, ftp:// 等引起的问题</p>\n<p>4. 设置 URL 白名单或者限制内网 IP（使用 gethostbyname () 判断是否为内网 IP）</p>\n<p>5. 限制请求的端口为 http 常用的端口，比如 80、443、8080、8090</p>\n<p>6. 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly94ei5hbGl5dW4uY29tL3QvMjExNQ==\">https://xz.aliyun.com/t/2115</span><br />\n<span class=\"exturl\" data-url=\"aHR0cDovL2JvYmFvLjM2MC5jbi9sZWFybmluZy9kZXRhaWwvMjQwLmh0bWw=\">http://bobao.360.cn/learning/detail/240.html</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2VjcHVsc2UuY29tL2FyY2hpdmVzLzY1ODMyLmh0bWw=\">https://www.secpulse.com/archives/65832.html</span></p>\n",
            "tags": [
                "web安全",
                "SSRF"
            ]
        },
        {
            "id": "https://self-ferry.github.io/2021/02/01/web%E6%BC%8F%E6%B4%9E-CSRF/",
            "url": "https://self-ferry.github.io/2021/02/01/web%E6%BC%8F%E6%B4%9E-CSRF/",
            "title": "web漏洞-CSRF",
            "date_published": "2021-02-01T11:53:47.000Z",
            "content_html": "<p><span class=\"label success\">✔️嘘，请安静</span></p>\n<div class=\"media-container\"><div class=\"player\" data-type=\"audio\" data-src='[{\"title\":\"列表 1\",\"list\":[\"https://music.163.com/#/song?id=1334246005\"]}]'></div></div>\n<h1 id=\"csrf概念\"><a class=\"anchor\" href=\"#csrf概念\">#</a> CSRF 概念</h1>\n<p>CSRF 跨站点请求伪造 (Cross—Site Request Forgery)，跟 XSS 攻击一样，存在巨大的危害性，你可以这样来理解：</p>\n<blockquote>\n<p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中 Web A 为存在 CSRF 漏洞的网站，Web B 为攻击者构建的恶意网站，User C 为 Web A 网站的合法用户。尽管听起来跟 XSS 跨站脚本攻击有点相似，但事实上 CSRF 与 XSS 差别很大，XSS 利用的是站点内的信任用户，而 CSRF 则是通过伪装来自受信任用户的请求来利用受信任的网站。</p>\n</blockquote>\n<h1 id=\"csrf攻击示意图\"><a class=\"anchor\" href=\"#csrf攻击示意图\">#</a> CSRF 攻击示意图</h1>\n<p><img data-src=\"image001.png\" alt=\"\" /></p>\n<p>首先用户 C 浏览并登录了受信任站点 A；<br />\n登录信息验证通过以后，站点 A 会在返回给浏览器的信息中带上已登录的 cookie，cookie 信息会在浏览器端保存一定时间（根据服务端设置而定）；<br />\n完成这一步以后，用户在没有登出（清除站点 A 的 cookie）站点 A 的情况下，访问恶意站点 B；<br />\n这时恶意站点 B 的某个页面向站点 A 发起请求，而这个请求会带上浏览器端所保存的站点 A 的 cookie；<br />\n站点 A 根据请求所带的 cookie，判断此请求为用户 C 所发送的。<br />\n因此，站点 A 会报据用户 C 的权限来处理恶意站点 B 所发起的请求，而这个请求可能以用户 C 的身份发送 邮件、短信、消息，以及进行转账支付等操作，这样恶意站点 B 就达到了伪造用户 C 请求站点 A 的目的。<br />\n受害者只需要做下面两件事情，攻击者就能够完成 CSRF 攻击：</p>\n<ol>\n<li>登录受信任站点 A，并在本地生成 cookie；</li>\n<li>在不登出站点 A（清除站点 A 的 cookie）的情况下，访问恶意站点 B。</li>\n</ol>\n<p>很多情况下所谓的恶意站点，很有可能是一个存在其他漏洞（如 XSS）的受信任且被很多人访问的站点，这样，普通用户可能在不知不觉中便成为了受害者。</p>\n<h1 id=\"csrf漏洞检测\"><a class=\"anchor\" href=\"#csrf漏洞检测\">#</a> CSRF 漏洞检测：</h1>\n<p>检测 CSRF 漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉 Referer 字段后再重新提交，如果该提交还有效，那么基本上可以确定存在 CSRF 漏洞。</p>\n<p>随着对 CSRF 漏洞研究的不断深入，不断涌现出一些专门针对 CSRF 漏洞进行检测的工具，如 CSRFTester，CSRF Request Builder 等。</p>\n<p>以 CSRFTester 工具为例，CSRF 漏洞检测工具的测试原理如下：使用 CSRFTester 进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在 CSRFTester 中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在 CSRF 漏洞，当然此款工具也可以被用来进行 CSRF 攻击。</p>\n<p>客户端访问服务器时没有同服务器做安全验证</p>\n<p>一切 http 参数可控</p>\n<p>详细 CSRF 检测见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTAxMTIyL2FydGljbGUvZGV0YWlscy8xMDY0MDg3MTQ=\"> https://blog.csdn.net/qq_41901122/article/details/106408714</span></p>\n<h1 id=\"防御csrf攻击\"><a class=\"anchor\" href=\"#防御csrf攻击\">#</a> 防御 CSRF 攻击</h1>\n<h2 id=\"尽量使用post限制get\"><a class=\"anchor\" href=\"#尽量使用post限制get\">#</a> 尽量使用 POST，限制 GET</h2>\n<p>GET 接口太容易被拿来做 CSRF 攻击，看上面示例就知道，只要构造一个 img 标签，而 img 标签又是不能过滤的数据。接口最好限制为 POST 使用，GET 则无效，降低攻击风险。<br />\n当然 POST 并不是万无一失，攻击者只要构造一个 form 就可以，但需要在第三方页面做，这样就增加暴露的可能性。</p>\n<h2 id=\"将cookie设置为httponly\"><a class=\"anchor\" href=\"#将cookie设置为httponly\">#</a> 将 cookie 设置为 HttpOnly</h2>\n<p>CRSF 攻击很大程度上是利用了浏览器的 cookie，为了防止站内的 XSS 漏洞盗取 cookie, 需要在 cookie 中设置 “HttpOnly” 属性，这样通过程序（如 JavaScript 脚本、Applet 等）就无法读取到 cookie 信息，避免了攻击者伪造 cookie 的情况出现。<br />\n在 Java 的 Servlet 的 API 中设置 cookie 为 HttpOnly 的代码如下：<br />\n <code>response.setHeader( &quot;Set-Cookie&quot;, &quot;cookiename=cookievalue;HttpOnly&quot;);</code></p>\n<h2 id=\"增加token\"><a class=\"anchor\" href=\"#增加token\">#</a> 增加 token</h2>\n<p>CSRF 攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于 cookie 中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的 cookie 来通过安全验证。由此可知，抵御 CSRF 攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信总不存在于 cookie 之中。鉴于此，系统开发人员可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务端进行 token 校验，如果请求中没有 token 或者 token 内容不正确，则认为是 CSRF 攻击而拒绝该请求。<br />\n假设请求通过 POST 方式提交，则可以在相应的表单中增加一个隐藏域：<br />\n <code>&lt;input type=&quot;hidden&quot; name=&quot;_toicen&quot; value=&quot;tokenvalue&quot;/&gt;</code> <br />\ntoken 的值通过服务端生成，表单提交后 token 的值通过 POST 请求与参数一同带到服务端，每次会话可以使用相同的 token，会话过期，则 token 失效，攻击者因无法获取到 token，也就无法伪造请求。<br />\n在 session 中添加 token 的实现代码：</p>\n<figure class=\"highlight php\"><figcaption data-lang=\"PHP\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>HttpSession session <span class=\"token operator\">=</span> request<span class=\"token operator\">.</span><span class=\"token function\">getSession</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword type-declaration\">Object</span> token <span class=\"token operator\">=</span> session<span class=\"token operator\">.</span><span class=\"token function\">getAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string double-quoted-string\">\"_token\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>token <span class=\"token operator\">==</span> <span class=\"token constant\">null</span> <span class=\"token constant\">I</span> <span class=\"token constant\">I</span> <span class=\"token string double-quoted-string\">\"\"</span><span class=\"token operator\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    session<span class=\"token operator\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string double-quoted-string\">\"_token\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">UUID</span><span class=\"token operator\">.</span>randomUUIDO <span class=\"token operator\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"通过referer识别\"><a class=\"anchor\" href=\"#通过referer识别\">#</a> 通过 Referer 识别</h2>\n<p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。比如某银行的转账是通过用户访问 <code>http://www.xxx.com/transfer.do</code>  页面完成的，用户必须先登录 <code>www.xxx.com</code> ，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的 Referer 值就会是<br />\n提交按钮所在页面的 URL（本例为 <code>www.xxx. com/transfer.do</code> ）。如果攻击者要对银行网站实施 CSRF 攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的 Referer 的值是其他网站的地址，而不是银行转账页面的地址。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值即可，如果是以 <code>www.xx.om</code>  域名开头的地址，则说明该请求是来自银行网站自己的请求，是合法的；如果 Referer 是其他网站，就有可能是 CSRF 攻击，则拒绝该请求。<br />\n取得 HTTP 请求 Referer：<br />\n <code>String referer = request.getHeader(&quot;Referer&quot;);</code></p>\n<h1 id=\"csrf-绕过referer技巧\"><a class=\"anchor\" href=\"#csrf-绕过referer技巧\">#</a> CSRF-- 绕过 Referer 技巧</h1>\n<p>CSRF 遇到 Referer 绕过的情况，有条件限制，不一定所有的 Refere 验证就可以绕过</p>\n<h2 id=\"referer条件为空条件时\"><a class=\"anchor\" href=\"#referer条件为空条件时\">#</a> referer 条件为空条件时</h2>\n<p>解决方案:</p>\n<p>利用 <code>ftp://, http://, https://, file://, javascript:, data: </code> <br />\n这个时候浏览器地址栏是 <code>file://</code>  开头的，如果这个 HTML 页面向任何 http 站点提交请求的话，这些请求的 Referer 都是空的。</p>\n<p><span class=\"label\">例:</span></p>\n<ol>\n<li>利用 data: 协议</li>\n</ol>\n<figure class=\"highlight html\"><figcaption data-lang=\"HTML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>iframe</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg==<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>bese64 编码 解码即可看到代码</p>\n<ol start=\"2\">\n<li>利用 https 协议</li>\n</ol>\n<p>https 向 http 跳转的时候 Referer 为空<br />\n拿一个 https 的 webshell<br />\n <code>&lt;iframe src=&quot;https://xxxxx.xxxxx/attack.php&quot;&gt;</code></p>\n<p>attack.php 写上 CSRF 攻击代码</p>\n<h2 id=\"判断referer是某域情况下绕过\"><a class=\"anchor\" href=\"#判断referer是某域情况下绕过\">#</a> 判断 Referer 是某域情况下绕过</h2>\n<p>比如你找的 csrf 是 <code>http://xxx.com</code>  验证的 referer 是验证的 <code>*.http://xx.com</code>  可以找个二级域名 之后 <code>&lt;img &quot;csrf地址&quot;&gt;</code>  之后在把文章地址发出去 就可以伪造。</p>\n<h2 id=\"判断referer是否存在某关键字\"><a class=\"anchor\" href=\"#判断referer是否存在某关键字\">#</a> 判断 referer 是否存在某关键字</h2>\n<p>referer 判断存在不存在 <code>http://google.com</code>  这个关键词</p>\n<p>在网站新建一个 <code>http://google.com</code>  目录 把 CSRF 存放在 <code>http://google.com</code>  目录，即可绕过</p>\n<h2 id=\"判断referer是否含有某域名\"><a class=\"anchor\" href=\"#判断referer是否含有某域名\">#</a> 判断 referer 是否含有某域名</h2>\n<p>判断了 Referer 开头是否以 <code>http://126.com</code>  以及 126 子域名 不验证根域名为 <code>http://126.com</code>  那么我这里可以构造子域名 <code>http://x.126.com.xxx.com</code>  作为蠕虫传播的载体服务器，即可绕过。</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82NzQwOGQ3M2M2NmQ=\">https://www.jianshu.com/p/67408d73c66d</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjA2OTczL2FydGljbGUvZGV0YWlscy84NjUwNDc0Nw==\">https://blog.csdn.net/qq_41606973/article/details/86504747</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRjaGF0LmNzZG4ubmV0L2FjdGl2aXR5LzVhMGJhMzQ3ZTFmNzU1NTcxNDgzZWE1YQ==\">https://gitchat.csdn.net/activity/5a0ba347e1f755571483ea5a</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vRmx1b3Jlc2NlbmNlLXRqeS9wLzYxMDAzMTAuaHRtbA==\">https://www.cnblogs.com/Fluorescence-tjy/p/6100310.html</span></p>\n",
            "tags": [
                "web安全",
                "CSRF"
            ]
        }
    ]
}